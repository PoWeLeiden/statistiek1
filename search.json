[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Statistische analyse en presentatie met R",
    "section": "",
    "text": "Voorwoord\nDit boek bevat het R-materiaal voor de cursus Statistiek I.\nWe hebben het boek in twee delen verdeeld:",
    "crumbs": [
      "Voorwoord"
    ]
  },
  {
    "objectID": "index.html#overzicht-per-week",
    "href": "index.html#overzicht-per-week",
    "title": "Statistische analyse en presentatie met R",
    "section": "Overzicht per week",
    "text": "Overzicht per week\nVoor elke week in de cursus moet je relevante hoofdstukken in beide secties lezen. In 2023-2024 is dit:\n\n\n\n\n\n\n\n\nWeek\nWerken met data in R\nStatistische analyse in R\n\n\n\n\n1\n1  Werken met R en RStudio: de basis, par. 1 tot 7\n7  Centrum- en spreidingsmaten\n\n\n2\n1  Werken met R en RStudio: de basis, par. 8\n8  Grafieken maken met ggplot2, 9  Tabellen & 10  R en kansrekening\n\n\n3\n2  Filteren, selecteren en hernoemen\n11  Normaalverdeling & 12  Inferentie voor proporties, par. 1 & 2\n\n\n4\n3  Variabelen maken, samenvatten en hercoderen & 4  Ontbrekende gegevens\n12  Inferentie voor proporties\n\n\n5\n5  Geavanceerd hercoderen van variabelen\n13  Chi-kwadraattoets en associatiematen\n\n\n6\n-\n14  T-toets voor het gemiddelde\n\n\n7\n6  Data combineren\n15  Poweranalyse & 16  ANOVA",
    "crumbs": [
      "Voorwoord"
    ]
  },
  {
    "objectID": "part_working_data.html",
    "href": "part_working_data.html",
    "title": "Werken met data in R",
    "section": "",
    "text": "Dit deel van het materiaal richt zich op het werken met gegevens in R. Je leert hoe je:\n\nBasisprincipes van het gebruik van R en RStudio\nGegevens laden/importeren in R\nGegevens creëren in R\nGegevens wijzigen in R",
    "crumbs": [
      "Werken met data in R"
    ]
  },
  {
    "objectID": "data_01_basics.html",
    "href": "data_01_basics.html",
    "title": "1  Werken met R en RStudio: de basis",
    "section": "",
    "text": "1.1 Interactie met de console: R als rekenmachine gebruiken\nR kan gebruikt worden als een krachtige rekenmachine. Je kunt eenvoudig wiskundige bewerkingen direct op de prompt in de console invoeren. Typ gewoon je rekenkundige bewerkingen en druk op ENTER op Windows-toetsenborden en op RETURN op Mac-toetsenborden.\nVoor eenvoudige rekenkundige bewerkingen gebruikt R de volgende operatoren:1\n+    Optellen\n-    Aftrekken\n*    Vermenigvuldigen\n/    Delen\n^    Machtsverheffen",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Werken met R en RStudio: de basis</span>"
    ]
  },
  {
    "objectID": "data_01_basics.html#interactie-met-de-console-r-als-rekenmachine-gebruiken",
    "href": "data_01_basics.html#interactie-met-de-console-r-als-rekenmachine-gebruiken",
    "title": "1  Werken met R en RStudio: de basis",
    "section": "",
    "text": "1.1.1 Haakjes gebruiken\nAls je 6 en 3 wilt optellen en daarna het resultaat met 2 wilt vermenigvuldigen, moet je haakjes toevoegen. Dit legt een volgorde op voor de berekening van het resultaat (d.w.z. eerst 6 en 3 optellen en dan delen door 2). In het geval van dit voorbeeld, zou je kunnen invoeren\n\n(6 + 3) * 2\n\n[1] 18\n\n\n\n\n1.1.2 Meer complexe vergelijkingen\nJe kunt meer complexe uitdrukkingen schrijven die haakjes en operatoren gebruiken.\nDe volgorde waarin R bovenstaande operatoren uitvoert is2:\n\nhaakjes\nmachtsverheffen en worteltrekken\nvermenigvuldigen en delen van links naar rechts\noptellen en aftrekken van links naar rechts.\n\nNeem de volgende vergelijking:\n\\[\n\\frac{18 * 4^2 - (4+2)}{3} + \\sqrt{16}\n\\]\nJe voert dit als volgt in de RStudio console in:\n\n(18 * 4 ^ 2 - (4 + 2))/3 + sqrt(16)\n\n[1] 98\n\n\nMerk op hoe je de volgorde van evaluatie kunt bepalen door haakjes te gebruiken.\n\nIntern berekent R eerst 18 * 4 ^ 2 (= 288). Het volgt de hierboven beschreven regels, dus er is geen noodzaak om een haakje rond 4^2 te zetten. Exponenten worden berekend vóór de vermenigvuldiging, dus hoeven we dit niet aan te geven via een haakje.\nHiervan trekken we 4 + 2 af (288 - 6 = 282).\nDaarna delen we door 3.\nTen slotte tellen we de wortel van 16 erbij op.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Werken met R en RStudio: de basis</span>"
    ]
  },
  {
    "objectID": "data_01_basics.html#base-r-en-packages",
    "href": "data_01_basics.html#base-r-en-packages",
    "title": "1  Werken met R en RStudio: de basis",
    "section": "1.2 base R en packages",
    "text": "1.2 base R en packages\nWanneer je R downloadt van het Comprehensive R Archive Network (CRAN), krijg je het ‘basis’ R-systeem (‘base R’). Deze software bevat basisfunctionaliteit en implementeert de R-taal. Een van de redenen waarom R zo nuttig is, is echter de grote verzameling van aanvullende pakketten (packages) die de basisfunctionaliteit van R uitbreiden. R-pakketten worden ontwikkeld en gepubliceerd door de grote R-gemeenschap. Er zijn duizenden packages beschikbaar die een breed scala van onderwerpen bestrijken.\nDe primaire locatie voor het verkrijgen van R packages is CRAN. Er zijn enkele bijkomende locaties, maar daar hoef je je voorlopig geen zorgen over te maken.\n\n1.2.1 Installeren en laden van een R package\nOm een package te installeren, gebruik je de install.packages() functie en dan schrijf je de naam van het package. Je moet aanhalingstekens plaatsen rond de naam van het pakket, dus install.packages(\"&lt;de naam van het pakket&gt;\"). Als je bijvoorbeeld het pakket rio wilt installeren (een R-pakket dat het importeren en exporteren van gegevens in R heel snel maakt), dan schrijf je:\n\ninstall.packages(\"rio\")\n\nR installeert automatisch alles wat het nodig heeft. Als je eenmaal een package hebt geïnstalleerd, blijft het op je laptop staan. Het installeren van een R-pakket hoeft dus maar één keer gedaan te worden (totdat je R opnieuw installeert).\n\n\n\n\n\n\nWaarschuwing\n\n\n\nLet op: Packages die nodig zijn voor deze cursus zijn voorgeïnstalleerd op alle PC’s van de Universiteit Leiden. Daarom kan deze stap overgeslagen worden als je op PC’s van de universiteit werkt en kun je ze gewoon laden (zie volgende stap). Als je een eigen laptop gebruikt, moet je het package wel eerst installeren.\n\n\nHet installeren van een package maakt het niet direct beschikbaar voor je in R. Voordat je het package en de bijbehorende functies kunt gebruiken, moet je het in R laden. Om packages in R te laden, wordt de library() functie gebruikt. Bij het laden van een package, gebruik je geen aanhalingstekens. Om het ‘rio’ pakket in R te laden, schrijf je:\n\nlibrary(rio)\n\nAls je een pakket probeert te laden dat niet is geïnstalleerd, krijg je een foutmelding (‘Error in library(rio) : there is no package called 'rio'’).",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Werken met R en RStudio: de basis</span>"
    ]
  },
  {
    "objectID": "data_01_basics.html#r-scripts",
    "href": "data_01_basics.html#r-scripts",
    "title": "1  Werken met R en RStudio: de basis",
    "section": "1.3 R Scripts",
    "text": "1.3 R Scripts\nHet console venster (in RStudio, het onderste linker paneel) is de plaats waar je commando’s rechtstreeks in de console kan typen, maar deze worden vergeten wanneer je R afsluit.\nVaak willen we niet alleen in de console werken, maar willen we onze code bewaren en opslaan. Een veelgebruikte manier om dit te doen is door te werken in een R script. Dit is een tekstbestand dat alle R code bevat die je wilt uitvoeren. Dit houdt alles mooi georganiseerd.\nHet is gemakkelijk om een nieuw script te maken in RStudio. We kunnen daarvoor het menu gebruiken (“File” → “New File” → “R Script”) of met de sneltoets “Command+Shift+N” op een Mac of “Ctrl+Shift+N” op Windows en Linux. Daarna verschijnt de editor als een nieuw deelvenster in de linkerbovenhoek van het RStudio venster.\nIn een R Script kun je alle code schrijven die nodig is voor je project. We zouden bijvoorbeeld deze drie regels kunnen schrijven:\n\nprint(\"Dit is mijn eerste R Script\")\n1+1\n17-8*2\n\n\n1.3.1 R Scripts annoteren\nJe kan commentaar toevoegen door het R Script te annoteren (van commentaar voorzien). Het annoteren maakt het veel gemakkelijker voor jezelf of mensen met wie je samenwerkt. Je gebruikt het symbool # om een annotatie te starten. Wanneer je een commando uitvoert, zal R alles na dit symbool negeren. In een script negeert R alles wat na # komt op de betreffende regel, maar zal het wel de volgende regels weer uitvoeren.\nTerugkomend op het eerdere voorbeeld, stel dat je een commentaar wilt toevoegen na de formule dan kun je schrijven:\n\n(18 * 4 ^ 2 - (5 + 4))/3   # Dit is een prachtige rekensom\n\n\n\n1.3.2 Uitvoeren van code in R scripts\nOm een commando in een R script uit te voeren, heb je verschillende opties:\n\nZet de cursor op de regel van het commando en klik vervolgens op de knop ‘Uitvoeren’ bovenin het bestandsvenster.\nPlaats de cursor op de regel van het commando en druk op CTRL + ENTER op Windows PC’s of COMMAND ⌘ + RETURN Mac.\nU kunt ook de hele regel selecteren en op ‘Uitvoeren’ of CTRL/COMMAND ⌘ + RETURN drukken). Merk op dat als je dit doet je de hele regel moet selecteren. Anders zal R alleen het deel van het commando uitvoeren dat je gemarkeerd hebt.\n\n\n\n\nRMarkdown Visual Mode 1\n\n\nNadat je op ‘Run’ of CTRL + ENTER hebt gedrukt, zal R het commando uitvoeren.\nAls je een annotatie hebt toegevoegd (zie hierboven), zal R de tekst achter # uitsluiten.\nJe kunt natuurlijk meerdere regels uitvoeren. Bijvoorbeeld, als je R Script deze drie commando’s bevat:\n\nprint(\"Dit is mijn eerste R Script\")\n1+1\n17-8*2\n\nJe kunt alles wat je wilt uitvoeren (dus de hele tekst of de eerste twee regels, enz.) selecteren met je muiscursor en dan klikken op de knop ‘Uitvoeren’ bovenin het bestandsvenster of op CTRL + ENTER drukken op Windows PC’s of COMMAND ⌘ + RETURN op Mac.\n\n\n1.3.3 Een bestaand R Script opslaan / openen\nJe kunt je script opslaan door te klikken op File → “Save as…” of door te klikken op het Save icoon bovenaan het Script Editor paneel (sneltoets: CRTL + S of COMMAND ⌘ + S). Als je dat doet, opent zich een venster Save File. Geef het R Script een informatieve naam en open het later. U kunt een bestaand R-script openen via File → “Open file…”",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Werken met R en RStudio: de basis</span>"
    ]
  },
  {
    "objectID": "data_01_basics.html#r-markdown-bestand",
    "href": "data_01_basics.html#r-markdown-bestand",
    "title": "1  Werken met R en RStudio: de basis",
    "section": "1.4 R Markdown bestand",
    "text": "1.4 R Markdown bestand\nEen ander veelgebruikt formaat is het R Markdown bestand. Een R Markdown document is een combinatie van geschreven tekst met simpele opmaak en stukken ingesloten R code (zogenoemde code chunks). Het mooie aan R Markdown is dat je code chunks (en in-line code) kan invoegen om uitvoer en statistische analyse te rapporteren.\nZodra je een RMarkdown bestand exporteert, kun je je tekst omzetten in documenten, rapporten, presentaties en dashboards van hoge kwaliteit.\n\n\n\n\n\n\nOpmerking\n\n\n\nRStudio zal automatisch het benodigde rmarkdown package installeren en laden wanneer nodig.\n\n\n\n\n\n\n\n\nOpmerking\n\n\n\nNaast Rmarkdown bestaat er ook een Quarto document. Dit is een zeer vergelijkbaar type document. Dit boek is gemaakt met behulp van Quarto.\n\n\n\n1.4.1 R Markdown bestanden bewerken\nVoorlopig hoef je niet te weten hoe je R Markdown bestanden maakt. We zullen ze echter in de loop van de cursus gebruiken voor oefeningen en opdrachten, dus je moet weten hoe je erin moet werken.\nR Markdown bestanden hebben de extensie .Rmd. Zodra je ze aanklikt, zou R Studio ze moeten openen. Als dat niet het geval is, kun je ze openen via ” File” → “Open File”. Als je ze voor het eerst opent, zullen ze eruit zien als een R Script (met wat gekleurde code). Het is gemakkelijker om er in te werken in de “Visuele” modus. Op Windows PC’s kun je naar deze modus overschakelen via ‘CTRL + SHIFT + F4’, op Macs via ‘COMMAND ⌘ + SHIFT + F4’. Je kunt ook klikken op de knop ‘Visual’.\n\n\n\nRMarkdown Visual Mode 1\n\n\nOm code uit te voeren, kun je de code selecteren en op ‘CTRL + ENTER’ (‘COMMAND + RETURN’ op Macs) drukken of, als alternatief, op het kleine groene pijltje klikken.\n\n\n\nRMarkdown Visual Mode 2\n\n\nJe kunt de code in het ‘code chunk’ ook aanpassen of nieuwe code toevoegen:\n\n\n\nRMarkdown Visual Mode 3\n\n\nZodra je de code hebt uitgevoerd, zal R de resultaten tonen onder de ‘code chunk’.\n\n\n1.4.2 Een R Markdown bestand ‘knitten’\nJe kunt je markdown-bestand omzetten in een HTML-, PDF- of Word-document dat je kunt uploaden op Brightspace. Klik hiervoor op het Knit icoon dat bovenaan je script. Hierna wordt een document gegenereerd dat zowel de inhoud als de uitvoer van alle ingesloten code chunks in het document bevat.\n\n\n\nKnit button\n\n\nJe kunt je .Rmd bestand opslaan met ” File” → “Save File As…”.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Werken met R en RStudio: de basis</span>"
    ]
  },
  {
    "objectID": "data_01_basics.html#een-r-project-opzetten",
    "href": "data_01_basics.html#een-r-project-opzetten",
    "title": "1  Werken met R en RStudio: de basis",
    "section": "1.5 Een R-project opzetten",
    "text": "1.5 Een R-project opzetten\nWanneer je met R werkt, zal je waarschijnlijk verschillende bestanden hebben: een bestand met de data set, een bestand met je R script (of R Markdown bestand) en misschien output die je bewaart. Om alle bestanden met betrekking tot een project bij elkaar te houden en het overzicht te bewaren, raden we aan een R Project op te zetten.\n\nKlik op “File” → “New Project”\nKlik op “New directory” en dan op “New Project”\nVoer je projectnaam in bij ‘Directory name’ en geef aan in welke map het project komt te staan door op ‘Browse’ te klikken en een map te selecteren. Klik dan op “Create Project” (Project aanmaken)\n\n\n\n\nEen project opzetten in RStudio\n\n\nR zal nu het project aanmaken en de map openen in de Bestanden weergave onderaan het project.\n\n\n\n\n\n\nTip\n\n\n\nStel een Project op voor deze cursus, en bewaar alle opdrachten, oefeningen en gegevensbestanden voor deze cursus in de projectmap/directory.\n\n\nMet “File → Open Project” kun je een bestaand project openen en er verder aan werken.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Werken met R en RStudio: de basis</span>"
    ]
  },
  {
    "objectID": "data_01_basics.html#handmatig-gegevens-invoeren-in-r",
    "href": "data_01_basics.html#handmatig-gegevens-invoeren-in-r",
    "title": "1  Werken met R en RStudio: de basis",
    "section": "1.6 Handmatig gegevens invoeren in R",
    "text": "1.6 Handmatig gegevens invoeren in R\nIn R is de belangrijkste en meest gebruikte manier om gegevens in te voeren de operator met het pijltje naar links (&lt;-). Deze toewijzingsoperator wordt gebruikt om een waarde toe te wijzen.\nDe combinatie object &lt;- inhoud betekent “wijs de waarde van het resultaat van de bewerking aan de rechterkant (‘inhoud’) toe aan het object aan de linkerkant (‘object’)”.\nR kan ook overweg met andere toewijzingsoperatoren, maar onze suggestie is om de &lt;- operator te gebruiken. Dit is de meest conventionele toewijzingsoperator die wordt gebruikt en is wat je zult vinden in alle basis R broncode.\n\n1.6.1 Gegevens opslaan in een object\nR kan omgaan met veel verschillende vormen van invoer (tekst, getallen, data, enz,). Je kan bepalen welk soort gegevens in een object worden opgeslagen. Stel dat we de numerieke waarde 12 willen toewijzen aan een object met de naam my_first_variable.\nWe maken een object aan met de naam my_first_variable (merk op dat er geen spatie in de naam mag staan) en kennen er één waarde (12) aan toe. Om dit in R te doen gebruiken we &lt;-. De code wordt dan:\n\nmy_first_variable &lt;- 12\n\nWe kunnen vervolgens laten printen wat de inhoud van my_first_variable is door de naam in te typen (en daarna de code te draaien):\n\nmy_first_variable \n\n[1] 12\n\n\nAls we het datatype controleren via class(), kunnen we zien dat dit een ‘numeriek’ object is. Dit wordt gebruikt voor getallen.\n\nclass(my_first_variable)\n\n[1] \"numeric\"\n\n\nOp dit punt is het misschien goed om op te merken dat R een hoofdlettergevoelige programmeertaal is. Dit betekent dat alle variabelen, functies en objecten moeten worden aangeroepen met hun exacte spelling. Als je het object my_first_variable probeert aan te roepen door My_first_variable te schrijven (let op de hoofdletter ‘M’), zal R het object niet kunnen vinden en een foutmelding weergeven:\n\nMy_first_variable\n\nError in eval(expr, envir, enclos): object 'My_first_variable' not found\n\n\nNatuurlijk kunnen we ook decimale getallen invoeren. Je moet hiervoor een ‘punt’ als decimaalscheidingsteken gebruiken:\n\nmy_second_variable &lt;- 6.521\nmy_second_variable \n\n[1] 6.521\n\n\nWanneer we de class van dit object inspecteren, zien we dat het weer een numeriek (numeric) object is.\n\nclass(my_second_variable)\n\n[1] \"numeric\"\n\n\nWe kunnen ook tekst opslaan. In R wordt tekst een ‘character’ (karakter) object of ‘string’ (tekenreeks) genoemd. Een string is een stuk tekst dat wordt voorgesteld als een opeenvolging van tekens (letters, cijfers en symbolen). Hij kan uit één of meerdere tekens bestaan. Elke waarde die in R binnen een paar enkele of dubbele aanhalingstekens wordt geschreven, wordt behandeld als een tekenreeks. Het is gebruikelijker om dubbele aanhalingstekens (““) dan enkele aanhalingstekens (’’) rond de tekst te gebruiken. Dit zal een character variabele creëren.\n\na_text_variable &lt;- \"Hallo, wereld\"\na_text_variable\n\n[1] \"Hallo, wereld\"\n\n\nZoals hierboven uitgelegd, kun je dubbele aanhalingstekens of enkele aanhalingstekens gebruiken. Hoewel dit tot hetzelfde resultaat zal leiden, raden we aan dubbele aanhalingstekens te gebruiken.\n\na_text_variable &lt;- 'Hallo wereld'\na_text_variable\n\n[1] \"Hallo wereld\"\n\n\n\n\n1.6.2 Een vector creëren\nTot nu toe bevat ons object slechts één waarde. Als we verschillende waarden willen opslaan, moeten we een vector maken. Vectoren zijn essentiële objecten in R. Zij zijn de bouwsteen voor data frames die wij later zullen behandelen. Laten we een numerieke vector maken die alle getallen van 1 tot 5 en de waarde 8.5 bevat. Om dit te doen gebruiken we c(). De “c” in c() staat voor combineren.\n\nmy_first_vector &lt;- c(1, 2, 3, 4, 5, 8.5)\nmy_first_vector\n\n[1] 1.0 2.0 3.0 4.0 5.0 8.5\n\n\nAls we het datatype controleren via class(), kunnen we zien dat dit een ‘numeriek’ object is. Dit wordt gebruikt als de waarden getallen zijn of als de waarden decimalen bevatten.\n\nclass(my_first_vector)\n\n[1] \"numeric\"\n\n\nWe kunnen ook een vector maken met tekst in plaats van getallen.\n\ncolor_vector &lt;- c(\"blue\", \"red\", \"green\", \"white\", \"black\", \"yellow\")\ncolor_vector\n\n[1] \"blue\"   \"red\"    \"green\"  \"white\"  \"black\"  \"yellow\"\n\n\nZoals hierboven is aangegeven, gebruikt R het datatype karakter' bij het opslaan van tekst. Als we het datatype controleren viaclass()`, kunnen we zien dat dit een ‘character’ object is.\n\nclass(color_vector)\n\n[1] \"character\"\n\n\nKunnen we getallen en tekst combineren? Nee. Vectoren zijn beperkt tot 1 type gegevens (d.w.z. je kunt getallen of tekenreeksen opslaan, maar niet beide). Wat gebeurt er als we getallen en tekenreeksen mixen?\n\nmixed_vector &lt;- c(1, \"red\", 3, \"white\", \"black\", 6)\n\nR maakt de vector, maar maakt er automatisch een character vector van (zie de dubbele aanhalingstekens als we de vector aanroepen en de output van class(mixed_vector)):\n\nmixed_vector\n\n[1] \"1\"     \"red\"   \"3\"     \"white\" \"black\" \"6\"    \n\nclass(mixed_vector)\n\n[1] \"character\"\n\n\n\n\n1.6.3 Variabelen creëren in R\nNu we weten hoe we gegevens moeten opslaan, kunnen we ze gebruiken om categoriale en continue variabelen te maken.\n\n1.6.3.1 Categoriale gegevens: Factors\nVoor categoriale gegevens (nominale en ordinale variabelen), gebruiken we een factor. Factoren worden gebruikt om de gegevens te categoriseren en op te slaan als niveaus. Ze kunnen zowel tekens als getallen (gehele getallen, decimalen) opslaan.\n\n1.6.3.1.1 Nominale variabelen\nStel dat we een nominale variabele met windrichtingen hebben. Eerst maken we een vector als invoer:\n\ndata &lt;- c(\"East\", \"West\", \"East\", \"North\", \"North\", \"East\", \"West\", \"West\", \"West\", \"East\", \"North\")\n\nTot nu toe is dit gewoon een character vector. Als we de inhoud ervan printen krijgen we:\n\ndata\n\n [1] \"East\"  \"West\"  \"East\"  \"North\" \"North\" \"East\"  \"West\"  \"West\"  \"West\" \n[10] \"East\"  \"North\"\n\n\nOm R te laten weten dat dit een categoriale variabele is, moeten we specificeren dat het een factor is. We kunnen dit doen door factor() toe te voegen rond de expressie:\n\ndirections &lt;- factor(c(\"East\", \"West\", \"East\", \"North\", \"North\", \"East\", \"West\", \"West\", \"West\", \"East\", \"North\"))\n\nIntern slaat R deze factoren op als gehele getallen (integers), en gebruikt de strings als labels. Als we de inhoud van dit object laten zien, krijgen we:\n\ndirections\n\n [1] East  West  East  North North East  West  West  West  East  North\nLevels: East North West\n\n\nZoals je kunt zien, behandelt R dit nu als een categoriale (nominale) variabele.\nWe kunnen ook meer informatie krijgen over de unieke waarden van onze factor door levels() te gebruiken3:\n\nlevels(directions)\n\n[1] \"East\"  \"North\" \"West\" \n\n\nHet gebruik van strings voor factoren verdient de voorkeur omdat we de labels kunnen gebruiken voor informatie. Het is natuurlijk mogelijk gehele getallen te gebruiken, d.w.z. 1 voor “Noord” 2 voor “Oost”, 3 voor “Zuid” en 4 voor “West”. Dit kan het echter moeilijk maken om te weten wat de getallen betekenen zonder na te gaan welke labels ze vertegenwoordigen. Daarom raden we aan om strings te gebruiken wanneer je factors maakt.\n\n\n1.6.3.1.2 Ordinale factor niveaus in R\nIn het vorige voorbeeld werd een nominale variabele gebruikt (d.w.z. geen duidelijke ordening van de categorieën). Ordinale variabelen daarentegen hebben een duidelijke rangschikking van de categorieën. Dit kunnen waarden zijn als laag, gemiddeld en hoog. Om dit te doen, maken we factoren met een inherente ordening van de categorieën door levels = c(), ordered = TRUE toe te voegen. Bijvoorbeeld, we kunnen een factor met temperatuur maken met “laag”, “gemiddeld”, “hoog”.\n\ntemperature &lt;- factor(c(\"low\", \"high\", \"medium\", \"high\", \"low\", \"medium\", \"high\"), levels = c(\"low\", \"medium\", \"high\"), ordered = TRUE)\n\n\ntemperature\n\n[1] low    high   medium high   low    medium high  \nLevels: low &lt; medium &lt; high\n\n\n\n\n\n1.6.3.2 Interval-ratiovariabelen\nInterval/ratiogegevens kunnen worden gecodeerd als variabelen met gehele getallen (getallen en decimalen). Om een continue variabele te maken, kunnen we eenvoudigweg een vector met gehele getallen of decimalen maken:\n\nexam_points &lt;- c(2, 7, 3, 4, 2, 0)",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Werken met R en RStudio: de basis</span>"
    ]
  },
  {
    "objectID": "data_01_basics.html#dataframes",
    "href": "data_01_basics.html#dataframes",
    "title": "1  Werken met R en RStudio: de basis",
    "section": "1.7 Dataframes",
    "text": "1.7 Dataframes\nOngetwijfeld één van de krachtigste en meest gebruikte datastructuren in R zijn dataframes (data.frame). Dataframes hebben twee dimensies en bestaan uit meerdere variabelen, één in elke kolom. Elke rij vertegenwoordigt een geval waarover we informatie hebben. Dit is een zeer eenvoudig voorbeeld van een dataframe:\n\n\n  stud_id stud_name grade\n1       1    Arnold   6.5\n2       2       Dan   5.5\n3       3       Ina   7.0\n4       4    George   9.0\n5       5    Sophie   8.5\n\n\nDit voorbeelddataframe bevat informatie over vijf studenten (één per rij). Het bevat drie variabelen: Student ID (stud_id), hun naam (stud_name) en hun cijfer (grade). We hebben dus drie kolommen.\nHet is mogelijk om een dataframe te maken door handmatig gegevens in te voeren; normaal zullen we een dataframe laden vanuit een bestand.\n\n\n\n\n\n\nOpmerking\n\n\n\nJe kunt later de term tibble tegenkomen, wat in wezen hetzelfde is als een dataframe.\n\n\n\n1.7.1 De data bekijken\n\n1.7.1.1 De data in RStudio bekijken\nZodra je gegevens hebt ingevoerd of geladen, toont R studio deze in het ‘Environment pane’ aan de rechterkant. Je kunt op de naam van het dataframe klikken (student.data in ons voorbeeld) om de gegevens in een apart venster te bekijken.\n\n\n\nThe Environment pane\n\n\n\n\n1.7.1.2 Dataframes aanmaken op basis van vectoren\nOm individuele vectoren te combineren tot één dataframe kunnen wij de functie data.frame() gebruiken. Dit voegt vectoren samen: elke vector zal in een aparte kolom staan. Elke rij vertegenwoordigt een geval waarover we informatie hebben. Hieronder maken we drie vectoren (een over de dag van de week, een over de temperatuur op die dag en een factor variabele over het weertype) en combineer ze tot een dataframe met de naam ‘weer’. Merk op dat we factor() gebruiken voor de factorvariabele.\n\ndag &lt;- c(\"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\")\ntemp &lt;- c(7, 5, 7, 8, 8)\ntype &lt;- factor(c(\"bewolkt\", \"buien\", \"regenachtig\", \"bewolkt\", \"regenachtig\"))\nweer &lt;- data.frame(dag, temp, type)\n\nstr(weer)\n\n'data.frame':   5 obs. of  3 variables:\n $ dag : chr  \"maandag\" \"dinsdag\" \"woensdag\" \"donderdag\" ...\n $ temp: num  7 5 7 8 8\n $ type: Factor w/ 3 levels \"bewolkt\",\"buien\",..: 1 2 3 1 3\n\nweer\n\n        dag temp        type\n1   maandag    7     bewolkt\n2   dinsdag    5       buien\n3  woensdag    7 regenachtig\n4 donderdag    8     bewolkt\n5   vrijdag    8 regenachtig\n\n\n\nweer &lt;- data.frame(dag, temp, type)\n\nDit creëert een nieuw dataframe met de naam “weer” dat de drie vectoren “dag”, “temp” en “type” combineert. Vervang de namen van het dataframe en de vectoren door je eigen gegevens.\n\nstr(weer)\n\nDeze code geeft de interne structuur van de dataframe weer.\n\n\n\n\n1.7.1.3 De operator $\nDe operator met het “dollarteken” ($) is nuttig wanneer we werken met dataframes. Ten eerste kan het worden gebruikt om variabelen in dataframes te bekijken. Bijvoorbeeld, we kunnen de variabele “grade” bekijken door te schrijven:\n\nstudent.data$grade\n\n[1] 6.5 5.5 7.0 9.0 8.5\n\n\nWe kunnen ook nieuwe variabelen creëren. Hiervoor gebruiken we de operator ‘&lt;-’. Laten we een nieuwe variabele aanmaken in ons ‘weer’-dataframe: een numerieke variabele over de vochtigheid op die dag.\n\nweer$vochtigheid &lt;- c(71, 84, 89, 76, 85) \nweer\n\n        dag temp        type vochtigheid\n1   maandag    7     bewolkt          71\n2   dinsdag    5       buien          84\n3  woensdag    7 regenachtig          89\n4 donderdag    8     bewolkt          76\n5   vrijdag    8 regenachtig          85\n\n\nZorg ervoor dat het aantal observaties van de nieuwe vectoren gelijk is aan het aantal observaties in het dataframe. Hieronder proberen we bijvoorbeeld nog een variabele over de windsnelheid toe te voegen. Maar omdat deze variabele maar 4 waarnemingen heeft, geeft R een foutmelding:\n\nweer$wind &lt;- c(27, 14, 21, 18) #deze vector heeft slechts 4 observaties\n\nError in `$&lt;-.data.frame`(`*tmp*`, wind, value = c(27, 14, 21, 18)): replacement has 4 rows, data has 5\n\n\n\n\n1.7.1.4 head() and tail()\nAls je een data frame hebt met veel waarnemingen, kan het nuttig zijn om alleen de eerste paar rijen af te drukken. Onze voorbeeldgegevensverzameling is klein, maar we kunnen ze toch gebruiken om het gebruik van de twee functies te illustreren:\n\nhead(student.data)\n\n  stud_id stud_name grade\n1       1    Arnold   6.5\n2       2       Dan   5.5\n3       3       Ina   7.0\n4       4    George   9.0\n5       5    Sophie   8.5\n\nhead(student.data, n = 3)\n\n  stud_id stud_name grade\n1       1    Arnold   6.5\n2       2       Dan   5.5\n3       3       Ina   7.0\n\ntail(student.data, n = 3)\n\n  stud_id stud_name grade\n3       3       Ina   7.0\n4       4    George   9.0\n5       5    Sophie   8.5\n\n\n\nhead(student.data)\n\nDit toont de eerste vijf rijen van een data frame. Vervang student.data door de naam van het juiste data frame als je met eigen data werkt.\n\nhead(student.data, n = 3)\n\nAls we n = … gebruiken, kunnen we aangeven hoeveel rijen met gegevens we willen weergeven, in dit voorbeeld 3 rijen.\n\ntail(student.data, n = 3)\n\ntail() geeft de laatste n rijen gegevens weer. Als je n = … weglaat, worden de laatste 5 rijen gegevens weergegeven.\n\n\n\n\n\n1.7.2 Gegevens in R laden\nJe kunt gegevens importeren in R voor analyse en databewerking (variabele namen veranderen, cases selecteren, de waarden van variabelen hercoderen, etc.).\nMet behulp van de import functie uit het pakket rio, kunnen we verschillende bestandsformaten importeren in R, waaronder Microsoft Excel bestanden, CSV bestanden, SPSS, Stata of R bestanden:\nStel dat we een door komma’s gescheiden waarden (comma-separated values, CSV) bestand willen openen. Een .csv-bestand is het meest gebruikte bestandsformaat voor het opslaan van gegevens. Ons voorbeeldbestand heet “deniro.csv” (beschikbaar hier) en bevat Rotten Tomato beoordelingen van films met Robert De Niro. Er zijn 87 records. We hebben drie variabelen: Year, Rating en Title.\n\n\n\n\n\n\nTip\n\n\n\nZorg ervoor dat je het bestand opslaat in je projectmap, want dat is waar R naar het bestand zal zoeken wanneer je het opent.\n\n\nJe kunt deze dataset in R importeren met de volgende code:\n\nlibrary(rio) \ndeniro_data &lt;- import(\"deniro.csv\") \n\n\nlibrary(rio)\n\nDit laadt het pakket ‘rio’ in R. Je hoeft dit maar één keer te doen aan het begin van je R-sessie.\n\nimport(\"deniro.csv\")\n\nimport() is een functie in het rio pakket die je in staat stelt om bestanden in bijna elk bestandsformaat te importeren. De functie import() leidt het bestandsformaat af uit de extensie van het bestand en roept de juiste data import functie voor je aan, waarbij een data.frame wordt teruggegeven\nIn dit voorbeeld laden we een bestand genaamd deniro.csv en slaan het op in een data frame genaamd deniro_data. Je kunt elke naam opgeven die je wilt voor een dataframe.\n\n\n\n\n\n\n\n\nWaarschuwing\n\n\n\nBelangrijk is dat als je alleen een bestandsnaam invult (hier: deniro.csv), R aanneemt dat dit bestand zich in je huidige werkdirectory bevindt. Als je in een R-project werkt, is deze werkdirectory dezelfde als je projectmap.\n\n\n\n\n\n\n\n\nOpmerking\n\n\n\nAls je projecten hebt met veel bestanden, kan het overzichtelijk zijn om databestanden in een aparte map op te slaan. Als je het bestand deniro.csv bijvoorbeeld in de map data opslaat (binnen je R project), kun je het als volgt laden:\n\nlibrary(rio)\ndeniro_data &lt;- import(\"data/deniro.csv\") \n\n\n\nWe kunnen nu de inhoud van dit dataframe weergeven:\n\nprint(deniro_data)\n\n   Year Score                                   Title\n1  1968    86                               Greetings\n2  1970    17                             Bloody Mama\n3  1970    73                                Hi, Mom!\n4  1971    40                             Born to Win\n5  1973    98                            Mean Streets\n6  1973    88                    Bang the Drum Slowly\n7  1974    97                  The Godfather, Part II\n8  1976    41                         The Last Tycoon\n9  1976    99                             Taxi Driver\n10 1977    47                                    1900\n11 1977    67                      New York, New York\n12 1978    93                         The Deer Hunter\n13 1980    97                             Raging Bull\n14 1981    75                        True Confessions\n15 1983    90                      The King of Comedy\n16 1984    89             Once Upon a Time in America\n17 1984    60                         Falling in Love\n18 1985    98                                  Brazil\n19 1986    65                             The Mission\n20 1987   100 Dear America: Letters Home From Vietnam\n21 1987    80                        The Untouchables\n22 1987    78                             Angel Heart\n23 1988    96                            Midnight Run\n24 1989    64                                Jacknife\n25 1989    47                         We're No Angels\n26 1990    88                              Awakenings\n27 1990    29                          Stanley & Iris\n28 1990    96                              Goodfellas\n29 1991    76                               Cape Fear\n30 1991    69                                Mistress\n31 1991    65                     Guilty by Suspicion\n32 1991    71                               Backdraft\n33 1992    87                            Thunderheart\n34 1992    67                      Night and the City\n35 1993    75                         This Boy's Life\n36 1993    78                       Mad Dog and Glory\n37 1993    96                            A Bronx Tale\n38 1994    39             Mary Shelley's Frankenstein\n39 1995    80                                  Casino\n40 1995    86                                    Heat\n41 1996    74                                Sleepers\n42 1996    38                                 The Fan\n43 1996    80                           Marvin's Room\n44 1997    85                             Wag the Dog\n45 1997    87                            Jackie Brown\n46 1997    72                                Cop Land\n47 1998    68                                   Ronin\n48 1998    38                      Great Expectations\n49 1999    69                            Analyze This\n50 1999    43                                Flawless\n51 2000    43    The Adventures of Rocky & Bullwinkle\n52 2000    84                        Meet the Parents\n53 2000    41                            Men of Honor\n54 2001    73                               The Score\n55 2001    33                              15 Minutes\n56 2002    48                         City by the Sea\n57 2002    27                            Analyze That\n58 2003     4                                 Godsend\n59 2004    35                              Shark Tale\n60 2004    38                        Meet the Fockers\n61 2005     4              The Bridge of San Luis Rey\n62 2005    46                                    Rent\n63 2005    13                           Hide and Seek\n64 2006    54                       The Good Shepherd\n65 2007    21               Arthur and the Invisibles\n66 2007    76                     Captain Shakespeare\n67 2008    19                          Righteous Kill\n68 2008    51                     What Just Happened?\n69 2009    46                        Everybody's Fine\n70 2010    72                                 Machete\n71 2010    10                          Little Fockers\n72 2010    50                                   Stone\n73 2011    25                            Killer Elite\n74 2011     7                          New Year's Eve\n75 2011    70                               Limitless\n76 2012    92                 Silver Linings Playbook\n77 2012    51                             Being Flynn\n78 2012    29                              Red Lights\n79 2013    46                              Last Vegas\n80 2013     7                         The Big Wedding\n81 2013    29                            Grudge Match\n82 2013    11                          Killing Season\n83 2014     9                             The Bag Man\n84 2015    60                                     Joy\n85 2015    26                                   Heist\n86 2015    61                              The Intern\n87 2016    11                           Dirty Grandpa\n\n\n\n\n1.7.3 Een dataframe exporteren\nOm een data frame op te slaan, gebruiken we de export() functie. We zullen het gebruiken om ons data frame met leerlingenscores op te slaan:\n\nexport(student.data, \"student_scores.csv\")\n\n\nexport(student.data, \"student_scores.csv\")\n\nexport() is een functie in het rio pakket waarmee je bestanden in verschillende formaten kunt opslaan. In het haakje geef je de naam van het dataframe op, gevolgd door de naam die je eraan wilt geven en de bestandsextensie (in dit geval een csv-bestand).\n\n\nrio ondersteunt ook de export naar het standaard bestandsformaat van R dat de .rds extensie gebruikt. Om dit te doen, schrijven we:\n\nexport(student.data, \"student_scores.rds\")\n\nHierna kunnen we het weer importeren op dezelfde manier als we eerder deden:\n\nstudent_scores &lt;- import(\"student_scores.rds\")",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Werken met R en RStudio: de basis</span>"
    ]
  },
  {
    "objectID": "data_01_basics.html#sec-data-basics-pipes",
    "href": "data_01_basics.html#sec-data-basics-pipes",
    "title": "1  Werken met R en RStudio: de basis",
    "section": "1.8 De pipe operator |>",
    "text": "1.8 De pipe operator |&gt;\nIn statistische analyses voeren we vaak meerdere bewerkingen uit op een dataset of een enkele variabele. De pipe operator |&gt; (we vertalen deze term niet, maar je zou het ook de ‘pijp-operator’ kunnen noemen) wordt gebruikt om nettere code te schrijven.\nDe pipe operator neemt in principe wat links staat en voert dat in als de eerste parameter aan de rechterkant. Bijvoorbeeld, als we een vector x hebben:\n\nx &lt;- c(1,2,3,4,5)\n\nJe weet dat we het gemiddelde van x als volgt kunnen berekenen:\n\nmean(x)\n\n[1] 3\n\n\nWe kunnen ook de pipe operator gebruiken om deze operatie uit te voeren:\n\nx |&gt; mean()\n\n[1] 3\n\n\nJe kunt deze code lezen als `neem x en plaats dat als eerste argument van de functie mean’.\nDit voorbeeld is natuurlijk triviaal (en normaal gesproken zou je gewoon mean(x) gebruiken), maar het mooie van de pipe operator is dat we meerdere bewerkingen achter elkaar kunnen uitvoeren, bijvoorbeeld:\n\nx |&gt; \n  sqrt() |&gt; \n  mean()\n\n[1] 1.676466\n\n\nIn dit voorbeeld nemen we x, berekenen de vierkantswortel voor elk element van x en nemen dan het gemiddelde hiervan. Het is hetzelfde als schrijven mean(sqrt(x)) . De pipe is een nettere manier om code te schrijven, vooral als je veel opeenvolgende stappen in de pipe hebt. Merk op dat we voor de duidelijkheid de verschillende delen van de pipe meestal op verschillende regels schrijven.\n\n1.8.1 Annoteren van code in de pipe\nAls je annotaties in de pijp wilt opnemen, zet ze dan na de pijp, zoals dit:\n\nx |&gt;\n  sqrt() |&gt;  # Dit berekent de vierkantswortel\n  mean()     # Dit berekent het gemiddelde\n\n[1] 1.676466\n\n\nAls je ze voor de pipe zet, denkt R dat de pipe deel uitmaakt van de annotaties en zal het een error4 weergeven:\n\nx |&gt; \n  sqrt()  Zo moet het het niet doen |&gt;   \n  mean()\n\nDit is de foutmelding:\n\n## Error in mean.default(): argument \"x\" is missing, with no default\n\n\n\n1.8.2 Pipes en dataframes\nWe kunnen de pipe operator ook gebruiken voor dataframes. In hoofdstuk 2 en 3 zullen we leren over verschillende handige functies in het dplyr pakket waarmee we nieuwe variabelen kunnen maken, gegevens kunnen filteren of variabelen kunnen selecteren. Nu weet je dat het simpelweg betekent dat we datgene wat links staat nemen en doorgeven aan de functie rechts.\n\n\n\n\n\n\nOpmerking\n\n\n\nJe kunt %&gt;% tegenkomen in code geschreven door anderen. Dit is ook een pipe operator, die voor onze doeleinden op dezelfde manier werkt als |&gt;.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Werken met R en RStudio: de basis</span>"
    ]
  },
  {
    "objectID": "data_01_basics.html#footnotes",
    "href": "data_01_basics.html#footnotes",
    "title": "1  Werken met R en RStudio: de basis",
    "section": "",
    "text": "Strikt genomen geen operator is de functie sqrt waarmee je de wortel kan trekken:\n\nsqrt(16) \n\n[1] 4\n\n\nDit geeft hetzelfde resultaat als verheffen tot de 1/2e macht:\n\n16^(1/2)\n\n[1] 4\n\n\n↩︎\nDit is een vereenvoudigde weergave. Typ ?Syntax in de Console om de volledige lijst te zien.↩︎\nOnder de motorkap koppelt R elk level aan een getal en bewaart de gegevens op deze manier:\n\nstr(directions)\n\n Factor w/ 3 levels \"East\",\"North\",..: 1 3 1 2 2 1 3 3 3 1 ...\n\n\nIn onze factor staat 1 dus voor East, 2 voor North en 3 vooor West.↩︎\nR verwerkt de pipe operator na sqrt() niet omdat deze na de hashtag (^#) staat en dus deel uitmaakt van de annotaties. Het resultaat is dat R de code x |&gt; sqrt() uitvoert en het resultaat weergeeft. Daarna gaat R door naar de regel mean() en geeft een foutmelding, omdat er geen argumenten zijn voor de functie.↩︎",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Werken met R en RStudio: de basis</span>"
    ]
  },
  {
    "objectID": "data_02_filtering_selecting.html",
    "href": "data_02_filtering_selecting.html",
    "title": "2  Filteren, selecteren en hernoemen",
    "section": "",
    "text": "2.1 Tibbles\nIn hoofdstuk 1 kwamen we al (data frames) tegen. Dataframes zijn een van de ‘originele’ manieren in R om met gegevens te werken. Maar door de manier waarop ze worden weergegeven, kan het soms moeilijk zijn om gegevens erin te veranderen en de inhoud ervan af te drukken.\nEen tibble, of tbl_df, is een moderne ‘versie’ van het dataframe. Tibbles hebben een verfijnde afdrukmethode die standaard alleen de eerste 10 rijen toont, en alle kolommen die op het scherm passen. Tibbles zijn daarom gemakkelijker te gebruiken als je grote datasets hebt die complexe objecten bevatten. Hoewel de hier gebruikte dataset niet bijzonder complex is, is het zinvol om aan tibbles te wennen.\nOm met tibbles te kunnen werken, moet je tidyverse installeren install.packages(\"tidyverse\") (reeds gedaan op universiteitscomputers). We kunnen de tidyverse packages laden door te typen:\nlibrary(tidyverse)\nOm onze dataset om te zetten in een tibble, kunnen we schrijven:\ndeniro_data &lt;- as_tibble(deniro_data)\nAls we nu deniro_data openen zien we dat de manier waarop het dataframe wordt weergegeven is veranderd. Merk op dat er inhoudelijk niets is veranderd. Alle oorspronkelijke variabelen en waarden zijn nog steeds hetzelfde. Het is alleen een visuele verandering:\ndeniro_data \n\n# A tibble: 87 × 3\n    Year Score Title                 \n   &lt;int&gt; &lt;int&gt; &lt;chr&gt;                 \n 1  1968    86 Greetings             \n 2  1970    17 Bloody Mama           \n 3  1970    73 Hi, Mom!              \n 4  1971    40 Born to Win           \n 5  1973    98 Mean Streets          \n 6  1973    88 Bang the Drum Slowly  \n 7  1974    97 The Godfather, Part II\n 8  1976    41 The Last Tycoon       \n 9  1976    99 Taxi Driver           \n10  1977    47 1900                  \n# ℹ 77 more rows",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Filteren, selecteren en hernoemen</span>"
    ]
  },
  {
    "objectID": "data_02_filtering_selecting.html#tibbles",
    "href": "data_02_filtering_selecting.html#tibbles",
    "title": "2  Filteren, selecteren en hernoemen",
    "section": "",
    "text": "deniro_data &lt;- as_tibble(deniro_data)\n\nMet deze code veranderen we het bestaande object deniro_data in een tibble, een dataframe met class tbl_df. Als je met een eigen dataset werkt, moet je de naam aanpassen.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Filteren, selecteren en hernoemen</span>"
    ]
  },
  {
    "objectID": "data_02_filtering_selecting.html#het-selecteren-van-variabelen",
    "href": "data_02_filtering_selecting.html#het-selecteren-van-variabelen",
    "title": "2  Filteren, selecteren en hernoemen",
    "section": "2.2 Het selecteren van variabelen",
    "text": "2.2 Het selecteren van variabelen\nZodra we onze dataset hebben geladen, kunnen we variabelen selecteren. Als we bijvoorbeeld de kolommen (variabelen) betreffende het publicatiejaar (Year) en de titel van de film (Title) willen selecteren, kunnen we schrijven:\n\ndeniro_data |&gt; \n  select(Year, Title)\n\n# A tibble: 87 × 2\n    Year Title                 \n   &lt;int&gt; &lt;chr&gt;                 \n 1  1968 Greetings             \n 2  1970 Bloody Mama           \n 3  1970 Hi, Mom!              \n 4  1971 Born to Win           \n 5  1973 Mean Streets          \n 6  1973 Bang the Drum Slowly  \n 7  1974 The Godfather, Part II\n 8  1976 The Last Tycoon       \n 9  1976 Taxi Driver           \n10  1977 1900                  \n# ℹ 77 more rows\n\n\n\ndeniro_data |&gt;\n\nDit deel van de code haalt één of meerdere kolommen uit deniro_data. Merk op dat we de native pipe operator (|&gt;) gebruiken, zie Paragraaf 1.8.\n\nselect(Year, Title)\n\nHier selecteren we twee kolommen van de tibble, genaamd Year en Title. Merk op dat we, omwille van de stijl, voorstellen om nieuwe opdrachten in een pipe op de volgende regel te zetten (zie overzicht van week 2)\n\n\nEr zijn verschillende speciale functies die binnen select() gebruikt kunnen worden. Het is mogelijk een functie toe te passen op de kolommen en bijvoorbeeld alleen numerieke kolommen te selecteren:\n\ndeniro_data |&gt; \n  select(where(is.numeric))\n\n# A tibble: 87 × 2\n    Year Score\n   &lt;int&gt; &lt;int&gt;\n 1  1968    86\n 2  1970    17\n 3  1970    73\n 4  1971    40\n 5  1973    98\n 6  1973    88\n 7  1974    97\n 8  1976    41\n 9  1976    99\n10  1977    47\n# ℹ 77 more rows\n\n\n\ndeniro_data |&gt;\n\nDit deel van de code haalt één of meerdere kolommen uit deniro_data. Merk op dat we de native pipe operator (|&gt;) gebruiken, zie Paragraaf 1.8.\n\nselect(where(is.numeric))\n\nHier selecteren we alleen de kolommen in deniro_data die numeriek zijn, met behulp van de functie where en is.numeric.\n\n\nselect() kan ook worden gebruikt om kolommen uit een tibble of dataframe te verwijderen. Hiervoor gebruiken we het min-teken:\n\ndeniro_data |&gt; \n  select(-Year, -Title)\n\n# A tibble: 87 × 1\n   Score\n   &lt;int&gt;\n 1    86\n 2    17\n 3    73\n 4    40\n 5    98\n 6    88\n 7    97\n 8    41\n 9    99\n10    47\n# ℹ 77 more rows\n\n\nMerk op dat tot dusver geen van de wijzigingen “permanent” is, omdat het resulterende gegevensframe (tibble) niet wordt “gemaakt” (toegewezen aan een object), maar alleen wordt afgedrukt. Je vraagt R de opdracht uit te voeren in de bestaande dataset en het resultaat af te drukken (niet op te slaan). Als je een variabele permanent wilt selecteren (of verwijderen), moet je een nieuw object maken. Dus als je bijvoorbeeld alleen de kolommen (variabelen) Jaar en Filmtitel wilt behouden in een nieuwe versie van de dataset (new_deniro_data), dan moet je schrijven:\n\nnew_deniro_data &lt;- deniro_data |&gt; \n  select(Year, Title)\n\n\nnew_deniro_data &lt;-\n\nDit deel van de code maakt een nieuw object genaamd “new_deniro_data”.\n\ndeniro_data |&gt; select(Year, Title)\n\nDit deel van de code haalt één of meerdere kolommen uit een dataset.\n\n\nMerk op dat je niet altijd een nieuwe dataset hoeft te maken. Als je de bestaande dataset wilt wijzigen, wijs je het resultaat toe aan een object met dezelfde naam:\n\ndeniro_data &lt;- deniro_data |&gt; \n  select(Year, Title)\n\n\n\n\n\n\n\nWaarschuwing\n\n\n\nDit zal de bestaande deniro_data (zoals deze in het werkgeheugen van R is bewaard) overschrijven met de wijzigingen. Als je terug wilt naar de oorspronkelijke dataset, moet je het bestand opnieuw importeren.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Filteren, selecteren en hernoemen</span>"
    ]
  },
  {
    "objectID": "data_02_filtering_selecting.html#casussen-filteren",
    "href": "data_02_filtering_selecting.html#casussen-filteren",
    "title": "2  Filteren, selecteren en hernoemen",
    "section": "2.3 Casussen filteren",
    "text": "2.3 Casussen filteren\nDe functie filter() wordt gebruikt om de rijen te filteren. Bijvoorbeeld Canadese kiezers die ouder zijn dan 50.\nEr zijn een aantal belangrijke functies en operatoren die nuttig zijn bij het samenstellen van de expressies die worden gebruikt om de gegevens te filteren:\n\n== betekent ‘gelijk aan’.\n!= betekent ‘niet gelijk aan’.\n&lt; betekent ‘kleiner dan’.\n&gt; betekent ‘groter dan’.\n&lt;= betekent ‘gelijk aan of kleiner dan’.\n&gt;= betekent ‘gelijk aan of groter dan’.\n& betekent ‘EN’.\n| betekent ‘OF’.\n! betekent ‘NIET’.\n%in% wordt gebruikt om één van meerdere waarden te selecteren.\n\nOm het gebruik van sommige daarvan te illustreren, gebruiken we de dataset van de Canadian Election Study 2019:\n\ncanada &lt;- import(\"2019 Canadian Election Study.rds\")\n\nWe zetten het dataframe om in een tibble en selecteren voor de overzichtelijkheid slechts een paar variabelen:\n\ncanada &lt;- canada |&gt;\n  as_tibble() |&gt;  \n  select(cps19_gender, cps19_age, cps19_bornin_other)\n\nLaten we aannemen dat we willen filteren op één of meer criteria. Voor een character variable zouden we schrijven:\n\ncanada |&gt;\n  filter(cps19_bornin_other == \"UNITED STATES\")\n\n# A tibble: 407 × 3\n   cps19_gender cps19_age cps19_bornin_other\n   &lt;fct&gt;            &lt;dbl&gt; &lt;fct&gt;             \n 1 A man               25 UNITED STATES     \n 2 A man               68 UNITED STATES     \n 3 A man               63 UNITED STATES     \n 4 A woman             36 UNITED STATES     \n 5 A woman             71 UNITED STATES     \n 6 A woman             59 UNITED STATES     \n 7 A woman             47 UNITED STATES     \n 8 A woman             64 UNITED STATES     \n 9 A woman             65 UNITED STATES     \n10 A man               88 UNITED STATES     \n# ℹ 397 more rows\n\n\n\nfilter(cps19_bornin_other == \"UNITED STATES\")\n\nDe functie filter() wordt gebruikt om een dataframe te filteren, waarbij alle rijen die aan de voorwaarden voldoen worden behouden. Hier vragen we naar respondenten die geboren zijn in de Verenigde Staten.\n\n\n\n\n\n\n\n\nTip\n\n\n\nEen fout die mensen vaak maken bij het filteren van character variables is dat ze de aanhalingstekens vergeten.\n\n\nAls we meerdere geboortelanden willen selecteren, kunnen we gebruik maken van %in%. Hier selecteren we mensen die geboren zijn in Vietnam of Oekraïne:\n\ncanada |&gt; \n  filter(cps19_bornin_other %in% c(\"vietnam\", \"ukraine\"))  # Spelling has to match how it appears in the dataset\n\n# A tibble: 120 × 3\n   cps19_gender cps19_age cps19_bornin_other\n   &lt;fct&gt;            &lt;dbl&gt; &lt;fct&gt;             \n 1 A man               69 ukraine           \n 2 A man               81 ukraine           \n 3 A woman             30 ukraine           \n 4 A man               19 vietnam           \n 5 A woman             42 ukraine           \n 6 A man               41 ukraine           \n 7 A woman             38 ukraine           \n 8 A woman             43 ukraine           \n 9 A man               55 ukraine           \n10 A man               51 ukraine           \n# ℹ 110 more rows\n\n\n\nfilter(cps19_bornin_other %in% c(\"vietnam\", \"ukraine\"))\n\nDe functie filter() wordt gebruikt om een dataframe te filteren, waarbij alle rijen die aan de voorwaarden voldoen worden behouden. In dit geval selecteren we alle respondenten die in Vietnam of Oekaïne zijn geboren. Let op dat je de lijst van opties als vector noteert (met behulp van c()).\n\n\nVoor een numerieke variabele (zoals lengte) gebruiken we de aanhalingstekens niet. Als we bijvoorbeeld respondenten willen selecteren uit de Verenigde Staten van 30 jaar of ouder:\n\ncanada |&gt; \n  filter(cps19_bornin_other == \"UNITED STATES\" & cps19_age &gt;= 30)\n\n# A tibble: 347 × 3\n   cps19_gender cps19_age cps19_bornin_other\n   &lt;fct&gt;            &lt;dbl&gt; &lt;fct&gt;             \n 1 A man               68 UNITED STATES     \n 2 A man               63 UNITED STATES     \n 3 A woman             36 UNITED STATES     \n 4 A woman             71 UNITED STATES     \n 5 A woman             59 UNITED STATES     \n 6 A woman             47 UNITED STATES     \n 7 A woman             64 UNITED STATES     \n 8 A woman             65 UNITED STATES     \n 9 A man               88 UNITED STATES     \n10 A man               72 UNITED STATES     \n# ℹ 337 more rows\n\n\n\nfilter(cps19_bornin_other == \"UNITED STATES\" & cps19_age &gt;= 30)\n\nDe functie filter() wordt gebruikt om een dataframe te filteren, waarbij alle rijen die aan de voorwaarden voldoen worden behouden. Hier vragen we om geboorteland Verenigde Staten en een leeftijd van 30 jaar of ouder.\n\n\nAls je respondenten wilt filteren die geboren zijn in Vietnam of jonger zijn dan 25, gebruik je:\n\ncanada |&gt; \n  filter(cps19_bornin_other == \"Vietnam\" | cps19_age &lt; 25)\n\n# A tibble: 2,858 × 3\n   cps19_gender cps19_age cps19_bornin_other\n   &lt;fct&gt;            &lt;dbl&gt; &lt;fct&gt;             \n 1 A woman             21 &lt;NA&gt;              \n 2 A woman             19 &lt;NA&gt;              \n 3 A man               21 &lt;NA&gt;              \n 4 A woman             19 &lt;NA&gt;              \n 5 A woman             20 &lt;NA&gt;              \n 6 A woman             21 albania           \n 7 A woman             21 &lt;NA&gt;              \n 8 A woman             21 &lt;NA&gt;              \n 9 A man               19 &lt;NA&gt;              \n10 A woman             19 &lt;NA&gt;              \n# ℹ 2,848 more rows\n\n\nJe kunt de bovengenoemde uitdrukkingen toepassen om de data te filteren. De “!” operator werkt een beetje anders, omdat hij alle gevallen selecteert die niet aan een voorwaarde voldoen. Dus, als we bijvoorbeeld alle casussen willen filteren die niet in de Verenigde Staten zijn geboren, zouden we schrijven:\n\ncanada |&gt;\n  filter(!(cps19_bornin_other == \"UNITED STATES\"))\n\n# A tibble: 5,639 × 3\n   cps19_gender cps19_age cps19_bornin_other\n   &lt;fct&gt;            &lt;dbl&gt; &lt;fct&gt;             \n 1 A woman             21 albania           \n 2 A woman             19 colombia          \n 3 A woman             20 india             \n 4 A woman             19 kenya             \n 5 A woman             19 philippines       \n 6 A woman             22 georgia           \n 7 A man               19 philippines       \n 8 A woman             19 afghanistan       \n 9 A woman             21 pakistan          \n10 A woman             19 philippines       \n# ℹ 5,629 more rows\n\n\n\nfilter(!(cps19_bornin_other == \"UNITED STATES\"))\n\nDe functie filter() wordt gebruikt om een dataframe te filteren, waarbij alle rijen die aan de voorwaarden voldoen worden behouden. Hier vragen we alleen gevallen te selecteren die NIET in de Verenigde Staten zijn geboren. Merk op dat we een uitroepteken voor de conditie zetten en dat de conditie tussen haakjes staat.\n\n\nMerk nogmaals op dat geen van de wijzigingen “permanent” is. Je vraagt R gewoon om de opdracht ‘tijdelijk’ uit te voeren in de bestaande dataset. Als je permanent wilt filteren, moet je een nieuw object maken (of toewijzen aan het huidige object). Dus, bijvoorbeeld, als je bijvoorbeeld een dataset wilt maken met alleen de antwoorden van mensen die hun gender niet als man of vrouw omschrijven:\n\nnew_canada &lt;- canada |&gt;\n  filter(cps19_gender == \"Other (e.g. Trans, non-binary, two-spirit, gender-queer)\")\n\n\nnew_canada &lt;-\n\nDit deel van de code maakt een nieuw object genaamd new_canada.\n\ncanada |&gt;\n\nDit deel van de code neemt canada als het begin van onze pipe.\n\nfilter(cps19_gender == \"Other (e.g. Trans, non-binary, two-spirit, gender-queer)\")\n\nDit deel van de code onderwerpt een dataframe aan de opgegeven voorwaarde.\n\n\n\n\n\n\n\n\nTip\n\n\n\nEen fout die mensen vaak maken in filters is het gebruik van slechts één is-gelijk-teken =, waar er twee == zouden moeten staan.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Filteren, selecteren en hernoemen</span>"
    ]
  },
  {
    "objectID": "data_02_filtering_selecting.html#variabelen-hernoemen",
    "href": "data_02_filtering_selecting.html#variabelen-hernoemen",
    "title": "2  Filteren, selecteren en hernoemen",
    "section": "2.4 Variabelen hernoemen",
    "text": "2.4 Variabelen hernoemen\nOm de namen van individuele variabelen te veranderen gebruiken we de rename() functie. Deze gebruikt de volgorde nieuwe_naam = oude_naam om geselecteerde variabelen te hernoemen.\nAls we de kolom cps19_age uit dataset canada willen hernoemen naar age, zou je schrijven:\n\ncanada |&gt;\n  rename(age = cps19_age)\n\n# A tibble: 37,822 × 3\n   cps19_gender   age cps19_bornin_other\n   &lt;fct&gt;        &lt;dbl&gt; &lt;fct&gt;             \n 1 A woman         30 &lt;NA&gt;              \n 2 A woman         21 &lt;NA&gt;              \n 3 A woman         19 &lt;NA&gt;              \n 4 A man           21 &lt;NA&gt;              \n 5 A woman         19 &lt;NA&gt;              \n 6 A woman         20 &lt;NA&gt;              \n 7 A woman         21 albania           \n 8 A woman         21 &lt;NA&gt;              \n 9 A woman         21 &lt;NA&gt;              \n10 A man           19 &lt;NA&gt;              \n# ℹ 37,812 more rows\n\n\nZoals hierboven is opgemerkt, is dit echter geen permanente wijziging. Daarvoor moeten we ervoor zorgen dat het in het bestaande dataframe wordt gewijzigd:\n\ncanada &lt;- canada |&gt;\n  rename(age = cps19_age)\n\n\ncanada &lt;- canada |&gt;\n\nDit deel van de code overschrijft het bestaande dataframe canada.\n\nrename(age = cps19_age)\n\nDit deel van de code hernoemt een variabele met het algemene patroon: &lt;nieuwe_naam&gt; = &lt;oude_naam&gt;.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Filteren, selecteren en hernoemen</span>"
    ]
  },
  {
    "objectID": "data_03_variables.html",
    "href": "data_03_variables.html",
    "title": "3  Variabelen maken, samenvatten en hercoderen",
    "section": "",
    "text": "3.1 Variabelen creëren of wijzigen\nWe kunnen de functie mutate uit package dplyr gebruiken om nieuwe variabelen aan te maken of bestaande variabelen in een dataframe te wijzigen. Het package dplyr wordt geladen als onderdeel van de tidyverse.\nWe gebruiken als voorbeeld de variabele Pop2006, die de bevolking van landen in 2006 bevat:\nhead(dta$Pop2006)\n\n[1]          NA  3137503.17 33347948.22    66900.00 16391381.89    83612.15\nAls we een variabele willen maken die de bevolking in miljoenen registreert, kunnen we de nieuwe variabele als volgt maken:\ndta &lt;- dta |&gt;\n  mutate(Pop2006_million = Pop2006 / 1000000)\nWe kunnen de eerste vijf casussen vergelijken om na te gaan of de transformatie heeft gewerkt zoals bedoeld:\ndta |&gt;\n  select(Pop2006, Pop2006_million) |&gt;   # Selecteer de oorspronkelijke en getransformeerde variabele\n  head()                                # Geef de eerste paar rijen weer\n\n      Pop2006 Pop2006_million\n1          NA              NA\n2  3137503.17      3.13750317\n3 33347948.22     33.34794822\n4    66900.00      0.06690000\n5 16391381.89     16.39138189\n6    83612.15      0.08361215\nAndere voorbeelden van mutaties zijn:\n# Bereken het verschil tussen de bevolking in 2006 en die in 2000\ndta &lt;- dta |&gt;\n  mutate(Pop2006_difference = Pop2006 - Pop2000)\n\n# Neem de vierkantswortel van de bevolking\ndta &lt;- dta |&gt;\n  mutate(Pop2006_squared = sqrt(Pop2006))\n\n# Neem het natuurlijke logaritme van de bevolking\ndta &lt;- dta |&gt;\n  mutate(Pop2006_log = log(Pop2006))  \n\n# Creëer een nieuwe variabele met dezelfde waarde (1) voor alle casussen\ndta &lt;- dta |&gt;\n  mutate(Country = 1)\nBelangrijke dingen over mutate:",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Variabelen maken, samenvatten en hercoderen</span>"
    ]
  },
  {
    "objectID": "data_03_variables.html#variabelen-creëren-of-wijzigen",
    "href": "data_03_variables.html#variabelen-creëren-of-wijzigen",
    "title": "3  Variabelen maken, samenvatten en hercoderen",
    "section": "",
    "text": "dta &lt;- dta |&gt;\n\nDit deel van de code zegt dat we beginnen met het dataframe dta en het resultaat toewijzen aan een dataframe met dezelfde naam. Eigenlijk betekent het: we gaan het dataframe dta veranderen. Als je met je eigen gegevens werkt, zou je dta vervangen door de naam van je eigen dataframe.\nMerk op dat we hier de pipe-operator |&gt; gebruiken, wat betekent dat we het oorspronkelijke dataframe nemen en dit gebruiken in de mutate-functie (zie hieronder).\n\nmutate(...)\n\nDe mutate-functie creëert een nieuwe variabele of verandert een bestaande. Tussen haakjes geven we aan wat voor soort mutatie we willen.\n\nPop2006_million\n\nDit is de naam van de variabele die we aanmaken. Als je niet de naam van een nieuwe variabele schrijft, maar in plaats daarvan de naam van een bestaande variabele gebruikt, zou dit de waarden van die variabele veranderen. Vervang in je eigen gegevens Pop2006_million door de naam van de variabele die je wilt aanmaken.\n\nPop2006 / 1000000\n\nZo willen we deze nieuwe variabele maken, in dit geval door de bestaande variabele Pop2006 te delen door één miljoen. Je kunt elke soort functie of operator toepassen, zolang het maar werkt op een vector (in dit geval: een hele kolom van een dataset).\n\n\n\n\n\n\n\n\nGebruik niet de $ operator om variabelen uit een dataframe te selecteren. Gebruik gewoon de naam van de variabele.\nVergeet niet het resultaat toe te wijzen, d.w.z. begin de code met dta &lt;- dta |&gt; (waarbij je dta vervangt door de naam van je dataset). Als je het resultaat niet toewijst, zal R het gemuteerde dataframe wel afdrukken, maar niet opslaan.\nAls je een mutatie toepast op een dataframe en het resultaat toewijst, zal dit geen uitvoer genereren. Als het succesvol werkt, verandert het gewoon het bestaande dataframe of maakt het een nieuw dataframe. Je kunt vervolgens de gegevens inspecteren om te zien of de transformatie heeft gewerkt.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Variabelen maken, samenvatten en hercoderen</span>"
    ]
  },
  {
    "objectID": "data_03_variables.html#gegevens-samenvatten",
    "href": "data_03_variables.html#gegevens-samenvatten",
    "title": "3  Variabelen maken, samenvatten en hercoderen",
    "section": "3.2 Gegevens samenvatten",
    "text": "3.2 Gegevens samenvatten\nWe kunnen gegevens samenvatten met de functie summarise van pacakge dplyr. Package dplyr wordt geladen als onderdeel van de tidyverse.\n\ndta |&gt;\n  summarise(mean_population = mean(Pop2006, na.rm=TRUE))\n\n  mean_population\n1        34502734\n\n\nDit geeft ons simpelweg de gemiddelde waarde van Pop2006 voor alle landen in de wereld. Het krachtigste gebruik van summarise is in combinatie met group_by. De onderstaande code groepeert bijvoorbeeld landen per continent (DD_un_continent_name) en berekent vervolgens de gemiddelde bevolkingsomvang voor elk continent:\n\ndta |&gt;\n  group_by(DD_un_continent_name) |&gt;\n  summarise(mean_population = mean(Pop2006, na.rm=TRUE))\n\n# A tibble: 6 × 2\n  DD_un_continent_name mean_population\n  &lt;chr&gt;                          &lt;dbl&gt;\n1 \"\"                            32600 \n2 \"Africa\"                   17475659.\n3 \"Americas\"                 25412866.\n4 \"Asia\"                     87338061.\n5 \"Europe\"                   17711125.\n6 \"Oceania\"                   2732066.\n\n\nWe kunnen ook groeperen op basis van meer dan één groeperingsvariabele. Hier berekenen we bijvoorbeeld de gemiddelde bevolking voor democratieën (Cheibub2Type = 0) en dictaturen (Cheibub2Type = 1) in elk continent:\n\ndta |&gt;\n  group_by(DD_un_continent_name, Cheibub2Type) |&gt;\n  summarise(mean_population = mean(Pop2006, na.rm=TRUE))\n\n# A tibble: 15 × 3\n# Groups:   DD_un_continent_name [6]\n   DD_un_continent_name Cheibub2Type mean_population\n   &lt;chr&gt;                       &lt;dbl&gt;           &lt;dbl&gt;\n 1 \"\"                              0            NaN \n 2 \"\"                             NA          32600 \n 3 \"Africa\"                        0       18924251.\n 4 \"Africa\"                        1       16597725.\n 5 \"Americas\"                      0       26786031.\n 6 \"Americas\"                      1       14770838.\n 7 \"Asia\"                          0      138303981.\n 8 \"Asia\"                          1       63553966.\n 9 \"Asia\"                         NA            NaN \n10 \"Europe\"                        0       18538856.\n11 \"Europe\"                        1        7226530.\n12 \"Europe\"                       NA            NaN \n13 \"Oceania\"                       0        3515919.\n14 \"Oceania\"                       1         380506.\n15 \"Oceania\"                      NA            NaN \n\n\nU kunt ook meerdere statistieken laten berekenen:\n\ndta |&gt;\n  group_by(DD_un_continent_name) |&gt;\n  summarise(mean_population = mean(Pop2006, na.rm=TRUE),\n            median_poplation = Median(Pop2006, na.rm=TRUE),  # Mediaan van pacakge DescTools\n            sd_population = sd(Pop2006, na.rm=TRUE))\n\n# A tibble: 6 × 4\n  DD_un_continent_name mean_population median_poplation sd_population\n  &lt;chr&gt;                          &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt;\n1 \"\"                            32600            32600            NA \n2 \"Africa\"                   17475659.         9244288.     25102665.\n3 \"Americas\"                 25412866.         6016000      59575769.\n4 \"Asia\"                     87338061.        14829470.    253704497.\n5 \"Europe\"                   17711125.         7441475.     28476042.\n6 \"Oceania\"                   2732066.          200462.      5920588.\n\n\nAls je het resultaat wilt opslaan in een nieuw dataframe in plaats van het te printen, kun je het resultaat toewijzen. Merk op dat er geen uitvoer is van de onderstaande code chunk omdat het resultaat wordt opgeslagen in het dataframe summary_data:\n\nsummary_data &lt;- dta |&gt;\n  group_by(DD_un_continent_name) |&gt;\n  summarise(mean_population = mean(Pop2006, na.rm=TRUE),\n            median_poplation = Median(Pop2006, na.rm=TRUE), # Mediaan van pacakge DescTools\n            sd_population = sd(Pop2006, na.rm=TRUE))\n\n\n\n\n\n\n\nOpmerking\n\n\n\nHet verschil tussen mutate en summarise is dat mutate een nieuwe waarde creëert voor elke casus in de dataset, terwijl summarise de gegevens samenvat per categorie van de groeperingsvariabele.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Variabelen maken, samenvatten en hercoderen</span>"
    ]
  },
  {
    "objectID": "data_03_variables.html#hercodering-van-variabelen",
    "href": "data_03_variables.html#hercodering-van-variabelen",
    "title": "3  Variabelen maken, samenvatten en hercoderen",
    "section": "3.3 Hercodering van variabelen",
    "text": "3.3 Hercodering van variabelen\nHercodering van variabelen betekent dat we de codering van waarden veranderen. Dit geldt vaak voor nominale of ordinale variabelen (factors), bijvoorbeeld wanneer we bepaalde categorieën willen groeperen.\n\n3.3.1 Hercodering van nominale variabelen\nWe illustreren dit aan de hand van de variabele religion (“Meerderheidsreligie”) die we maken uit Pippa Noris’ Democracy Cross-national Data. Aan het begin van dit hoofdstuk hebben we de dataset al geïmporteerd (dta) en de relevante packages geladen (tidyverse, rio).\nEerst maken we de variabele religion aan met de functie factorize uit rio. Dit creëert een factorversie van de oorspronkelijke (gelabelde numerieke) variabele Fox_emajrel.\n\ndta &lt;- dta |&gt;\n  mutate(religion = factorize(Fox_emajrel))\n\nDe variabele religion kan de volgende waarden aannemen:\n\ntable(dta$religion)\n\n\n            Catholic   Orthodox Christian Protestant Christian \n                  43                   12                   16 \n     Other Christian         Islam, Sunni         Islam, Shi'i \n                   0                   33                    3 \n        Islam, Other             Buddhist                Hindu \n                   1                    8                    2 \n              Jewish              Animist                Other \n                   1                    4                    5 \n     Islam (general)                Mixed  Christian (general) \n                   8                   12                   25 \n\n\nWe zien dat we verschillende grote categorieën hebben en verschillende kleinere categorieën. We zien ook dat verschillende islamitische denominaties en christelijke denominaties zijn opgesplitst. Stel dat wij, met het oog op verdere analyse, de indeling willen vereenvoudigen tot vijf categorieën: Christelijk, Islamitisch, Hindoeïstisch, Boeddhistisch en Overig.\nWe kunnen de functie recode van dplyr gebruiken om de categorieën te hercoderen. Het package dplyr wordt geladen als onderdeel van de tidyverse.\n\ndta &lt;- dta |&gt;\n  mutate(religion_recoded = recode(religion, \n                                   \"Animist\" = \"Other\",\n                                   \"Catholic\" = \"Christian\",\n                                   \"Islam (general)\" = \"Islam\",\n                                   \"Islam, Other\" = \"Islam\",\n                                   \"Islam, Shi'i\" = \"Islam\",\n                                   \"Islam, Sunni\" = \"Islam\",\n                                   \"Jewish\" = \"Other\",\n                                   \"Mixed\" = \"Other\",\n                                   \"Orthodox Christian\" = \"Christian\",\n                                   \"Protestant Christian\" = \"Christian\",\n                                   \"Other Christian\" = \"Christian\",\n                                   \"Christian (general)\" = \"Christian\"\n                                   )\n         )\n\n\nmutate(religion_recoded =\n\nDit deel van de code geeft aan dat we een nieuwe variabele religion_recoded willen aanmaken. Als je met je eigen gegevens werkt, kies je natuurlijk een passende naam.\n\nrecode(religion,\n\nDit deel van de code geeft aan dat we de bestaande variabele religion willen hercoderen. Als je met je eigen gegevens werkt, geef dan de naam op van de bestaande variabele die je wilt hercoderen.\n\n\"Animist\" = \"Other\"\n\nDit zijn de hercodeerstatements, waarbij we de oude naam links en de nieuwe naam rechts tussen dubbele aanhalingstekens (“) schrijven.\nWe kunnen zoveel van deze statements opnemen als we willen. Als we een waarde niet opnemen, blijft deze (standaard) ongewijzigd. We nemen bijvoorbeeld geen statement op voor Other, dus deze waarde zal hetzelfde zijn in de gehercodeerde variabele.\n\n\nDe hercodering heeft de gewenste vijf categorieën opgeleverd:\n\ntable(dta$religion_recoded)\n\n\nChristian     Islam  Buddhist     Hindu     Other \n       96        45         8         2        22 \n\n\nWij kunnen ook nagaan of de oude waarden correct zijn gehercodeerd in de nieuwe waarden:\n\ntable(dta$religion, dta$religion_recoded)\n\n                      \n                       Christian Islam Buddhist Hindu Other\n  Catholic                    43     0        0     0     0\n  Orthodox Christian          12     0        0     0     0\n  Protestant Christian        16     0        0     0     0\n  Other Christian              0     0        0     0     0\n  Islam, Sunni                 0    33        0     0     0\n  Islam, Shi'i                 0     3        0     0     0\n  Islam, Other                 0     1        0     0     0\n  Buddhist                     0     0        8     0     0\n  Hindu                        0     0        0     2     0\n  Jewish                       0     0        0     0     1\n  Animist                      0     0        0     0     4\n  Other                        0     0        0     0     5\n  Islam (general)              0     8        0     0     0\n  Mixed                        0     0        0     0    12\n  Christian (general)         25     0        0     0     0\n\n\n(Zo zijn alle vier de landen met een Animistische meerderheid correct gehercodeerd naar “Other”).\n\n\n3.3.2 Hercodering van ordinale variabelen\nAls je een ordinale variabele hebt die je wilt hercoderen, wil je waarschijnlijk dat de volgorde van de variabele behouden blijft.\nWe hebben bijvoorbeeld de variabele economy die we maken op basis van de Norris-dataset. Het is een classificatie van landen op basis van hun BBP per hoofd van de bevolking. We hebben de dataset al geïmporteerd (dta) en de relevante packages geladen (tidyverse, rio) aan het begin van dit overzicht.\nEerst maken we de variabele economy aan met de functie factorize uit rio. Dit creëert een factorversie van de oorspronkelijke (gelabelde numerieke) variabele TypeEcon2006.\n\ndta &lt;- dta |&gt;\n  mutate(economy = factorize(TypeEcon2006))\n\nDe variabele economy kan de volgende waarden aannemen:\n\ntable(dta$economy)\n\n\n       High ($15,000+) Medium ($2,000-14,999)    Low ($2000 or less) \n                    36                     68                     87 \n\n\nSoms wil men bepaalde categorieën samenvoegen, bijvoorbeeld om de landen van hoog en gemiddeld niveau samen te nemen, maar de volgorde van laag naar hoog behouden. We kunnen dit bereiken met recode_factor:\n\ndta &lt;- dta |&gt;\n  mutate(economy_recoded = recode_factor(economy,\n                                         \"Low ($2000 or less)\" = \"Lower\",\n                                         \"High ($15,000+)\" = \"Higher\",\n                                         \"Medium ($2,000-14,999)\" = \"Higher\",\n                                         .ordered = TRUE)\n         )\n\n\nmutate(economy_recoded\n\nDit deel van de code geeft aan dat we een nieuwe variabele economy_recoded willen aanmaken. Als je met je eigen gegevens werkt, kies je een passende naam voor de hergecodeerde variabele.\n\nrecode_factor(economy,\n\nDit deel van de code geeft aan dat we de bestaande variabele economy willen hercoderen. Als je met je eigen gegevens werkt, geef dan de naam op van de bestaande variabele die je wilt hercoderen.\n\n\"Low ($2000 or less)\"=\"Lower\"\n\nDit zijn de hercodeerstatements, waarbij we de oude naam links en de nieuwe naam rechts tussen dubbele aanhalingstekens (“) schrijven.\nWe kunnen zoveel van deze verklaringen opnemen als we willen. Merk op dat de spelling van de oorspronkelijke categorie precies moet kloppen.\n\n.ordered = TRUE\n\nDit geeft aan dat we een geordende factor willen maken. Let op de punt voor ordered.\n\n\nAls we de eerste paar waarden bekijken, zien we dat de factor geordend is. De volgorde van de factor wordt bepaald door de volgorde waarin je de hercodeerstatements hebt opgegeven (d.w.z. van laag naar hoog):\n\nhead(dta$economy_recoded)\n\n[1] Lower  Lower  Higher Higher Lower  Higher\nLevels: Lower &lt; Higher\n\n\n\n\n3.3.3 Hercodering van numerieke variabelen\nHet hercoderen van numerieke variabelen werkt op dezelfde manier als het hercoderen van norminale of ordinale variabelen.\nNeem als voorbeeld de Freedom House Democracy Ratings voor 2014 (fhrate14), die worden uitgedrukt op een schaal van 1 tot 7. Freedom House gebruikt ook een driepuntsscore: Free (1,0 tot 2,5), Partly Free (3,0 tot 5,0) en Not Free (5,5 tot 7). We hebben de dataset (dta) al geïmporteerd en de relevante packages (tidyverse, rio) geladen aan het begin van dit overzicht.\nWe kunnen de variabele fhrate14 als volgt hercoderen:\n\ndta &lt;- dta |&gt;\n  mutate(fhrate14_recoded = recode(fhrate14,\n                                   \"1\" = 1,\n                                   \"1.5\" = 1,\n                                   \"2.0\" = 1,\n                                   \"2.5\" = 1,\n                                   \"3\" = 2,\n                                   \"3.5\" = 2,\n                                   \"4\" = 2,\n                                   \"4.5\" = 2,\n                                   \"5\" = 2,\n                                   \"5.5\" = 3,\n                                   \"6\" = 3,\n                                   \"6.5\" = 3,\n                                   \"7\" = 3)\n         )\n\n\ntable(dta$fhrate14_recoded)\n\n\n 1  2  3 \n89 55 51 \n\n\n\n\n\n\n\n\nOpmerking\n\n\n\nAls je veel unieke waarden hebt, is dit misschien niet de meest efficiënte manier om een numerieke variabele te hercoderen. In zulke gevallen zal het gebruik van ifelse of case_when efficiënter werken, zie Hoofdstuk 5.1 Er zijn ook andere packages die hercodeerfuncties bieden (zoals recode uit package car of rec uit pacakge sjmisc), maar die zullen we hier niet bespreken.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Variabelen maken, samenvatten en hercoderen</span>"
    ]
  },
  {
    "objectID": "data_03_variables.html#footnotes",
    "href": "data_03_variables.html#footnotes",
    "title": "3  Variabelen maken, samenvatten en hercoderen",
    "section": "",
    "text": "In ons voorbeeld zouden we kunnen gebruiken:\n\ndta &lt;- dta |&gt;\n       mutate(fhrate14_recoded2 = case_when(fhrate14 &lt;= 2.5 ~ 1,\n                                            fhrate14 &lt;= 5 ~ 2,\n                                            fhrate14 &lt;= 7 ~ 3,\n                                            TRUE ~ NA_real_))\ntable(dta$fhrate14_recoded2)\n\n\n 1  2  3 \n89 55 51 \n\n\n↩︎",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Variabelen maken, samenvatten en hercoderen</span>"
    ]
  },
  {
    "objectID": "data_04_missing_data.html",
    "href": "data_04_missing_data.html",
    "title": "4  Ontbrekende gegevens",
    "section": "",
    "text": "4.1 Typen ontbrekende gegevens\nIn R wordt NA gewoonlijk gebruikt om ontbrekende gegevens aan te geven, maar als we datasets laden in een SPSS-, Stata- of ander bestandsformaat, kunnen ontbrekende gegevens andere codes hebben. Vaak is dit soort informatie te vinden in het codeboek, een apart bestand (vaak een PDF) dat de dataset en zijn variabelen beschrijft.\nEen voorbeeld is de variabele cps19_pidtrad (Traditional party identification) uit de 2019 Canadian Election Study (hierboven geopend):\nlevels(canada$pes19_pidtrad)\n\n[1] \"Liberal\"                          \"Conservative\"                    \n[3] \"NDP\"                              \"Bloc Québécois\"                  \n[5] \"Green\"                            \"People’s Party\"                  \n[7] \"Another party (please specify)\"   \"None of these\"                   \n[9] \"Don't know/ Prefer not to answer\"\nDeze variabele heeft een categorie “Geen van deze” en “Weet niet/wil niet antwoorden”, die voor de meeste analyses als ontbrekende gegevens moeten worden behandeld. Momenteel worden ze echter als gewone antwoordcategorieën behandeld.\nDit type probleem kan ook optreden bij interval-ratiovariabelen (numerieke variabelen), waar in sommige gevallen getallen als 999 worden gebruikt om ontbrekende waarden aan te geven. Let op: Dit raden wij niet aan, maar je kunt het tegenkomen in echte gegevens waar je mee werkt.\nHieronder staat een voorbeeld waarin de waarde 999 is gebruikt om ontbrekende gegevens aan te geven. Als we het gemiddelde voor deze variabele berekenen zonder R te vertellen dat 999 eigenlijk ontbrekende gegevens zijn, zullen we de gemiddelde leeftijd overschatten:\ndata_age &lt;- data.frame(age = c(55, 64, 37, 56, 999, 42, 47, 22, 49, 68, 59, 999))\nmean(data_age$age)\n\n[1] 208.0833\nDit resultaat is natuurlijk onjuist omdat we de missende waarden niet als zodanig behandelen en als geldige waarde hebben gebruikt.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ontbrekende gegevens</span>"
    ]
  },
  {
    "objectID": "data_04_missing_data.html#typen-ontbrekende-gegevens",
    "href": "data_04_missing_data.html#typen-ontbrekende-gegevens",
    "title": "4  Ontbrekende gegevens",
    "section": "",
    "text": "Tip\n\n\n\nWij raden aan altijd de niveaus of waarden van een variabele te controleren op waarden die we mogelijk als missend willen beschouwen.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ontbrekende gegevens</span>"
    ]
  },
  {
    "objectID": "data_04_missing_data.html#hercodering-van-ontbrekende-gegevens",
    "href": "data_04_missing_data.html#hercodering-van-ontbrekende-gegevens",
    "title": "4  Ontbrekende gegevens",
    "section": "4.2 Hercodering van ontbrekende gegevens",
    "text": "4.2 Hercodering van ontbrekende gegevens\nAls er waarden in de gegevens zitten die je als missend wilt behandelen, kun je na_if uit package dplyr gebruiken. Package dplyr wordt geladen als onderdeel van de tidyverse.\n\ncanada &lt;- canada |&gt;\n  mutate(pes19_pidtrad = na_if(pes19_pidtrad, \n                               \"Don't know/ Prefer not to answer\")) |&gt;\n  mutate(pes19_pidtrad = na_if(pes19_pidtrad, \n                               \"None of these\")) |&gt;\n  mutate(pes19_pidtrad = droplevels(pes19_pidtrad))\n\ntable(canada$pes19_pidtrad, useNA = \"ifany\") # Geef tabel weer met NAs\n\n\n                       Liberal                   Conservative \n                          1746                           1501 \n                           NDP                 Bloc Québécois \n                           693                            186 \n                         Green                 People’s Party \n                           274                             64 \nAnother party (please specify)                           &lt;NA&gt; \n                            23                          33335 \n\n\n\nmutate(pes19_pidtrad = ...\n\nWe gaan de bestaande variabele pes19_pidtrad wijzigen.\n\nna_if(pes19_pidtrad, \"Don't know/ Prefer not to answer\")\n\nDeze functie verandert bepaalde waarden in een variabele in NA . In dit voorbeeld willen we de waarden van \"Weet niet/antwoord liever niet\" van pes19_pidtrad veranderen in ontbrekende waarden (NA). Voor je eigen gegevens moet je de juiste variabelenaam invoegen en de waarde die je wilt veranderen in NA.\n\nmutate(pes19_pidtrad = droplevels(pes19_pidtrad))\n\nTen slotte gebruiken we droplevels om ervoor te zorgen dat factor levels van pes19_pidtrad die we als missend aanduiden ook als factor level worden verwijderd, zodat deze in eventuele latere analyses volledig worden genegeerd. Dit is niet nodig voor andere soorten variabelen (numeric of character).\n\n\nWe zien dat er geen respondenten meer zijn die “Geen van deze” of “Weet niet/wil niet antwoorden” antwoorden. Noot: Omdat we twee waarden hebben die we willen veranderen in NA, hebben we twee mutate statements.\nDit werkt ook voor het vervangen van numerieke waarden, zoals in ons data_age voorbeeld. Hier willen we de waarde van 999 veranderen in NA:\n\ndata_age &lt;- data_age |&gt;\n  mutate(age = na_if(age, 999))\ndata_age$age\n\n [1] 55 64 37 56 NA 42 47 22 49 68 59 NA\n\n\nEn het gemiddelde wordt correct berekend na hercodering van de ontbrekende waarden:\n\nmean(data_age$age, na.rm=TRUE)\n\n[1] 49.9\n\n\nOpmerking: het is beter om na_if te gebruiken dan recode om ontbrekende waarden te hercoderen.1",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ontbrekende gegevens</span>"
    ]
  },
  {
    "objectID": "data_04_missing_data.html#wegfilteren-van-ontbrekende-gegevens",
    "href": "data_04_missing_data.html#wegfilteren-van-ontbrekende-gegevens",
    "title": "4  Ontbrekende gegevens",
    "section": "4.3 Wegfilteren van ontbrekende gegevens",
    "text": "4.3 Wegfilteren van ontbrekende gegevens\nU kunt ontbrekende gegevens wegfilteren met de functie is.na:\n\ndta |&gt;\n  filter(!is.na(Pop2006)) |&gt;\n  select(Nation, Pop2006) |&gt;\n  head()\n\n             Nation     Pop2006\n1           Albania  3137503.17\n2           Algeria 33347948.22\n3           Andorra    66900.00\n4            Angola 16391381.89\n5 Antigua & Barbuda    83612.15\n6         Argentina 39120455.54\n\n\n\nfilter(!is.na(Pop2006))\n\nWe filteren de gevallen met een niet-ontbrekende waarde op de variabele Pop2006. Let op de ! die niet betekent, dus we willen alleen gevallen die geen ontbrekende waarde hebben op Pop2006.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ontbrekende gegevens</span>"
    ]
  },
  {
    "objectID": "data_04_missing_data.html#footnotes",
    "href": "data_04_missing_data.html#footnotes",
    "title": "4  Ontbrekende gegevens",
    "section": "",
    "text": "De reden is dat als je recode gebruikt om te hercoderen naar ontbrekende waarden, je R precies moet vertellen welk type ontbrekende gegevens je hebt, bijvoorbeeld NA_character_ in plaats van gewoon NA voor een character variabele. Anders krijg je incompatibele vectorproblemen die je beter kunt vermijden.↩︎",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ontbrekende gegevens</span>"
    ]
  },
  {
    "objectID": "data_05_advanced_recoding.html",
    "href": "data_05_advanced_recoding.html",
    "title": "5  Geavanceerd hercoderen van variabelen",
    "section": "",
    "text": "5.1 Variabelen hercoderen met case_when\nVaak moeten we data wijzigen of transformeren op basis van verschillende mogelijke condities. We kunnen dit doen met de case_when() functie uit het dplyr package.\nWe zullen het gebruik van deze functie illustreren met behulp van een dataset met GPA-cijfers beschikbaar in het openintro package.\nHet dataframe bevat de variabelen gpa en study_hours voor een steekproef van 193 studenten die in 2012 een inleidende cursus statistiek volgden aan een particuliere Amerikaanse universiteit. De gegevens zijn hieronder weergegeven als tibble:\nlibrary(openintro) # In dit package is de dataset gpa_study_hours opgenomen\nlibrary(tidyverse) # Nodig om een tibble te kunnen maken en weergeven\nas_tibble(gpa_study_hours)\n\n# A tibble: 193 × 2\n     gpa study_hours\n   &lt;dbl&gt;       &lt;dbl&gt;\n 1  4             10\n 2  3.8           25\n 3  3.93          45\n 4  3.4           10\n 5  3.2            4\n 6  3.52          10\n 7  3.68          24\n 8  3.4           40\n 9  3.7           10\n10  3.75          10\n# ℹ 183 more rows\nStel dat we de numerieke “gpa”-scores willen hercoderen naar een karaktervariabele “grades” die de letter “A” als hoogste cijfer hanteert. Omwille van de eenvoud maken we geen onderscheid in A+, A, A-, enz. maar richten we ons alleen op “hele cijfers” (A, B, C, enz.).\nVolgens een gangbare cijferomrekening willen wij dat de uitkomst is: A (GPA tussen 3,7 - 4,0), B (2,7 - 3,3), C (1,7 – 2,3), D (1,0 – 1,3). De letter F als cijfer komt overeen met een 0,0 GPA. Onze hercoderingsregels zijn dus:\ncase_when() werkt door aan twee “kanten” informatie te geven: aan de “linkerkant” staat een conditie en aan de “rechterkant” hebben we de waarde als deze voorwaarde waar is. Beide worden gescheiden door een tilde (~):\ncase_when(conditie ~ waarde)\nEr zijn een aantal belangrijke functies en operatoren die nuttig zijn bij het construeren van de expressies die worden gebruikt om de gegevens te hercoderen:\nMet behulp van onderstaande code kunnen we het numerieke cijfer hercoderen naar een letter (grade) van A t/m F:\ngpa_study_hours &lt;- gpa_study_hours |&gt;\n  mutate(gpa_grade = case_when(\n    gpa &gt;= 3.7 ~ \"A\",\n    gpa &gt;= 2.7 ~ \"B\",\n    gpa &gt;= 1.7 ~ \"C\",\n    gpa &gt;= 1.3 ~ \"D\",\n    gpa &lt; 1.3 ~ \"F\"))  # Let op de twee haakjes: één om case_when af te sluiten en één om mutate af te sluiten\ngpa_study_hours\n\n# A tibble: 193 × 3\n     gpa study_hours gpa_grade\n   &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;    \n 1  4             10 A        \n 2  3.8           25 A        \n 3  3.93          45 A        \n 4  3.4           10 B        \n 5  3.2            4 B        \n 6  3.52          10 B        \n 7  3.68          24 B        \n 8  3.4           40 B        \n 9  3.7           10 A        \n10  3.75          10 A        \n# ℹ 183 more rows\nWe zullen meestal te maken krijgen met het hercoderen van numerieke variabelen of karaktervariabelen. Zorg ervoor dat je aanhalingstekens gebruikt rond karaktervariabelen. Als je bijvoorbeeld de karaktervariabele gpa_grade wilt hercoderen naar een numerieke variabele gpa_num (die de waarden 1, 2, 3, 4, 6 heeft), dan schrijf je:\ngpa_study_hours &lt;- gpa_study_hours |&gt;\n  mutate(gpa_num = case_when(\n    gpa_grade == \"A\" ~ 1,\n    gpa_grade == \"B\" ~ 2,\n    gpa_grade == \"C\" ~ 3,\n    gpa_grade == \"D\" ~ 4,\n    gpa_grade == \"F\" ~ 6))\nAls je een numerieke variabele wilt hercoderen naar een numerieke variabele, gebruik je natuurlijk geen aanhalingstekens. Die worden alleen gebruikt als één van de variabelen een tekenvariabele is.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Geavanceerd hercoderen van variabelen</span>"
    ]
  },
  {
    "objectID": "data_05_advanced_recoding.html#variabelen-hercoderen-met-case_when",
    "href": "data_05_advanced_recoding.html#variabelen-hercoderen-met-case_when",
    "title": "5  Geavanceerd hercoderen van variabelen",
    "section": "",
    "text": "Als de score groter of gelijk is aan 3,7, transformeren we dit in een “A”.\nAnders, als de score groter is dan of gelijk aan (&gt;=) 2,7, een “B” toekennen.\nAnders, als de score groter is dan of gelijk is aan (&gt;=) 1.7, geef dan een “C”.\nAnders, als de score groter of gelijk is aan (&gt;=) 1.3, geef dan een “D”.\nAnders een “F” toekennen\n\n\n\n\n\n== betekent “gelijk aan”\n!= betekent “niet gelijk aan”.\n&lt; betekent “kleiner dan”\n&gt; betekent “groter dan”\n&lt;= betekent “gelijk aan of kleiner dan”\n&gt;= betekent “gelijk aan of groter dan”\n& betekent “EN”.\n| betekent “OF”.\n! betekent “NIET”.\n\n\n\n\n\n\n\nOpmerking\n\n\n\nOm case_when() te gebruiken, moeten we R vertellen waar het resultaat moet worden opgeslagen: ofwel door het resultaat toe te wijzen aan de huidige variabele, ofwel door het toe te wijzen aan een nieuwe variabele in onze hercoderingsprocedure. Hiervoor gebruiken we mutate(). Het is erg belangrijk dat je een nieuwe variabele specificeert met mutate() tijdens het hercoderen (of een bestaande variabele die wordt overschreven). Anders weet R niet waar het de nieuwe, hergecodeerde gegevens moet plaatsen.\n\n\n\n\n\ngpa_study_hours &lt;-\n\nDit eerste deel van de code zegt dat we het bestaande dataframe gpa_study_hours overschrijven.\n\ngpa_study_hours |&gt;\n\nDit deel van de code geeft aan dat we werken met de gpa_study_hours dataset. |&gt; is the pipe operator.\n\nmutate(gpa_grade = case_when(\n\nHier creëren we een nieuwe variabele genaamd gpa_grade met behulp van mutate(). De inhoud van de nieuwe variabelen bepalen we met case_when(. Voor je eigen gegevens moet je de naam van de nieuwe variabele veranderen.\n\ngpa &gt;= 3.7 ~ \"A\",\n\nHier beginnen we met het specificeren van onze condities en de bijbehorende waardes. Als de GPA scores (variabele gpa) gelijk is aan of groter dan 3,7, wordt de uitkomstvariabele (gpa_grade) gelijk aan \"A\" (let op de aanhalingstekens rond de letter).\nNoot: de algemene vorm is dus conditie ~ waarde . Meerdere statements worden gescheiden door een komma.\n\ngpa &gt;= 2.7 ~ \"B\", gpa &gt;= 1.7 ~ \"C\", gpa &gt;= 1.3 ~ \"D\",\n\nHier gaan we verder met het specificeren van onze condities en de bijbehorende waarden. Elke nieuwe regel betekent in wezen “en ander als”, d.w.z. anders als gpa gelijk is aan of groter dan 2,7 wijs een \"B\" toe, anders als gpa gelijk is aan of groter dan 1,7 wijs een \"C\" toe, enzovoorts.\n\ngpa &lt; 1.3 ~ \"F\"))\n\nTen slotte bepalen wij dat de letter F moet worden toegekend aan alle gpa-waarden kleiner dan 1,3.\n\n\n\n\n\n\n\n\nOpmerking\n\n\n\nAls geen van de bovenstaande condities waar is (bijvoorbeeld als gpa een missende waarde (NA) heeft), dan geeft case_when een missende waarde (NA) voor die casus.\n\n\n\n\n\n\n\n\nTip\n\n\n\nDe case_when() functie is zeer veelzijdig en kan gebruikt worden om verschillende situaties aan te pakken. Het is bijvoorbeeld mogelijk om verschillende statements met elkaar te combineren met behulp van “AND” of “OR” statements. Wie meer wil weten, kan de RDocumentatie van het package bekijken hier.\n\n\n\n\n\ngpa_study_hours &lt;-\n\nDit eerste deel van de code geeft aan dat we de bestaande dataframe gpa_study_hours overschrijven.\n\ngpa_study_hours |&gt;\n\nDit deel van de code geeft aan dat we werken met de gpa_study_hours dataset. |&gt; is the pipe operator.\n\nmutate(gpa_num = case_when(\n\nHier creëren we een nieuwe variabele genaamd gpa_num met behulp van mutate(). De inhoud van de nieuwe variabelen bepalen we met case_when(. Voor je eigen gegevens moet je de naam van de nieuwe variabele veranderen.\n\ngpa_grade == \"A\" ~ 1,\n\nHier beginnen we met het specificeren van onze condities en de bijbehorende uitvoerwaarden. Omdat gpa_grade een karaktervariabele is, gebruiken we dubbele aanhalingstekens. Het GPA-cijfer \"A\" moet worden gehercodeerd in het getal 1 (zonder aanhalingstekens).\n\ngpa_grade == \"B\" ~ 2, gpa_grade == \"C\" ~ 3, gpa_grade == \"D\" ~ 4,\n\nHier gaan we verder met het specificeren van onze condities en bijbehorende waarden.\n\ngpa_grade == \"F\" ~ 6))\n\nTenslotte geven we aan dat het cijfer 6 moet worden toegekend aan alle waarden met een \"F\" in gpa_grade.\n\n\n\n\n5.1.1 Meervoudige vergelijkingen\nDe voorwaarden gebruikt door case_when kunnen verwijzen naar meerdere variabelen. In het onderstaande voorbeeld willen we een variabele cum laude berekenen, die gelijk is aan 1 wanneer de gpa 3,3 of hoger is en het aantal studie-uren meer dan 30 bedraagt, en anders gelijk is aan 0:\n\ngpa_study_hours &lt;- gpa_study_hours |&gt;\n  mutate(cum_laude = case_when(\n    gpa &gt;= 3.3 & study_hours &gt; 30 ~ 1, \n    gpa &gt;= 3.3 ~ 0,\n    gpa &lt; 3.3 ~ 0))\n\n\nmutate(cum_laude = case_when(\n\nHier creëren we een nieuwe variabele genaamd cum_laude met behulp van mutate().\n\ngpa &gt;= 3.3 & study_hours &gt; 30 ~ 1,\n\nOnze eerste voorwaarde is dat gpa 3.3 of hoger moet zijn en dat study_hours groter dan 30 moet zijn. Als aan deze voorwaarde is voldaan, zal cum_laude gelijk zijn aan 1.\n\ngpa &gt;= 3.3 ~ 0, gpa &lt; 3.3 ~ 0))\n\nWe moeten ook de alternatieven specificeren. Ten eerste, als niet aan de vorige conditie is voldaan, maar gpa is hoger dan 3.3, wijs dan een 0 toe. Daarnaast, als niet aan de vorige conditie is voldaan, maar gpa is lager dan 3.3, wijs dan een 0 toe aan de nieuwe variabele cum_laude.\n\n\nDoor de eerste 10 rijen te printen en te inspecteren, kunnen we nagaan of de hercodering heeft gewerkt zoals bedoeld:\n\ngpa_study_hours\n\n# A tibble: 193 × 5\n     gpa study_hours gpa_grade gpa_num cum_laude\n   &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;\n 1  4             10 A               1         0\n 2  3.8           25 A               1         0\n 3  3.93          45 A               1         1\n 4  3.4           10 B               2         0\n 5  3.2            4 B               2         0\n 6  3.52          10 B               2         0\n 7  3.68          24 B               2         0\n 8  3.4           40 B               2         1\n 9  3.7           10 A               1         0\n10  3.75          10 A               1         0\n# ℹ 183 more rows\n\n\n\n\n\n\n\n\nWaarschuwing\n\n\n\nAls je met je eigen (bestaande) datasets werkt, kijk dan goed naar de ‘bestaande’ variabelen, d.w.z. de variabelen die je wilt hercoderen. Zorg ervoor dat je alle alternatieven correct specificeert, vooral als je gegevens missende waarden (NA) hebben op één (of meerdere) variabelen. Na hercodering raden wij je aan de uitkomstvariabele zorgvuldig te inspecteren om te zien of de uitkomst precies is zoals je hem bedoeld had. Dat kan bijvoorbeeld door een kruistabel te maken van de oude en nieuwe variabele.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Geavanceerd hercoderen van variabelen</span>"
    ]
  },
  {
    "objectID": "data_06_merging_data.html",
    "href": "data_06_merging_data.html",
    "title": "6  Data combineren",
    "section": "",
    "text": "6.1 Datasets combineren: rijen of kolommen toevoegen",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data combineren</span>"
    ]
  },
  {
    "objectID": "data_06_merging_data.html#datasets-combineren-rijen-of-kolommen-toevoegen",
    "href": "data_06_merging_data.html#datasets-combineren-rijen-of-kolommen-toevoegen",
    "title": "6  Data combineren",
    "section": "",
    "text": "6.1.1 Rijen toevoegen\nAls we twee datasets hebben met dezelfde kolommen (variabelen), kunnen we de rijen van de twee datasets samenvoegen met bind_rows uit package dplyr (dit package wordt geladen met de tidyverse).\nAls voorbeeld hebben we twee datasets met dezelfde variabelen, name en age:\n\ndta1 &lt;- data.frame(name = c(\"Billy\", \"Xin\", \"Hugo\"), age = c(20, 30, 40))\ndta2 &lt;- data.frame(name = c(\"Theresa\", \"Elin\", \"Lena\"), age = c(25, 35, 45))\n\ndta1 \n\n   name age\n1 Billy  20\n2   Xin  30\n3  Hugo  40\n\ndta2\n\n     name age\n1 Theresa  25\n2    Elin  35\n3    Lena  45\n\n\nWij kunnen deze datasets als volgt combineren:\n\ndta_combined &lt;- bind_rows(dta1, dta2)\ndta_combined\n\n     name age\n1   Billy  20\n2     Xin  30\n3    Hugo  40\n4 Theresa  25\n5    Elin  35\n6    Lena  45\n\n\n\n\n6.1.2 Kolommen toevoegen\nAls we extra kolommen willen toevoegen aan een dataframe, kunnen we bind_cols uit package dplyr gebruiken (dit package wordt geladen met de tidyverse).\nAls we bijvoorbeeld twee datasets hebben, één met de naam en leeftijd van mensen, en een andere met hun zelfgerapporteerde geslacht:\n\ndta &lt;- data.frame(name = c(\"Billy\", \"Xin\", \"Hugo\"), age = c(20, 30, 40))\ngender &lt;- data.frame(gender = c(\"Non-binary\", \"Female\", \"Male\"))\n\n\ndta\n\n   name age\n1 Billy  20\n2   Xin  30\n3  Hugo  40\n\ngender\n\n      gender\n1 Non-binary\n2     Female\n3       Male\n\n\nWe kunnen dit combineren met bind_cols:\n\nbind_cols(dta, gender)\n\n   name age     gender\n1 Billy  20 Non-binary\n2   Xin  30     Female\n3  Hugo  40       Male\n\n\n\n\n\n\n\n\nBelangrijk\n\n\n\nbind_cols zal matchen op positie, dus de volgorde van rijen moet precies hetzelfde zijn. Voor meer flexibele manieren om kolommen aan een dataset toe te voegen, zie “Datasets samenvoegen” hieronder.",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data combineren</span>"
    ]
  },
  {
    "objectID": "data_06_merging_data.html#datasets-samenvoegen-join",
    "href": "data_06_merging_data.html#datasets-samenvoegen-join",
    "title": "6  Data combineren",
    "section": "6.2 Datasets samenvoegen (join)",
    "text": "6.2 Datasets samenvoegen (join)\nAls we twee datasets hebben met een gemeenschappelijke variabele (d.w.z. een variabele met dezelfde naam en vergelijkbare codering, bijvoorbeeld een landnaam of een unieke identificatiecode), kunnen we de datasets combineren met join van dplyr.\nLaten we beginnen met wat voorbeeldgegevens over 4 landen:\n\ncountry_dta1 &lt;- data.frame(country = c(\"USA\", \"Germany\", \"Netherlands\", \"Kenya\"),\n                           population = c(332, 84, 18, 56))\n\ncountry_dta2 &lt;- data.frame(country = c(\"Netherlands\", \"Germany\", \"Kenya\", \"Argentina\"),\n                          official_name = c(\"Nederland\", \"Bundesrepublik Deutschland\", \"Republic of Kenya\", \"República Argentina\"))\n\ncountry_dta1\n\n      country population\n1         USA        332\n2     Germany         84\n3 Netherlands         18\n4       Kenya         56\n\ncountry_dta2\n\n      country              official_name\n1 Netherlands                  Nederland\n2     Germany Bundesrepublik Deutschland\n3       Kenya          Republic of Kenya\n4   Argentina        República Argentina\n\n\nMerk op dat slechts drie landen voorkomen in beide datasets, maar de variabele country is aanwezig in beide dataframes en de waarden (d.w.z. de spelling van de namen van de landen) zijn hetzelfde voor de drie landen die in beide datasets voorkomen.\nWe kunnen de gegevens in deze datasets als volgt samenvoegen, met behulp van zogenaamde ‘joins’ van pacakge dplyr. De functie full_join geeft alle rijen in beide datasets terug:\n\njoined_data &lt;- full_join(x = country_dta1, \n                         y = country_dta2, \n                         by = c(\"country\"))\n\n\nx = country_dta1\n\nDit specificeert de eerste van de twee datasets. Vervang door je eigen dataset als je met je eigen gegevens werkt.\n\ny = country_dta2\n\nDit specificeert de tweede van de twee datasets.\n\nby = c(\"country\")\n\nDit specificeert de kolom waarop we de waarden van de twee dataframes willen matchen (gespecificeerd als een character vector, d.w.z. tussen dubbele haakjes). In ons voorbeeld gebruiken we de variabele country, omdat deze variabele vergelijkbaar is tussen onze twee datasets.\n\n\n\njoined_data\n\n      country population              official_name\n1         USA        332                       &lt;NA&gt;\n2     Germany         84 Bundesrepublik Deutschland\n3 Netherlands         18                  Nederland\n4       Kenya         56          Republic of Kenya\n5   Argentina         NA        República Argentina\n\n\nWe zien dat alle vijf landen aanwezig zijn in de samengevoegde dataset. De VS ontbreekt in country_dta2, dus er ontbreekt een waarde (NA) voor official_name in de gecombineerde dataset. Argentinië ontbreekt in country_dta1 en heeft dus een ontbrekende waarde voor population in de gecombineerde dataset.\nEr zijn vier soorten joins:\n\n\n\nFunctie\nGecombineerde dataset omvat…\n\n\n\n\ninner_join()\n… alle rijen in x en y.\n\n\nleft_join()\n… alle rijen in x.\n\n\nright_join()\n… alle rijen in y.\n\n\nfull_join()\n… alle rijen in x of y.\n\n\n\nWe kunnen het resultaat zien als we de vier soorten joins uitvoeren en printen:\n\n# Inner join: alleen de drie landen die in beide datasets voorkomen\ninner_join(x = country_dta1, y = country_dta2, by = c(\"country\"))\n\n      country population              official_name\n1     Germany         84 Bundesrepublik Deutschland\n2 Netherlands         18                  Nederland\n3       Kenya         56          Republic of Kenya\n\n# Left join: alleen de vier landen in de eerste dataset\nleft_join(x = country_dta1, y = country_dta2, by = c(\"country\"))\n\n      country population              official_name\n1         USA        332                       &lt;NA&gt;\n2     Germany         84 Bundesrepublik Deutschland\n3 Netherlands         18                  Nederland\n4       Kenya         56          Republic of Kenya\n\n# Right join: alleen de vier landen in de tweede dataset\nright_join(x = country_dta1, y = country_dta2, by = c(\"country\"))\n\n      country population              official_name\n1     Germany         84 Bundesrepublik Deutschland\n2 Netherlands         18                  Nederland\n3       Kenya         56          Republic of Kenya\n4   Argentina         NA        República Argentina\n\n# Full join: alle vijf de landen\nfull_join(x = country_dta1, y = country_dta2, by = c(\"country\"))\n\n      country population              official_name\n1         USA        332                       &lt;NA&gt;\n2     Germany         84 Bundesrepublik Deutschland\n3 Netherlands         18                  Nederland\n4       Kenya         56          Republic of Kenya\n5   Argentina         NA        República Argentina\n\n\n\n6.2.1 Joining met verschillende variabelen\nAls we twee dataframes hebben met verschillende namen, moeten we R instrueren welke variabelen moeten worden vergeleken.\nStel bijvoorbeeld dat we een derde dataframe hebben met landeninformatie:\n\ncountry_dta3 &lt;- data.frame(country_name = c(\"USA\", \"Netherlands\", \"Germany\"),\n                           capital_city = c(\"Washington DC\", \"Amsterdam\", \"Berlin\"))\ncountry_dta3\n\n  country_name  capital_city\n1          USA Washington DC\n2  Netherlands     Amsterdam\n3      Germany        Berlin\n\n\nWe merken op dat de variabele met de naam van het land in dit dataframe country_name heet. Om deze te combineren met country_dta1, moeten we by als volgt specificeren:\n\nfull_join(x = country_dta1, y = country_dta3, \n          by = c(\"country\" = \"country_name\"))\n\n      country population  capital_city\n1         USA        332 Washington DC\n2     Germany         84        Berlin\n3 Netherlands         18     Amsterdam\n4       Kenya         56          &lt;NA&gt;\n\n\n\nby = c(\"country\" = \"country_name\")\n\nDe syntaxis \"country\" = \"country_name\" betekent dat we variabele country uit de eerste dataset vergelijken met variabele country_name uit de tweede dataset.\n\n\nMerk op dat deze oplossing alleen werkt als de landennamen identiek gespeld zijn (en alleen de naam van de variabele verschilt). Het onderstaande zal niet goed werken, omdat de landennamen niet vergelijkbaar zijn tussen de twee datasets:\n\ncountry_dta4 &lt;- data.frame(country = c(\"United States of America\", \"Deutschland\", \"Nederland\"),\n                           capital_city = c(\"Washington DC\", \"Berlin\", \"Amsterdam\"))\n\ncountry_dta4\n\n                   country  capital_city\n1 United States of America Washington DC\n2              Deutschland        Berlin\n3                Nederland     Amsterdam\n\nfull_join(country_dta1, country_dta4)\n\n                   country population  capital_city\n1                      USA        332          &lt;NA&gt;\n2                  Germany         84          &lt;NA&gt;\n3              Netherlands         18          &lt;NA&gt;\n4                    Kenya         56          &lt;NA&gt;\n5 United States of America         NA Washington DC\n6              Deutschland         NA        Berlin\n7                Nederland         NA     Amsterdam\n\n\nIn dergelijke gevallen is de oplossing om eerst de variabele die wordt gebruikt voor de matching te hercoderen:\n\ncountry_dta4_recoded &lt;- country_dta4 |&gt;\n  mutate(country = recode(country, \n                          \"United States of America\" = \"USA\",\n                          \"Deutschland\" = \"Germany\",\n                          \"Nederland\" = \"Netherlands\"))\n\nDe landennamen uit beide datasets komen nu overeen, en we kunnen ze dus samenvoegen:\n\nfull_join(country_dta1, country_dta4_recoded)\n\n      country population  capital_city\n1         USA        332 Washington DC\n2     Germany         84        Berlin\n3 Netherlands         18     Amsterdam\n4       Kenya         56          &lt;NA&gt;",
    "crumbs": [
      "Werken met data in R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data combineren</span>"
    ]
  },
  {
    "objectID": "part_statistical_analysis.html",
    "href": "part_statistical_analysis.html",
    "title": "Statistische analyse in R",
    "section": "",
    "text": "In dit deel bespreken we de R-code die nodig is voor het uitvoeren van verschillende soorten statistische analyses die in de cursus zijn besproken.",
    "crumbs": [
      "Statistische analyse in R"
    ]
  },
  {
    "objectID": "analysis_01_descriptives.html",
    "href": "analysis_01_descriptives.html",
    "title": "7  Centrum- en spreidingsmaten",
    "section": "",
    "text": "7.1 Centrummaten\nDe meest gebruikte centrummaten zijn het gemiddelde, de mediaan en de modus. Om te tonen hoe we ze berekenen met R, zullen we de volgende drie variabelen gebruiken:\ndirections &lt;- factor(c(\"East\", \"West\", \"East\", \"North\", \"North\", \"East\", \"West\", \"West\", \"West\", \"East\", \"North\"))\ntemperature &lt;- factor(c(\"low\", \"high\", \"medium\", \"high\", \"low\", \"medium\", \"high\"), levels = c(\"low\", \"medium\", \"high\"), ordered = TRUE)\nexam_points &lt;- c(2, 7, 3, 4, 2, 0)\nAls we deze variabelen vervolgens printen, zien we dat de inhoud correct is opgeslagen:\ndirections # nominaal\n\n [1] East  West  East  North North East  West  West  West  East  North\nLevels: East North West\n\ntemperature # ordinaal\n\n[1] low    high   medium high   low    medium high  \nLevels: low &lt; medium &lt; high\n\nexam_points # interval/ratio\n\n[1] 2 7 3 4 2 0",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Centrum- en spreidingsmaten</span>"
    ]
  },
  {
    "objectID": "analysis_01_descriptives.html#centrummaten",
    "href": "analysis_01_descriptives.html#centrummaten",
    "title": "7  Centrum- en spreidingsmaten",
    "section": "",
    "text": "7.1.1 Modus\nDe modus is de waarde die het vaakst voorkomt in een verzameling gegevens. We kunnen eerst de verdeling van de waarden bekijken met de table() functie:\n\ntable(directions)\n\nOp basis hiervan kunnen we zien dat er twee modi zijn (Oost en West).\n\ndirections\n East North  West \n    4     3     4\n\nAls we de modus willen berekenen, kunnen we gebruik maken van een pakket met de naam DescTools. Dit is een verzameling van diverse statistische basisfuncties voor het efficiënt beschrijven van gegevens. Het pakket bevat de functie Mode() (let op de hoofdletter M).\nWe installeren en laden het benodigde package as volgt:\n\ninstall.packages(\"DescTools\") # DescTools package installeren (hoeft slechts één keer)\nlibrary(DescTools) # DescTools package laden\n\nOm de modus te berekenen, schrijven we:\n\nMode(directions, na.rm = TRUE)\n\n[1] East West\nattr(,\"freq\")\n[1] 4\nLevels: East North West\n\n\n\nna.rm = TRUE\n\nDit zorgt ervoor dat eventuele missende waarden worden genegeerd bij de berekening van de modus.\n\n\nUit de resultaten blijkt dat er twee modi zijn: East en West.\n\n\n7.1.2 Mediaan\nDe mediaan is de waarde die, in de veronderstelling dat de dataset van klein naar groot is geordend, in het midden valt. Om deze te berekenen, gebruiken we het Mediaan() commando uit het DescTools package (zie hierboven voor het installeren en laden van dit package). De functie Median uit package DescTools kan omgaan met factors:\n\nMedian(temperature, na.rm=TRUE)\n\n[1] medium\nLevels: low &lt; medium &lt; high\n\n\n\nna.rm = TRUE\n\nDit zorgt ervoor dat eventuele missende waarden worden genegeerd bij de berekening van de mediaan.\n\n\n\n\n7.1.3 Gemiddelde\nHet gemiddelde van een verzameling waarnemingen wordt berekend door alle waarden bij elkaar op te tellen en dan te delen door het totaal aantal waarden1:\n\nmean(exam_points, na.rm=TRUE)\n\n[1] 3\n\n\n\nna.rm = TRUE\n\nDit zorgt ervoor dat eventuele missende waarden worden genegeerd bij de berekening van het gemiddelde.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Centrum- en spreidingsmaten</span>"
    ]
  },
  {
    "objectID": "analysis_01_descriptives.html#spreidingsmaten",
    "href": "analysis_01_descriptives.html#spreidingsmaten",
    "title": "7  Centrum- en spreidingsmaten",
    "section": "7.2 Spreidingsmaten",
    "text": "7.2 Spreidingsmaten\nOm de minimum- en maximumwaarde van een vector of een kolom in een data frame te vinden, kunnen we de functies max() en min() gebruiken. Toegepast op de ordinale en interval/ratio variabele die we hebben gemaakt:\n\nmin(temperature, na.rm = TRUE)\n\n[1] low\nLevels: low &lt; medium &lt; high\n\nmax(exam_points, na.rm = TRUE)\n\n[1] 7\n\n\n\nna.rm = TRUE\n\nDit zorgt ervoor dat eventuele missende waarden worden genegeerd bij de berekening van het minimum of maximum.\n\n\n\n7.2.1 Spreidingsbreedte\nrange() geeft een vector terug die het minimum en maximum bevat:\n\nrange(exam_points, na.rm = TRUE)\n\n[1] 0 7\n\n\n\nexam_points\n\nDit is de naam van de variabele/vector waarvan we de range willen berekenen. Vervang door je eigen variabelen indien je werkt met je eigen data.\n\nna.rm = TRUE\n\nDit zorgt ervoor dat eventuele missende waarden worden genegeerd.\n\n\n\n\n7.2.2 Interkwartielafstand\nOm een overzicht te krijgen van de interkwartielafstand, kunnen we de summary() functie gebruiken:\n\nsummary(exam_points)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    2.00    2.50    3.00    3.75    7.00 \n\n\nIn de resultaten zien we 1st Qu. (= 1st quartile, 1e kwartiel) en 3rd Qu. (= 3rd quartile, 3e kwartiel),\n\n\n7.2.3 Standaardafwijking en variantie\nJe kunt de standaardafwijking in R berekenen met de sd() functie. Standaard genereert deze de steekproef-standaardafwijking. Als je de standaardafwijking van de populatie wilt berekenen, kun je een aanpassing maken (vermenigvuldigen met sqrt((n-1)/n)).\n\nsd(exam_points, na.rm = TRUE)\n\n[1] 2.366432\n\n\n\nna.rm = TRUE\n\nDit zorgt ervoor dat eventuele missende waarden worden genegeerd.\n\n\nOm de variantie te berekenen, kunnen we de var() functie gebruiken:\n\nvar(exam_points, na.rm = TRUE)\n\n[1] 5.6\n\n\n\nna.rm = TRUE\n\nDit zorgt ervoor dat eventuele missende waarden worden genegeerd.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Centrum- en spreidingsmaten</span>"
    ]
  },
  {
    "objectID": "analysis_01_descriptives.html#bewerkingen-doen-in-dataframes",
    "href": "analysis_01_descriptives.html#bewerkingen-doen-in-dataframes",
    "title": "7  Centrum- en spreidingsmaten",
    "section": "7.3 Bewerkingen doen in dataframes",
    "text": "7.3 Bewerkingen doen in dataframes\nZoals uitgelegd in Paragraaf 1.7.1.3, gebruik je het symbool “$” om variabelen in dataframes aan te roepen. Daarom, als we een van de functies willen gebruiken die tot nu toe zijn behandeld (mean(), table(), sd(), var(), enz.) gebruik je gewoon die operator om specifieke variabelen in data frames te gebruiken.\nVoorbeeld: als we het gemiddelde en de standaardafwijking van filmscores (‘Score’) in ‘deniro_data’ willen berekenen, zouden we schrijven:\n\nlibrary(rio)  # Laad package rio voor het importeren van de data met functie 'import'\ndeniro_data &lt;- import(file = \"deniro.csv\") \n\n\nmean(deniro_data$Score, na.rm = TRUE)\n\n[1] 58.1954\n\nsd(deniro_data$Score, na.rm = TRUE)\n\n[1] 28.06754\n\n\n\nna.rm = TRUE\n\nDit zorgt ervoor dat eventuele missende waarden worden genegeerd.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Centrum- en spreidingsmaten</span>"
    ]
  },
  {
    "objectID": "analysis_01_descriptives.html#beschrijvende-statistieken-voor-een-volledig-dataframe",
    "href": "analysis_01_descriptives.html#beschrijvende-statistieken-voor-een-volledig-dataframe",
    "title": "7  Centrum- en spreidingsmaten",
    "section": "7.4 Beschrijvende statistieken voor een volledig dataframe",
    "text": "7.4 Beschrijvende statistieken voor een volledig dataframe\nEr zijn veel samenvattende statistieken beschikbaar in R. Een eenvoudige manier om een basisoverzicht van een dataframe te krijgen is de describe() functie uit het ‘psych’ pakket. Als je dit package moet installeren type je install.packages(\"psych\") in de R console (niet nodig op universiteits-pc’s).\nOm de describe() functie uit het `psych’ pakket te gebruiken, schrijven we:\n\nlibrary(psych)\n\n\nAttaching package: 'psych'\n\n\nThe following objects are masked from 'package:DescTools':\n\n    AUC, ICC, SD\n\ndescribe(deniro_data, na.rm = TRUE, skew = FALSE, ranges = TRUE)\n\n       vars  n    mean    sd median  min  max range   se\nYear      1 87 1995.98 12.94   1997 1968 2016    48 1.39\nScore     2 87   58.20 28.07     65    4  100    96 3.01\nTitle*    3 87   44.00 25.26     44    1   87    86 2.71\n\n\n\nna.rm = TRUE\n\nWe voegen na.rm = TRUE toe om R te vertellen ontbrekende waarden weg te laten.\n\nskew = FALSE\n\nVia dit deel van de code, vertellen we R of het de scheefheid van de variabele moet berekenen. Ik zou aanraden om het weg te laten, maar als je het toch wilt toevoegen, verander het dan in skew = TRUE.\n\nranges = TRUE\n\nWe voegen ranges = TRUE toe om R te vertellen de spreidingsbreedte (range) te berekenen. Als je dit niet wilt, kun je het instellen op ranges = FALSE\n\n\nZoals je kunt zien, levert dit een relatief eenvoudige overzichtstabel op. Let wel op: de variabele Title is een character variabele (dat is te zien aan de asterisk *). Psych maakt hier eerst een numerieke variabele van.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Centrum- en spreidingsmaten</span>"
    ]
  },
  {
    "objectID": "analysis_01_descriptives.html#footnotes",
    "href": "analysis_01_descriptives.html#footnotes",
    "title": "7  Centrum- en spreidingsmaten",
    "section": "",
    "text": "We kunnen het gemiddelde ook berekenen door de som te berekenen en dan te delen door het aantal observaties:\n\nsum(exam_points) / length(exam_points)\n\n[1] 3\n\n\n↩︎",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Centrum- en spreidingsmaten</span>"
    ]
  },
  {
    "objectID": "analysis_02_graphs.html",
    "href": "analysis_02_graphs.html",
    "title": "8  Grafieken maken met ggplot2",
    "section": "",
    "text": "8.1 Algemene inleiding tot ggplot\nPlots met ggplot 2 worden ontworpen in lagen (layers).\nElke ggplot begint met de ggplot functie, waarin je de dataset definieert die wordt gebruikt en de belangrijkste variabelen. Bijvoorbeeld in de grafiek hieronder definiëren we loan50 als de data . Vervolgens koppelen (“mapping”) we de variabelen die we gebruiken met behulp van de aes functie, die variabelen koppelt aan elementen van de grafiek. In onderstaand voorbeeld geven we aan dat we de variabele total_income op de x-as willen gebruiken en loan_amount op de y-as.\nggplot(data = loan50, \n       mapping = aes(x = total_income, y = loan_amount))\nDe bovenstaande code produceert een ‘lege’ grafiek, omdat we R nog niet hebben verteld wat voor soort grafiek we willen produceren: misschien een lijngrafiek, een puntenwolk of iets anders? We moeten een geom-laag aan de grafiek toevoegen om punten, lijnen of balken in de grafiek te kunnen produceren. Hieronder voegen we punten toe aan de grafiek met geom_point(). Merk op dat we ook een plusteken (+) toevoegen na de tweede regel, die ervoor zorgt dat we de punten toevoegen aan onze grafiek:\nggplot(data = loan50, \n       mapping = aes(x = total_income, y = loan_amount)) +\n  geom_point()\nWe kunnen ook extra lagen toevoegen om de grafiek er anders uit te laten zien, labels te veranderen of andere elementen aan de grafiek toe te voegen. Voorbeelden hiervan vind je voor elk van de grafiektypes hieronder.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grafieken maken met ggplot2</span>"
    ]
  },
  {
    "objectID": "analysis_02_graphs.html#algemene-inleiding-tot-ggplot",
    "href": "analysis_02_graphs.html#algemene-inleiding-tot-ggplot",
    "title": "8  Grafieken maken met ggplot2",
    "section": "",
    "text": "8.1.1 Een ggplot opslaan in een bestand\nAls je een grafiek wilt gebruiken in bijvoorbeeld een Word-document of Powerpoint, kun je de ggplot exporteren met ggsave. Dit slaat de laatste ggplot op in een bestand:\n\nggplot(data = loan50, \n       mapping = aes(x = total_income, y = loan_amount)) +\n  geom_point()\n\nggsave(filename = \"scatterplot_example.png\", \n       width=7, \n       height=7)\n\n\nfilename = \"scatterplot_example.png\"\n\nJe moet het bestand een naam en een extensie geven. In dit voorbeeld is de bestandsnaam ingesteld op scatterplot_example.png. Dit maakt een PNG-bestand, wat vaak goed werkt als je de grafiek wilt gebruiken in een tekstdocument of presentatie. Je kunt ook andere bestandsformaten maken, zoals een jpeg of pdf bestand, door de extensie te veranderen, bijvoorbeeld scatterplot_example.pdf.\n\nwidth = 7\n\nDit geeft de breedte van de grafiek in inches.\n\nheight = 7\n\nGeeft de hoogte van de grafiek in inches.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grafieken maken met ggplot2</span>"
    ]
  },
  {
    "objectID": "analysis_02_graphs.html#puntenwolk-scatterplot",
    "href": "analysis_02_graphs.html#puntenwolk-scatterplot",
    "title": "8  Grafieken maken met ggplot2",
    "section": "8.2 Puntenwolk (scatterplot)",
    "text": "8.2 Puntenwolk (scatterplot)\nEen puntenwolk geeft een overzicht van elk uniek punt voor twee numerieke waarden. Dit werkt vooral goed als er veel unieke waarden zijn.\nIn het onderstaande voorbeeld zetten we total_income op de x-as (horizontaal) en loan_amount op de y-as (verticaal).\n\nggplot(data = loan50, \n       mapping = aes(x = total_income, y = loan_amount)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\ndata = loan50\n\nDit stukje code zegt dat het dataframe dat we gebruiken loan50 heet. Voor je eigen grafiek zou je loan50 vervangen door de naam van het data.frame dat je gebruikt.\n\nmapping = aes(x = total_income, y = loan_amount)\n\nDit deel van de code geeft aan dat total_income de variabele is die we willen weergeven op de x-as en loan_amount moet worden weergegeven op de y-as. Voor je eigen grafiek zou je dus total_income en loan_amount vervangen door je eigen variabelen.\n\ngeom_point()\n\nDit vertelt ggplot2 dat we een scatterplot willen maken met punten voor de twee variabelen. We hebben geen extra argumenten nodig voor een eenvoudige scatterplot.\n\n\n\n8.2.1 Puntenwolk: extra opties\nOm de scatterplot er wat mooier uit te laten zien, kunnen we extra opties toevoegen. Om opties aan een plot toe te voegen gebruiken we het + teken aan het eind van de regel:\n\ndata(loan50)\nggplot(data = loan50, \n       mapping = aes(x = total_income, y = loan_amount)) +\n  geom_point(size=2, colour = \"grey\") +\n  labs(title = \"Total income and loan amount\",\n       x = \"Total Income\",\n       y = \"Loan Amount\") +\n  scale_x_continuous(labels=label_dollar()) +\n  scale_y_continuous(labels=label_dollar()) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\ngeom_point(size = 2, colour = \"grey\")\n\nMet deze opties kunnen we de grootte en de kleur van de stippen instellen. Merk op dat de kleurnaam een character vector is en tussen aanhalingstekens moet worden geplaatst: “grey”.\n\nlabs(title = \"Title\", x = \"x axis title\", y = \"y axis title\")\n\nDeze optie voegt mooiere namen toe voor de titel van de grafiek, en de titels van de x- en y-as.\n\nscale_x_continuous(labels=scales::label_dollar())\n\nDeze optie en haar ‘zusje’ scale_y_continuous veranderen hoe de waarden en assen worden weergegeven. In dit geval willen we de waarden in dollars weergeven. Dit kan worden gedaan met label_dollar() uit package scales.\n\ntheme_minimal()\n\nOm het uiterlijk van een grafiek te veranderen, kun je de theme_* functies gebruiken (waarbij je in plaats van ster verschillende opties kunt toevoegen, zoals theme_minimal(), theme_classic() of theme_light().\n\n\n\n\n8.2.2 Puntenwolk: meerdere groepen\nSoms heb je verschillende groepen in je gegevens die je zou willen visualiseren. In dat geval kan je geom_point aanpassen om de kleur of de vorm van de punten per groep te veranderen. In dit voorbeeld zal de kleur van de punt aangeven om wat voor type huiseigenaar het gaat:\n\ndata(loan50)\nggplot(data = loan50, \n       mapping = aes(x = total_income, y = loan_amount)) +\n  geom_point(aes(colour = homeownership)) \n\n\n\n\n\n\n\n\n\ngeom_point(aes(colour = homeownership))\n\nDit geeft aan dat de kleur van de punten zal variëren per categorie van homeownership (huur, hypotheek, eigen huis). R zal automatisch een kleur (colour) kiezen voor elke groep. Voor je eigen grafiek, zou je homeownership veranderen in je eigen groeperingsvariabele. Opmerking: vergeet niet om colour = homeownership in aes() te zetten.\n\n\n\ndata(loan50)\nggplot(data = loan50, \n       mapping = aes(x = total_income, y = loan_amount)) +\n  geom_point(aes(shape = homeownership)) \n\n\n\n\n\n\n\n\n\ngeom_point(aes(shape = homeownership))\n\nDit geeft aan dat de vorm (shape) van de punten zal variëren per categorie van homeownership. R zal automatisch een shape kiezen voor elke groep. Voor uw eigen grafiek, zou u homeownership veranderen in uw eigen groeperingsvariabele. Opmerking: vergeet niet om shape = homeownership in aes() te zetten.\n\n\n\n\n8.2.3 Puntenwolk: afzonderlijke grafieken per groep\nSoms wil je, in plaats van verschillende kleuren of vormen voor een groep te gebruiken, een aparte grafiek voor elke groep maken. Deze worden “facetten” (facets) genoemd en kunnen als volgt worden gemaakt:\n\ndata(loan50)\nggplot(data = loan50, \n       mapping = aes(x = total_income, y = loan_amount)) +\n  geom_point() +\n  facet_wrap(vars(homeownership))\n\n\n\n\n\n\n\n\n\nfacet_wrap(vars(homeownership))\n\nDit geeft aan dat we een apart “facet” willen produceren voor elke waarde van woningbezit (huur, hypotheek, eigen). Voor uw eigen grafiek, zou u homeownership veranderen in uw eigen groeperingsvariabele. Opmerking: vergeet niet om de variabele naam in vars() te zetten. Er zijn extra opties voor de functie facet_wrap om te bepalen hoe deze worden weergegeven, bijvoorbeeld het aantal rijen (nrow) en kolommen (ncol).",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grafieken maken met ggplot2</span>"
    ]
  },
  {
    "objectID": "analysis_02_graphs.html#dot-plot",
    "href": "analysis_02_graphs.html#dot-plot",
    "title": "8  Grafieken maken met ggplot2",
    "section": "8.3 Dot plot",
    "text": "8.3 Dot plot\nEen dot plot vat de waarden voor een enkele variabele samen.\n\nggplot(data = loan50,\n       mapping = aes(x = interest_rate)) +\n  geom_dotplot()\n\nBin width defaults to 1/30 of the range of the data. Pick better value with\n`binwidth`.\n\n\n\n\n\n\n\n\n\n\ndata = loan50\n\nDit stukje code zegt dat het dataframe dat we gebruiken loan50 heet. Voor je eigen grafiek zou je loan50 vervangen door de naam van het data.frame dat je gebruikt.\n\nmapping = aes(x = interest_rate)\n\nDit deel van de code zegt dat interest_rate de variabele is die we willen weergeven. Voor je eigen grafiek zou je dus interest_rate vervangen door je eigen variabele.\n\ngeom_dotplot()\n\nDit vertelt ggplot2 dat we een dotplot willen maken. We hebben geen bijkomende opties nodig voor een basis dotplot.\n\n\n\n8.3.1 Dot plot: extra opties\n\nggplot(data = loan50,\n       mapping = aes(x = interest_rate)) +\n  geom_dotplot() +\n  labs(title = \"Dot plot of interest rate\",\n       x = \"Interest rate\",\n       y = \"\") +\n  scale_y_continuous(labels=NULL) +\n  scale_x_continuous(labels = label_percent(scale=1),\n                     breaks=seq(5,25,by=5)) +\n  theme_minimal()\n\nBin width defaults to 1/30 of the range of the data. Pick better value with\n`binwidth`.\n\n\n\n\n\n\n\n\n\n\nlabs(title = \"Title\", x = \"x axis title\", y = \"\")\n\nDeze optie voegt mooiere namen toe voor de titel van de grafiek, en de titels van de x- en y-as. In het voorbeeld verwijderen we de titel van de y-as door hem op niets te zetten (\"\")\n\nscale_x_continuous(labels = label_percent(scale=1), breaks=seq(5,25,by=5)\n\nDeze optie verandert hoe de x-as wordt weergegeven. In dit geval willen we de waarden in percentages weergeven. Dit kan gedaan worden met label_percent(scale = 1) uit package scales. We stellen ook breaks=seq(5,25, by=5) in om R te vertellen dat we de waarden van de x-as willen weergeven op 5%, 10%, 15%, 20% en 25%.\n\ntheme_minimal()\n\nOm het uiterlijk van een grafiek te veranderen, kun je de theme_* functies gebruiken (waarbij je in plaats van ster verschillende opties kunt toevoegen, zoals theme_minimal(), theme_classic() of theme_light().",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grafieken maken met ggplot2</span>"
    ]
  },
  {
    "objectID": "analysis_02_graphs.html#histogram",
    "href": "analysis_02_graphs.html#histogram",
    "title": "8  Grafieken maken met ggplot2",
    "section": "8.4 Histogram",
    "text": "8.4 Histogram\nEen histogram geeft een overzicht van een numerieke variabele, door de tellingen van (gegroepeerde) waarden weer te geven.\n\nggplot(data = loan50,\n       mapping = aes(x = interest_rate)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\ndata = loan50\n\nDit stukje code zegt dat het dataframe dat we gebruiken loan50 heet. Voor je eigen grafiek zou je loan50 vervangen door de naam van het data.frame dat je gebruikt.\n\nmapping = aes(x = interest_rate)\n\nDit deel van de code zegt dat interest_rate de variabele is die we willen weergeven. Voor je eigen grafiek zou je dus interest_rate vervangen door je eigen variabele.\n\ngeom_histogram()\n\nDit vertelt ggplot2 dat we een histogram willen maken. Dit produceert een basis histogram met 30 bins (zie hieronder voor opties die deze standaardinstelling veranderen).\n\n\n\n8.4.1 Histogram: bin-grootte regelen\nEr zijn verschillende mogelijkheden om te bepalen hoe de gegevens van de variabele worden gegroepeerd: de breedte van de bins (‘bakken’), het aantal bins of handmatige breekpunten instellen:\n\n8.4.1.1 Breedte van de bins\n\nggplot(data = loan50,\n       mapping = aes(x = interest_rate)) +\n  geom_histogram(binwidth = 2.5)\n\n\n\n\n\n\n\n\n\ngeom_histogram(binwidth = 2.5)\n\nDe optie binwidth stelt de breedte van de bins in, in dit voorbeeld op 2.5.\n\n\n\n\n8.4.1.2 Aantal bins\n\nggplot(data = loan50,\n       mapping = aes(x = interest_rate)) +\n  geom_histogram(bins = 10)\n\n\n\n\n\n\n\n\n\ngeom_histogram(bins = 10)\n\nDe optie bins stelt het aantal bins in, in dit voorbeeld 10.\n\n\n\n\n8.4.1.3 Handmatige breekpunten\n\nggplot(data = loan50,\n       mapping = aes(x = interest_rate)) +\n  geom_histogram(breaks=seq(5,27.5,by=2.5))\n\n\n\n\n\n\n\n\n\ngeom_histogram(breaks=seq(5,27.5,by=2.5)\n\nDe optie breaks stelt exacte breekpunten in voor de bins in de histogrammen. In dit voorbeeld stellen we breekpunten in van 5 tot 27.5 in stappen van 2.5 (d.w.z. de eerste bin is 5-7.5, de tweede 7.5-10, etc.).\n\n\n\n\n\n8.4.2 Histogram: extra opties\n\ndata(loan50)\nggplot(data = loan50,\n       mapping = aes(x = interest_rate)) +\n  geom_histogram(breaks=seq(5,27.5,by=2.5), colour = \"black\", fill=\"grey\") +\n  labs(title = \"Histogram of interest rate\",\n       x = \"Interest Rate\", y= \"Count\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\ngeom_histogram(colour = \"black\", fill=\"grey\")\n\nDit regelt het uiterlijk van de balken. In dit voorbeeld voegen we een zwarte rand toe aan de balk door de colour (kleur) in te stellen en de fill (vulkleur) te veranderen in grijs.\n\nlabs(title = \"Title\", x = \"x axis title\", y = \"y axis title\")\n\nDeze optie voegt mooiere namen toe voor de titel van de grafiek, en de titels van de x- en y-as.\n\ntheme_minimal()\n\nOm het uiterlijk van een grafiek te veranderen, kun je de theme_* functies gebruiken (waarbij je in plaats van ster verschillende opties kunt toevoegen, zoals theme_minimal(), theme_classic() of theme_light().",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grafieken maken met ggplot2</span>"
    ]
  },
  {
    "objectID": "analysis_02_graphs.html#box-plot",
    "href": "analysis_02_graphs.html#box-plot",
    "title": "8  Grafieken maken met ggplot2",
    "section": "8.5 Box plot",
    "text": "8.5 Box plot\nEen boxplot geeft een samenvatting van een variabele, met behulp van vijf statistieken, waaronder de mediaan, Q1 en Q3.\n\nggplot(data = loan50,\n       mapping = aes(x = interest_rate)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\ndata = loan50\n\nDit stukje code zegt dat het dataframe dat we gebruiken loan50 heet. Voor je eigen grafiek zou je loan50 vervangen door de naam van het dataframe dat je gebruikt.\n\nmapping = aes(x = interest_rate)\n\nDit deel van de code zegt dat interest_rate de variabele is die we willen weergeven. Voor je eigen grafiek zou je dus interest_rate vervangen door je eigen variabele.\n\ngeom_boxplot()\n\nDit vertelt ggplot2 dat we een boxplot willen maken. Dit produceert een basis boxplot.\n\n\n\n8.5.1 Box plot: extra opties\n\nggplot(data = loan50,\n       mapping = aes(y = interest_rate)) +\n  geom_boxplot(fill = \"grey\") +\n  labs(title = \"Boxplot of interest rate\", \n       y = \"Interest rate\") +\n  theme_minimal() +\n  theme(axis.text.x=element_blank(),axis.ticks.x=element_blank())\n\n\n\n\n\n\n\n\n\naes(y = interest_rate)\n\nAls we interest_rate op de y-as zetten (in plaats van op de x-as) veranderen we de oriëntatie van de boxplot.\n\ngeom_boxplot(fill = \"grey\")\n\nDe optie fill bepaalt de kleur van de vakjes. Merk op dat de kleur tussen aanhalingstekens moet worden opgegeven (dus \"grey\").\n\nlabs(title = \"Title\", x = \"x axis title\", y = \"y axis title\")\n\nDeze optie voegt mooiere namen toe voor de titel van de grafiek, en de titels van de x- en y-as.\n\ntheme_minimal()\n\nOm het uiterlijk van een grafiek te veranderen, kun je de theme_* functies gebruiken (waarbij je in plaats van ster verschillende opties kunt toevoegen, zoals theme_minimal(), theme_classic() of theme_light().\n\ntheme(axis.text.x=element_blank(),axis.ticks.x=element_blank())\n\nDeze optie zorgt dat op de x as geen labels and ticks weergegeven worden, aangezien deze betekenisloos zijn.\n\n\n\n\n8.5.2 Box plot: meerdere groepen\n\nggplot(data = loan50,\n       mapping = aes(x = interest_rate, y = homeownership)) +\n  geom_boxplot() \n\n\n\n\n\n\n\n\n\naes(x = interest_rate, y = homeownership)\n\nIn dit voorbeeld geven we de rente (interest rate) weer per type woningbezit (eigen, hypotheek, huur). Hier plaatsen we interest_rate op de x-as en homeownership op de y-as. Merk op dat de tweede variabele (in dit geval homeownership) een factor of character variabele moet zijn (d.w.z. categoriaal).",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grafieken maken met ggplot2</span>"
    ]
  },
  {
    "objectID": "analysis_02_graphs.html#staafdiagram-bar-plot",
    "href": "analysis_02_graphs.html#staafdiagram-bar-plot",
    "title": "8  Grafieken maken met ggplot2",
    "section": "8.6 Staafdiagram (Bar plot)",
    "text": "8.6 Staafdiagram (Bar plot)\nEen staafdiagram kan worden gebruikt om tellingen of proporties van categoriale variabelen weer te geven. U kunt het ook gebruiken om samenvattende statistieken (bv. gemiddelden) voor verschillende groepen weer te geven.\n\nMerk op dat een histogram wordt gebruikt voor de weergave van frequenties van numerieke (interval-ratio) variabelen, terwijl een staafdiagram wordt gebruikt voor de weergave van frequenties van categoriale variabelen.\n\n\nggplot(data = loan50,\n       mapping = aes(x = homeownership)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n\ndata = loan50\n\nDit stukje code zegt dat het dataframe dat we gebruiken loan50 heet. Voor je eigen grafiek zou je loan50 vervangen door de naam van het dataframe dat je gebruikt.\n\nmapping = aes(x = homeownership)\n\nDit deel van de code zegt dat homeownership de variabele is die we willen laten zien. Voor je eigen grafiek, zou je dus homeownership vervangen door je eigen variabele.\n\ngeom_bar()\n\nDit vertelt ggplot2 dat we een barplot willen maken. Dit produceert een basis barplot.\n\n\n\n8.6.1 Bar plot: extra opties\n\nggplot(data = loan50,\n       mapping = aes(x = homeownership)) +\n  geom_bar(fill = \"grey\", colour = \"black\") +\n  labs(title = \"Homeownership\",\n       x = \"Home ownership type\",\n       y = \"Count\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\ngeom_bar(fill = \"grey\", colour = \"black\")\n\nDe optie fill bepaalt de kleur van de balken en colour bepaalt de kleur van de rand. Merk op dat de kleur tussen aanhalingstekens moet worden opgegeven (dus \"grey\").\n\nlabs(title = \"Title\", x = \"x axis title\", y = \"y axis title\")\n\nDeze optie voegt mooiere namen toe voor de titel van de grafiek, en de titels van de x- en y-as. Opmerking: als je de manier waarop de categorieën worden gepresenteerd wilt veranderen (d.w.z. “Huur” in plaats van “huur”), moet je de variabele homeownership hercoderen.\n\ntheme_minimal()\n\nOm het uiterlijk van een grafiek te veranderen, kun je de theme_* functies gebruiken (waarbij je in plaats van ster verschillende opties kunt toevoegen, zoals theme_minimal(), theme_classic() of theme_light().\n\n\n\n\n8.6.2 Bar plot: meerdere groepen\nWanneer je twee categoriale variabelen hebt, kun je een staafdiagram maken dat beide variabelen weergeeft. In het onderstaande geval geven we homeownership en verified_income weer.\n\n8.6.2.1 Gestapelde staafdiagram (stacked bar plot)\n\nggplot(data = loan50,\n       mapping = aes(x = homeownership)) +\n  geom_bar(aes(fill = verified_income))\n\n\n\n\n\n\n\n\n\ngeom_bar(aes(fill = verified_income))\n\nDe optie fill (binnen aes ) geeft aan dat we elke staaf willen onderverdelen naar de categorieën van verified_income.\n\n\nNote: als je de labels in de legenda van deze grafiek wilt veranderen, kun je het beste de variabele (verified_income) hernoemen (rename) en hercoderen (recode). Dit behandelen we in de komende weken.\n\n\n8.6.2.2 Staven naast elkaar\n\nggplot(data = loan50,\n       mapping = aes(x = homeownership)) +\n  geom_bar(aes(fill = verified_income), position=\"dodge\")\n\n\n\n\n\n\n\n\n\ngeom_bar(aes(fill = verified_income), position = \"dodge\")\n\nDe optie fill (binnen aes ) geeft aan dat we elke staaf willen onderverdelen naar de categorieën van verified_income. We voegen position = \"dodge\" toe om de staven naast elkaar weer te geven in plaats van te stapelen.\n\n\n\n\n8.6.2.3 Percentage gestapeld staafdiagram\nDit type staafdiagram stapelt de subcategorieën, maar berekent ze als een percentage.\n\nggplot(data = loan50,\n       mapping = aes(x = homeownership)) +\n  geom_bar(aes(fill = verified_income), position = \"fill\") +\n  scale_y_continuous(labels = label_percent()) + \n  labs(y = \"Percentage\")\n\n\n\n\n\n\n\n\n\ngeom_bar(aes(fill = verified_income), position = \"fill\")\n\nDe optie fill (binnen aes ) geeft aan dat we elke staaf willen onderverdelen naar de categorieën van verified_income.\n\nscale_y_continuous(labels = label_percent())\n\nDit zorgt ervoor dat percentages in plaats van aantallen op de y-as worden weergegeven. De functie label_percent() komt uit package scales.\n\nlabs(y = \"Percentage\")\n\nOm ervoor te zorgen dat op de y-as “Percentage” staat in plaats van “Counts”, wijzigen we het label van de y-as.\n\n\n\n\n\n8.6.3 Staafdiagram van gemiddelden\nWe kunnen ook staafdiagrammen gebruiken om statistieken weer te geven (bijvoorbeeld gemiddelden) van een numerieke variabele voor elke categorie van een categorische variabele. Laten we bijvoorbeeld de gemiddelde interest_rate per type homeownership plotten.\nEerst moeten we een dataframe maken dat de gemiddelde rente per type huiseigendom laat zien. Dit kunnen we doen met group_by en summarise uit het dplyr pakket. We zullen deze functies later in de cursus in meer detail bespreken. Voor nu is het voldoende om te begrijpen dat we de gemiddelde rente voor elk type huizenbezit berekenen:\n\nloan50_means &lt;- loan50 |&gt;\n  group_by(homeownership) |&gt;\n  summarise(interest_rate = mean(interest_rate, na.rm=TRUE))\nloan50_means\n\n# A tibble: 3 × 2\n  homeownership interest_rate\n  &lt;fct&gt;                 &lt;dbl&gt;\n1 rent                   10.8\n2 mortgage               11.9\n3 own                    13.9\n\n\nMet dit nieuwe dataframe loan50_means, kunnen we een staafdiagram maken van deze gemiddelden, met geom_col():\n\nggplot(data = loan50_means,\n       mapping = aes(x = homeownership, y = interest_rate)) +\n  geom_col()\n\n\n\n\n\n\n\n\n\ndata = loan50_means\n\nMerk op dat we hier de dataset loan50_means gebruiken, die we hierboven hebben gemaakt. Deze bevat de gemiddelde interest_rate per type homeownership.\n\nmapping = aes(x = homeownership, y = interest_rate)\n\nDit deel van de code geeft de categoriale (x) variabele en de numerieke (y) variabele.\n\ngeom_col()\n\nDit vertelt ggplot2 dat we een staafdiagram willen maken waar we de waarden van de gegevens willen weergeven (niet de tellingen per groep, zoals met geom_bar).",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Grafieken maken met ggplot2</span>"
    ]
  },
  {
    "objectID": "analysis_03_tables.html",
    "href": "analysis_03_tables.html",
    "title": "9  Tabellen",
    "section": "",
    "text": "9.1 Frequentietabellen\nEen frequentietabel toont het aantal keren dat een waarde voorkomt in de data. We hebben al kennis gemaakt met de functie table, die een eenvoudige tabel met tellingen oplevert. Om een uitgebreidere frequentietabel te maken die ook percentages bevat, gebruiken we package expss. Ons voorbeeld gebruikt gegevens uit package openintro. We laden eerst de packages:\nlibrary(expss)\nlibrary(openintro)\nWe laden daarna de dataset loan50 die deel uitmaakt van het package openintro met behulp van de functie data.\ndata(loan50)\nNu maken we maken een frequentietabel met de functie fre:\nfre(loan50$homeownership)\n\n\n\n\n\nloan50$homeownership\n Count \n Valid percent \n Percent \n Responses, % \n Cumulative responses, % \n\n\n\n\n rent \n21\n42\n42\n42\n42\n\n\n mortgage \n26\n52\n52\n52\n94\n\n\n own \n3\n6\n6\n6\n100\n\n\n #Total \n50\n100\n100\n100\n\n\n\n &lt;NA&gt; \n0\n\n0",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tabellen</span>"
    ]
  },
  {
    "objectID": "analysis_03_tables.html#frequentietabellen",
    "href": "analysis_03_tables.html#frequentietabellen",
    "title": "9  Tabellen",
    "section": "",
    "text": "Opmerking\n\n\n\nOnthoud dat we de functie data alleen kunnen gebruiken voor datasets die bij een package horen. Voor het laden van datasets vanuit een bestand zie Paragraaf 1.7.2.\n\n\n\n\n\nfre\n\nDit is de functie om een frequentietabel te maken met behulp van het expss package\n\nloan50$homeownership\n\nWe specificeren de gebruikte dataset en variabele met behulp van de dollartekennotatie, d.w.z. de naam van het dataframe vóór het dollarteken en de naam van de variabele na het dollarteken.\n\n\n\n\n\n\n\n\nRapportage\n\n\n\nVoor een frequentietabel is het meestal voldoende om de aantallen en geldige percentages te rapporteren. Dit wordt bereikt door de eerste drie kolommen van een frequentietabel te selecteren en ontbrekende waarden te verwijderen.\n\nfre(loan50$homeownership)[,1:3] |&gt; drop_na()\n\n\n\n\n\nloan50$homeownership\n Count \n Valid percent \n\n\n\n\n rent \n21\n42\n\n\n mortgage \n26\n52\n\n\n own \n3\n6\n\n\n #Total \n50\n100\n\n\n\n\n\n\n\n\n\n\n\n\nRapportage voor gevorderden\n\n\n\n\n\nAls je het helemaal netjes wil doen, zonder de tabel nog handmatig te bewerken, kun je onderstaande code gebruiken en aanpassen.\n\nloan50 |&gt;                                            # Start met je data frame\n  pull(homeownership) |&gt;                             # Selecteer de juiste variabele\n  set_var_lab(\"Homeownership\") |&gt;                    # Geef deze een nette naam\n  fre(stat_lab = c(\"Frequentie\", \"Percentage\")) |&gt;   # Gebruik Nederlandse labels\n  _[,1:3] |&gt;                                         # Selecteer kolom 1 t/m 3\n  drop_na()                                          # Laat lege rijen weg\n\n\n\n\n\nHomeownership\n Frequentie \n Percentage \n\n\n\n\n rent \n21\n42\n\n\n mortgage \n26\n52\n\n\n own \n3\n6\n\n\n #Total \n50\n100",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tabellen</span>"
    ]
  },
  {
    "objectID": "analysis_03_tables.html#kruistabellen",
    "href": "analysis_03_tables.html#kruistabellen",
    "title": "9  Tabellen",
    "section": "9.2 Kruistabellen",
    "text": "9.2 Kruistabellen\nEen kruistabel (contingency table of cross table) geeft een samenvatting van gegevens voor twee categoriale variabelen. Hieronder staat een kruistabel van twee variabelen: het geslacht van een respondent en of de respondent rookt.\n\n\n9.2.1 Twee lay-outs van een kruistabel\nDe bovenstaande tabel toont de waargenomen frequenties. Dit is niet de manier waarop kruistabel moeten worden gepresenteerd. In plaats daarvan zijn er twee manieren die worden gebruikt en die beide voor deze cursus kunnen worden gebruikt.\n\n9.2.1.1 Lay-out 1\nIn de eerste lay-out worden alleen de percentages per categorie van de variabele in de rijen, behalve de totaalrij onderaan, getoond. Je berekent de percentages per kolom door het aantal waargenomen frequenties te delen door het totale aantal waarnemingen in die kolom. In de laatste kolom toon je ook de percentages.\n\nToegepast op bovenstaande gegevens (geslacht van de respondent en roken) zou de kruistabel er als volgt uitzien:\n\n\n\n9.2.1.2 Lay-out 2\nIn de tweede lay-out worden naast de percentages per categorie van de variabele in de rijen ook de waargenomen frequenties getoond. Ook hier deel je voor de percentages de waargenomen frequenties door het totale aantal waarnemingen in elke kolom. In de kolom “rijtotalen” worden echter alleen de waargenomen frequenties getoond.\n\nToegepast op bovenstaande gegevens zou de kruistabel er als volgt uitzien:\n\nVanzelfsprekend mogen de engelstalige termen ‘Frequency’, ‘Column %’, ‘Row totals’ en ‘Column totals’ ook vervangen worden door een Nederlandstalig equivalent (Frequentie, Kolompercentage, Rijtotaal, Kolomtotaal).\n\n\n\n\n\n\nRapportage: aanwijzingen\n\n\n\n\nGebruik een eenvoudige lay-out met een beperkt aantal (horizontale) lijnen. Verticale lijnen zijn niet nodig. De hierboven gebruikte standaard is acceptabel, maar ook een variant met slechts drie lijnen (boven, onder de titelrij en onder) is prima.\nZet de onafhankelijke variabele in de kolommen en de afhankelijke variabele in de rijen. Dit is een conventie (de statistiek verandert op zich niet als je het omdraait); het is voor je lezers makkelijker als je daaraan voldoet.\nPercenteer variabelen over de kolommen. Elke kolom moet optellen tot 100%.\nOmdat we weten dat de totalen van de kolommen 100% zijn, vermeld je daar de aantallen (in de laatste rij). Op die manier kan de lezer de aantallen van elke cel desgewenst terugrekenen. Het is ook acceptabel om zowel kolompercentages als aantallen in elke cel te vermelden (layout 1).\nDoorgaans kan worden afgerond op gehele getallen of één decimaal.\nZet een titel boven de tabel. Begin de titel met ‘Tabel’ en het nummer van de tabel.\nOnderaan de tabel kan desgewenst de bron worden vermeld.\nBij de interpretatie van de tabel worden de percentages over de rijen vergeleken, bijvoorbeeld: van de mannen rookte 56%, terwijl van de vrouwen 46% rookte.\n\n\n\n\n\n\n9.2.2 Kruistabellen in R\nEenvoudige tabellen kunnen worden gemaakt met table(), maar om kolompercentages en totalen toe te voegen en de mogelijkheid te bieden om te exporteren naar Word/HTML, gebruiken we het package flextable:\n\nlibrary(flextable) \n\n\ndata(loans_full_schema)\ntable_example &lt;- proc_freq(x = loans_full_schema, \n                           row = \"application_type\", \n                           col = \"homeownership\", \n                           include.row_percent = FALSE, \n                           include.table_percent = FALSE) \ntable_example\n\napplication_typehomeownershipMORTGAGEOWNRENTTotalindividualCount3,8391,1703,4968,505Col. pct80.2%86.5%90.6%jointCount9501833621,495Col. pct19.8%13.5%9.4%TotalCount4,7891,3533,85810,000\n\n\n\ntable_example &lt;- proc_freq(….)\n\nWe maken een tabel genaamd table_example met de functie proc_freq.\n\nx = loans_full_schema\n\nDit specificeert welke dataset (data.frame) we willen gebruiken.\n\nrow = \"application_type\"\n\nDit specificeert de variabele die we willen gebruiken in de rijen van de kruistabel.\n\ncol = \"homeownership\"\n\nDit specificeert de variabele die we willen gebruiken in de kolommen van de kruistabel.\n\ninclude.row_percent = FALSE\n\nHiermee geven we aan dat we de rijpercentages niet willen opnemen. Kolompercentages worden standaard wel opgenomen.\n\ninclude.table_percent = FALSE\n\nDit geeft aan dat we geen tabelpercentages willen opnemen.\n\n\nMet de volgende code kun je dit opslaan in een Word bestand (save_as_docx) en een HTML bestand (save_as_html). Merk op dat dit bestand wordt opgeslagen in de huidige werkdirectory (working directory).\n\nsave_as_docx(table_example, path = \"table_example.docx\")\nsave_as_html(table_example, path = \"table_example.html\")\n\n\ntable_example\n\nDit specificeert welke tabel we willen exporteren.\n\npath = \"table_example.docx\"\n\nDit specificeert de bestandsnaam voor het te exporteren bestand.\n\n\nMerk op dat deze tabel nog enige (handmatige) bewerking vereist als je alleen de percentages in de cellen wilt opnemen (zie lay-out 1). Vergeet ook niet om een titel voor de tabel op te nemen.\n\n\n\n\n\n\n\n\n\n9.2.3 Kruistabellen in R met expss\nEen alternatieve oplossing vereist iets langere R-code, maar levert een tabel op die niet verder bewerkt hoeft te worden voor lay-out optie 1. Deze oplossing gebruikt de pakketten expss en huxtable:\n\nlibrary(huxtable)\nlibrary(expss)\n\ndata(loans_full_schema)\n\ncross_table &lt;- loans_full_schema |&gt;\n  tab_cells(`Application type`= application_type) |&gt;\n  tab_cols(`Home ownership`= homeownership, total(homeownership)) |&gt;\n  tab_total_label(\"Total\") |&gt;\n  tab_stat_cpct() |&gt;\n  tab_pivot() |&gt;\n  drop_empty_rows() |&gt;\n  drop_empty_columns() |&gt;\n  as_huxtable() |&gt;\n  theme_article() |&gt;\n  set_number_format(row=everywhere,col=everywhere,value= \"%.0f %%\" ) |&gt;\n  set_number_format(row=final(1),col=everywhere,value=0)\n\ncross_table\n\n\nHome ownership#Total\n\nMORTGAGEOWNRENT\n\nApplication typeindividual80 %86 %91 %85 %\n\njoint20 %14 %9 %15 %\n\n#Total47891353385810000\n\n\n\ncross_table = loans_full_schema\n\nDit definieert dat we een tabel genaamd cross_table maken met de dataset loans_full_schema. Wanneer je een eigen tabel maakt, zou je deze natuurlijk hernoemen naar de naam van je eigen dataset.\n\ntab_cells(`Application type`= application_type)\n\nHiermee geven we aan dat we de variabele application_type willen gebruiken in de rijen. We geven ook aan dat we deze variabele willen weergeven als Application type, met behulp van ˝ Application type` `` (let op het gebruik van de zogenoemde backtick (˝) ).\n\ntab_cols(`Home ownership`= homeownership, total(homeownership))\n\nDit specificeert dat we de variabele homeownership willen gebruiken in de kolommen en ook een Totaal kolom willen opnemen (met het totaal van geldige waarden op de variabele homeownership). We specificeren ook dat we willen dat de variabele wordt weergegeven als Home ownership.\n\ntab_total_label(\"Total\")\n\nWe willen graag dat het totaallabel wordt weergegeven als Total.\n\ntab_stat_cpct()\n\nWe willen dat de tabel kolompercentages bevat.\n\ntab_pivot()\n\nDeze functie creëert de tabel.\n\ndrop_empty_rows()\n\nVerwijder alle lege rijen uit de tabel\n\ndrop_empty_columns()\n\nVerwijder alle lege kolommen uit de tabel\n\nas_huxtable()\n\nDit transformeert deze tabel in een tabel waar het huxtable pakket mee kan werken, wat verdere wijziging en export van de tabel mogelijk maakt.\n\ntheme_article()\n\nGeef de tabel een thema dat hem geschikt maakt voor publicatie in een wetenschappelijk tijdschrift.\n\nset_number_format(row=everywhere,col=everywhere,value= \"%.0f %%\" )\n\nRond percentages af op 0 decimalen en voeg het percentagesymbool toe.\n\nset_number_format(row=final(1),col=everywhere,value=0)\n\nRond de totaaltelling in de laatste rij af op 0 decimalen.\n\n\n\nNote: je hoeft alleen de eerste drie regels van deze code te veranderen om hem te gebruiken voor je eigen data: de naam van de data set en de variabelen.\n\nDeze tabel kan op de volgende manier worden opgeslagen in een Word document (quick_docx) en/of HTML bestand (quick_html):\n\nquick_docx(cross_table,\n           file = \"cross_table.docx\")\nquick_html(cross_table,\n           file = \"cross_table.html\")\n\n\ncross_table\n\nDit specificeert welke tabel we willen exporteren.\n\nfile = \"cross_table.docx\"\n\nDit specificeert de bestandsnaam voor het te exporteren bestand.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tabellen</span>"
    ]
  },
  {
    "objectID": "analysis_04_probability.html",
    "href": "analysis_04_probability.html",
    "title": "10  R en kansrekening",
    "section": "",
    "text": "10.1 Dobbelsteen rollen\nWe kunnen R gebruiken om de waarschijnlijkheid van verschillende dobbelsteenworpen te berekenen, zoals de kans op bepaalde getallen bij het meerdere malen gooien met een zeszijdige dobbelsteen. Dit kan bijvoorbeeld nuttig zijn om je handmatige berekeningen te controleren en om te zien of je de kansbegrippen goed begrepen hebt. Voor het dobbelen kunnen we het dice package gebruiken. Als je op je eigen computer werkt, moet je het package eerst installeren met het commando install.packages(\"dice\"). Het installeren van de package is niet nodig op universiteitscomputers.\nJe kunt het package als volgt laden:\nlibrary(dice) # Package laden\n\nLoading required package: gtools\nHet commando getEventProb() berekent de waarschijnlijkheid van een gebeurtenis voor een bepaald dobbelsteenproces. We kunnen dit specificeren door een lijstobject door te geven aan eventList. Het package kan verschillende scenario’s simuleren. We zullen de basisfuncties demonstreren, maar je kunt ook de extra functies bekijken, zie de handleiding.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>R en kansrekening</span>"
    ]
  },
  {
    "objectID": "analysis_04_probability.html#dobbelsteen-rollen",
    "href": "analysis_04_probability.html#dobbelsteen-rollen",
    "title": "10  R en kansrekening",
    "section": "",
    "text": "10.1.1 Kans op een 6 bij het gooien van een zeszijdige dobbelsteen\n\ngetEventProb(nrolls = 1,\n             ndicePerRoll = 1,\n             nsidesPerDie = 6,\n             eventList = list(6))\n\n[1] 0.1666667\n\n\n\ngetEventProb(\n\nDit deel van de code geeft aan dat we de waarschijnlijkheid van een gebeurtenis willen verkrijgen.\n\nnrolls = 1,\n\nDit getal staat voor het aantal te gooien dobbelstenen. In dit geval gooien we één keer met de dobbelsteen.\n\nndicePerRoll = 1,\n\nDit geheel getal staat voor het aantal dobbelstenen dat bij elke worp moet worden gebruikt.\n\nnsidesPerDie = 6,\n\nDit bepaalt het aantal zijden van de dobbelsteen. Je kunt dit bijvoorbeeld veranderen als je met een dobbelsteen met 10 zijden wilt werken. Wil je een dobbelsteen met zes zijden simuleren, laat het dan op 6 staan.\n\neventList = list(6))\n\nDit specificeert de gebeurtenis waarin we geïnteresseerd zijn. Merk op dat je een list() commando moet gebruiken. Een lijst is een type object in R. Voorlopig hoef je hier niet meer over te weten. Als je de kans op bijvoorbeeld een 4 wilt krijgen, moet je dit deel van de code veranderen in eventList = list(4)).\n\n\n\n\n10.1.2 Kans op een 1 of een 4 bij het gooien van een zeszijdige dobbelsteen\nWe kunnen de code aanpassen aan de gebeurtenis waarin we geïnteresseerd zijn. Als we de kans willen weten op een 1 of een 4 bij het gooien van een zeszijdige dobbelsteen, dan schrijven we:\n\ngetEventProb(nrolls = 1,\n             ndicePerRoll = 1,\n             nsidesPerDie = 6,\n             eventList = list(c(1,4)))\n\n[1] 0.3333333\n\n\n\ngetEventProb(\n\nDit deel van de code geeft aan dat we de waarschijnlijkheid van een gebeurtenis willen verkrijgen.\n\nnrolls = 1,\n\nDit getal staat voor het aantal te gooien dobbelstenen. In dit geval gooien we één keer met de dobbelsteen.\n\nndicePerRoll = 1,\n\nDit geheel getal staat voor het aantal dobbelstenen dat bij elke worp moet worden gebruikt.\n\nnsidesPerDie = 6,\n\nDit bepaalt het aantal zijden van de dobbelsteen. Je kunt dit bijvoorbeeld veranderen als je met een dobbelsteen met 10 zijden wilt werken. Wil je een dobbelsteen met zes zijden simuleren, laat het dan op 6 staan.\n\neventList = list(c(1,4)))\n\nDit specificeert de gebeurtenis waarin we geïnteresseerd zijn (als list). Hier zijn we geïnteresseerd in een 1 of een 4. Je schrijft het door c(1,4) in je lijst op te nemen. Je kunt meer getallen toevoegen. Als je bijvoorbeeld de kans op een 1, 2 of een 5 wilt berekenen, schrijf je eventList = list(c(1,2,5))).\n\n\n\n\n10.1.3 Kans op twee enen bij het tweemaal gooien van een zeszijdige dobbelsteen\nAls we willen weten hoe groot de kans is dat we twee keer 1 gooien met een zeszijdige dobbelsteen, dan schrijven we:\n\ngetEventProb(nrolls = 2, \n             ndicePerRoll = 1,\n             nsidesPerDie = 6,\n             eventList = list(1,1),\n             orderMatters = TRUE)\n\n[1] 0.02777778\n\n\n\ngetEventProb(\n\nDit deel van de code geeft aan dat we de waarschijnlijkheid van een gebeurtenis willen verkrijgen.\n\nnrolls = 2,\n\nDit getal staat voor het aantal te gooien dobbelstenen. In dit geval gooien we twee keer met de dobbelsteen.\n\nndicePerRoll = 1,\n\nDit geheel getal staat voor het aantal dobbelstenen dat bij elke worp moet worden gebruikt.\n\nnsidesPerDie = 6,\n\nDit bepaalt het aantal zijden van de dobbelsteen. Je kunt dit bijvoorbeeld veranderen als je met een dobbelsteen met 10 zijden wilt werken. Wil je een dobbelsteen met zes zijden simuleren, laat het dan op 6 staan.\n\neventList = list(1,1))\n\nDit specificeert de gebeurtenis waarin we geïnteresseerd zijn. Hier zijn we geïnteresseerd in twee 1-en. Merk op dat dit anders is dan voorheen omdat we niet c() schrijven. In plaats daarvan geven we aan dat het resultaat van belang, in dit voorbeeld, 1 is, gevolgd door een 1. Voor andere gebeurtenissen verander je de getallen tussen haakjes (bijv. list(1, c(5, 6)) om te berekenen wat de kans is dat je met de eerste worp een 1 gooit en met de tweede worp een 5 of een 6).\n\norderMatters = TRUE\n\nDeze optie geeft dat de volgorde van de condities in evenList van belang is. In dit voorbeeld maakt het geen verschil.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>R en kansrekening</span>"
    ]
  },
  {
    "objectID": "analysis_04_probability.html#kaartspel",
    "href": "analysis_04_probability.html#kaartspel",
    "title": "10  R en kansrekening",
    "section": "10.2 Kaartspel",
    "text": "10.2 Kaartspel\nWe kunnen R gebruiken om de waarschijnlijkheid te berekenen van het trekken van combinaties van kaarten uit een kaartspel. Een standaard kaartspel heeft 52 kaarten in 13 waarden en 4 kleuren. De kleuren zijn schoppen (Spade), klaveren (Club), ruiten (Diamond) en harten (Heart). Elke kleur heeft 13 kaartwaarden: 2-10, 3 “gezichtskaarten” Boer (Jack), Koningin (Queen), Koning (King) (J, Q, K) en een Aas (Ace). Helaas is er geen R package beschikbaar zoals in het voorbeeld van het dobbelen. De openintro gegevens bevatten echter een voorgedefinieerd kaartspel dat alle kaarten van een standaard kaartspel bevat.\n\ndata(cards, package = \"openintro\") # Specificeer dat we de dataset cards van package openintro willen gebruiken\n\nEr zijn 52 waarnemingen voor 4 variabelen in de dataset:\n\nwaarde\n\neen factor met niveaus 10 2 3 4 5 6 7 8 9 A J K Q\n\nkleur\n\neen factor met de niveaus zwart rood\n\nsuit\n\neen factor met de niveaus klaveren ruiten harten schoppen\n\ngezicht\n\neen logische vector (TRUE voor gezichtskaarten en FALSE voor alle andere kaarten)\n\n\nOm de kans op een ‘Aas’-kaart te berekenen, kunnen we nagaan hoe vaak zo’n kaart voorkomt. Dit kan gemakkelijk in R met de filter() functie uit het tidyverse package. Dit package is geïnstalleerd op alle computers van de universiteit.\n\nlibrary(tidyverse) \n\nWe kunnen dan de functie filter() gebruiken om casussen te selecteren op basis van hun waarden (zie Hoofdstuk 2). Voor ons doel hier gebruiken we een specifieke manier om kaarten in ons kaartspel te selecteren, en wel als volgt:\n\ncards |&gt; \n  filter(value == \"A\")\n\n# A tibble: 4 × 4\n  value color suit    face \n  &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;   &lt;lgl&gt;\n1 A     red   Heart   TRUE \n2 A     red   Diamond TRUE \n3 A     black Spade   TRUE \n4 A     black Club    TRUE \n\n\n\ncards |&gt;\n\nDit deel van de code geeft aan dat we werken met het ‘cards’ dataframe. |&gt; wordt in R de pipe operator genoemd (zie week 2).\n\nfilter(value == \"A\")\n\nHier vragen we R om gevallen te kiezen (d.w.z. te filteren) wanneer een van de kaarten (merk op dat deze variabele ‘value’ heet) gelijk is aan \"A\". Let op: vergelijkingen van characters zijn altijd hoofdlettergevoelig, dus schrijf niet “a”.\n\n\nNu we weten dat er 4 azen zijn en omdat we weten dat er 52 kaarten in ons kaartspel zitten, kunnen we eenvoudigweg 4 delen door 52 om de kans op een aas te krijgen.\n\n4/52\n\n[1] 0.07692308\n\n\nOp dezelfde manier kunnen we testen hoeveel ruiten kaarten (Diamond) er zijn en de waarschijnlijkheid berekenen:\n\ncards |&gt; \n  filter(suit == \"Diamond\") \n\n# A tibble: 13 × 4\n   value color suit    face \n   &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;   &lt;lgl&gt;\n 1 2     red   Diamond FALSE\n 2 3     red   Diamond FALSE\n 3 4     red   Diamond FALSE\n 4 5     red   Diamond FALSE\n 5 6     red   Diamond FALSE\n 6 7     red   Diamond FALSE\n 7 8     red   Diamond FALSE\n 8 9     red   Diamond FALSE\n 9 10    red   Diamond FALSE\n10 J     red   Diamond TRUE \n11 Q     red   Diamond TRUE \n12 K     red   Diamond TRUE \n13 A     red   Diamond TRUE \n\n13/52\n\n[1] 0.25\n\n\nAls we geïnteresseerd zijn in gezichtskaarten, verandert onze code enigszins omdat dit een logische vector is (dat is een vector die alleen de waarden TRUE or FALSE kan aannemn). We plaatsen geen aanhalingstekens rond TRUE, maar schrijven gewoon:\n\ncards |&gt; \n  filter(face == TRUE) \n\n# A tibble: 16 × 4\n   value color suit    face \n   &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;   &lt;lgl&gt;\n 1 J     red   Heart   TRUE \n 2 Q     red   Heart   TRUE \n 3 K     red   Heart   TRUE \n 4 A     red   Heart   TRUE \n 5 J     red   Diamond TRUE \n 6 Q     red   Diamond TRUE \n 7 K     red   Diamond TRUE \n 8 A     red   Diamond TRUE \n 9 J     black Spade   TRUE \n10 Q     black Spade   TRUE \n11 K     black Spade   TRUE \n12 A     black Spade   TRUE \n13 J     black Club    TRUE \n14 Q     black Club    TRUE \n15 K     black Club    TRUE \n16 A     black Club    TRUE \n\n16/52\n\n[1] 0.3076923\n\n\nWe kunnen het voorkomen van combinaties vinden, bijvoorbeeld alle kaarten vinden die ofwel Aas of een Ruit zijn. Daartoe gebruiken we het symbool | dat staat voor OR (OF):\n\ncards |&gt; \n  filter(suit == \"Diamond\" | value == \"A\")\n\n# A tibble: 16 × 4\n   value color suit    face \n   &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;   &lt;lgl&gt;\n 1 A     red   Heart   TRUE \n 2 2     red   Diamond FALSE\n 3 3     red   Diamond FALSE\n 4 4     red   Diamond FALSE\n 5 5     red   Diamond FALSE\n 6 6     red   Diamond FALSE\n 7 7     red   Diamond FALSE\n 8 8     red   Diamond FALSE\n 9 9     red   Diamond FALSE\n10 10    red   Diamond FALSE\n11 J     red   Diamond TRUE \n12 Q     red   Diamond TRUE \n13 K     red   Diamond TRUE \n14 A     red   Diamond TRUE \n15 A     black Spade   TRUE \n16 A     black Club    TRUE \n\n\nOp basis hiervan zijn er 16 kaarten die ofwel een Aas ofwel een Ruit zijn. Daarom is de kans om een Aas óf een Ruit te trekken 16 gedeeld door 52:\n\n16/52\n\n[1] 0.3076923\n\n\nJe kunt ook het “&” symbool gebruiken om AND (EN) aan te geven, bijvoorbeeld om het aantal kaarten te krijgen dat rood is én een Aas:\n\ncards |&gt; \n  filter(color == \"red\" & value == \"A\")\n\n# A tibble: 2 × 4\n  value color suit    face \n  &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;   &lt;lgl&gt;\n1 A     red   Heart   TRUE \n2 A     red   Diamond TRUE \n\n\nJe kunt de code uitbreiden, bijvoorbeeld door te schrijven als je het aantal kaarten wilt vinden die ofwel Ruit, of Aas, of Koning zijn. Omdat we alleen het aantal rijen willen weten sluiten we onze pipe af met nrow():\n\ncards |&gt; \n  filter(value %in% c(\"A\", \"K\") | suit == \"Diamond\") |&gt;\n  nrow()\n\n[1] 19",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>R en kansrekening</span>"
    ]
  },
  {
    "objectID": "analysis_04_probability.html#voorwaardelijke-kansen-met-een-kruistabel",
    "href": "analysis_04_probability.html#voorwaardelijke-kansen-met-een-kruistabel",
    "title": "10  R en kansrekening",
    "section": "10.3 Voorwaardelijke kansen met een kruistabel",
    "text": "10.3 Voorwaardelijke kansen met een kruistabel\nWe kunnen waarschijnlijkheden onderzoeken met een kruistabel. Voor deze demonstratie gebruiken we de dataset uit het boek genaamd photo_classify uit het openintro package. Dit is een gesimuleerde dataset voor fotoclassificaties gebaseerd op een machine learning algoritme versus wat de echte classificatie voor die foto’s is. Hoewel de gegevens niet echt zijn, lijken ze op prestaties die redelijkerwijs te verwachten zijn in een goed gebouwde classificeerder. Zie voor meer informatie hoofdstuk 3.2 in het boek.\nEerst maken we een kruistabel van de twee variabelen mach_lean en waarheid. In week 2 kwamen we een manier tegen om kruistabellen in R te maken met behulp van het flextable package.\n\nlibrary(flextable) \n\n\nAttaching package: 'flextable'\n\n\nThe following object is masked from 'package:purrr':\n\n    compose\n\n\nIn week 2 gebruikten we deze code die de percentages over de kolommen weergeeft.\n\nlibrary(openintro)\ndata(photo_classify)\n\ntable_example &lt;- proc_freq(x = photo_classify, \n                           row = \"mach_learn\", \n                           col = \"truth\", \n                           include.row_percent = FALSE, \n                           include.table_percent = FALSE) \ntable_example\n\nmach_learntruthfashionnotTotalpred_fashionCount19722219Col. pct63.8%1.5%pred_notCount1121,4911,603Col. pct36.2%98.5%TotalCount3091,5131,822\n\n\nMet het flextable package kunnen we ook de tabelpercentages weergeven. De onderstaande code maakt een tabel met gezamenlijke kansen (joint probabilities) voor de photo_classify gegevens. De percentages worden berekend door het aantal in elke cel te delen door het totaal van de tabel (1822).\n\ntable_example2 &lt;- proc_freq(x = photo_classify, \n                           row = \"mach_learn\", \n                           col = \"truth\", \n                           include.row_percent = FALSE,\n                           include.column_percent = FALSE,\n                           include.table_percent = TRUE,\n                           include.column_total = TRUE) \n\n\ntable_example = proc_freq(…)\n\nWe definiëren dat we een tabel genaamd table_example2 willen maken met behulp van de functie proc_freq.\n\nx = photo_classify\n\nDit specificeert welke dataset (data.frame) we willen gebruiken.\n\nrow = \"mach_learn\"\n\nDit specificeert de variabele die we willen gebruiken in de rijen van de kruistabel.\n\ncol = \"truth\"\n\nDit specificeert de variabele die we willen gebruiken in de kolom van de kruistabel.\n\ninclude.row_percent = FALSE\n\nHiermee geven we aan dat we geen rijpercentages willen opnemen.\n\ninclude.column_percent = FALSE,\n\nHiermee geven we aan dat we geen kolompercentages willen opnemen.\n\ninclude.table_percent = TRUE\n\nHiermee geven we aan dat we wel tabelpercentages willen opnemen.\n\ninclude.column_total = TRUE)\n\nHiermee geven we aan dat we kolomtotalen willen opnemen.\n\n\n\ntable_example2\n\nmach_learntruthfashionnotTotalpred_fashion197 (10.8%)22 (1.2%)219 (12.0%)pred_not112 (6.1%)1,491 (81.8%)1,603 (88.0%)Total309 (17.0%)1,513 (83.0%)1,822 (100.0%)\n\n\nOp basis hiervan kunnen we zien dat de classificator in 10,81 % van de gevallen de modefoto’s correct voorspelde (zie cel fashion, pred_fashion) en in 6,15 % van de gevallen geen modefoto correct voorspelde. Evenzo voorspelde de classificator in 1,21 % van de gevallen een foto die geen modefoto was als “mode” en in 81,83 % van de gevallen was de classificator correct in zijn beoordeling dat een foto die geen modefoto was inderdaad geen modefoto was.\nDit is dezelfde tabel als op blz. 96 van het boek.\n\n10.3.1 Voorwaardelijke kansen\nOm voorwaardelijke kansen verder te onderzoeken, kunnen we de informatie uit de zojuist gemaakte tabel gebruiken.\nStel dat we de kans willen berekenen dat een foto over mode ging (truth is fashion) gegeven dat de voorspelling was dat de foto over mode gaat (mach_learn is pred_fashion). We zien dat er 219 gevallen waren waarin de voorspelling mode was en dat de foto in 197 gevallen inderdaad een modefoto was.\nP(truth is fashion given mach_learn is pred_fashion ) = \\((\\frac{197}{219})= 0.900\\)\nIn R kunnen we de waarde als volgt berekenen:\n\n197/219\n\n[1] 0.8995434",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>R en kansrekening</span>"
    ]
  },
  {
    "objectID": "analysis_05_normal_distribution.html",
    "href": "analysis_05_normal_distribution.html",
    "title": "11  Normaalverdeling",
    "section": "",
    "text": "11.1 Berekening van z-scores\nDe z-score is een maat die aangeeft hoe ver een bepaalde waarde in een bepaalde dataset onder of boven het gemiddelde ligt. De formule voor de z-score is:\n\\(z = \\frac{x-\\mu}\\sigma\\)\nWe gebruiken het voorbeeld van cumulatieve SAT-scores (\\(mu\\) = 1100 en \\(sigma\\) = 200) om de berekening van z-scores te illustreren. Om de z-score van een waarde van 1190 te berekenen, zouden we berekenen:\n\\(z = \\frac{x-\\mu}\\sigma = \\frac{1190-1100}{200}\\)\n(1190-1100)/200\n\n[1] 0.45\nDit geeft aan dat de z-score positief is (0,45) en dat deze 0,45 standaarddeviaties boven het gemiddelde ligt.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Normaalverdeling</span>"
    ]
  },
  {
    "objectID": "analysis_05_normal_distribution.html#gebied-onder-de-normaalcurve-berekenen",
    "href": "analysis_05_normal_distribution.html#gebied-onder-de-normaalcurve-berekenen",
    "title": "11  Normaalverdeling",
    "section": "11.2 Gebied onder de normaalcurve berekenen",
    "text": "11.2 Gebied onder de normaalcurve berekenen\nOm het gebied in een standaardnormale (z) verdeling te vinden, kunnen we de functie pnorm() gebruiken. Maar let op: deze geeft standaard de oppervlakte, of waarschijnlijkheid, onder een bepaalde z-waarde (dus de linkerstaart (left tail)):\n\npnorm(0.45)\n\n[1] 0.6736448\n\n\nDe waarde geeft dus aan dat 67,36 % van de waarden onder een z-waarde van 0,45 liggen. Als we geïnteresseerd zijn in het gebied boven een z-score van 0,45, dan is dat: 1 - 0.6736448 = 0.3263552. Dit kunnen we ook direct berekenen met pnorm door lower.tail = FALSE te specificeren:\n\npnorm(0.45, lower.tail = FALSE)\n\n[1] 0.3263552\n\n\nOngeveer 32,65 % van de waarden ligt boven een SAT-score van 1190.\nWe kunnen ook het gebied tussen twee z-scores berekenen. Als we bijvoorbeeld geïnteresseerd zijn in het gebied tussen SAT-scores van 950 en 1200, berekenen we twee z-scores:\n\n(950-1100)/200\n\n[1] -0.75\n\n(1200-1100)/200\n\n[1] 0.5\n\n\nDe z-score van een SAT-score van 950 is - 0,75, de z-score van een SAT-score van 1200 is 0,5. Het gebied, of de waarschijnlijkheid, onder deze specifieke z-waarden (of, zo je wilt, van de linker staart) zijn:\n\npnorm(-0.75)\n\n[1] 0.2266274\n\npnorm(0.5)\n\n[1] 0.6914625\n\n\nVergeet niet dat beide de grootte van het gebied aan de linkerkant aangeven. Om de oppervlakte onder de curve tussen de twee SAT-scores te vinden, kunnen we dus de kleinste waarde (die overeenkomt met een SAT-score van 950) aftrekken van de grootste waarde. Dit geeft ons:\n\npnorm(0.5) - pnorm(-0.75)\n\n[1] 0.4648351\n\n\nMerk op dat we eenvoudigweg pnorm(0.5) - pnorm(-0.75) kunnen schrijven en R zal de waarde van pnorm(-0.75) (die 0.2266274 is) aftrekken van pnorm(0.5) (die 0.6914625 is).\nJe kunt ook direct het gebied onder de curve berekenen zonder eerst de z-waarden te berekenen. Met de functie pnorm() kunnen we direct de waarde opgeven die we zoeken, samen met het gemiddelde en de standaardafwijking van onze normaalverdeling:\n\npnorm(1200, mean = 1100, sd = 200) - pnorm(950, mean = 1100, sd = 200)\n\n[1] 0.4648351",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Normaalverdeling</span>"
    ]
  },
  {
    "objectID": "analysis_05_normal_distribution.html#vind-de-grenswaarde-bij-een-gebied",
    "href": "analysis_05_normal_distribution.html#vind-de-grenswaarde-bij-een-gebied",
    "title": "11  Normaalverdeling",
    "section": "11.3 Vind de grenswaarde bij een gebied",
    "text": "11.3 Vind de grenswaarde bij een gebied\nNatuurlijk is het ook mogelijk om het omgekeerde te doen, bijvoorbeeld als we geïnteresseerd zijn welke SAT-score nodig is om tot de 10% beste scores te behoren. Hiervoor gebruiken we de functie qnorm(). Deze functie wordt standaard bij R geleverd en wordt gebruikt om de grenswaarde te vinden die een gebied bepaalt. Stel bijvoorbeeld dat je dat 90e percentiel wilt vinden van een normaalverdeling waarvan het gemiddelde 1100 en de standaardafwijking 200 is. Dan vraag je om:\n\nqnorm(0.9, mean = 1100, sd = 200)\n\n[1] 1356.31\n\n\n\nqnorm(0.9, mean = 1100, sd = 200)\n\nDeze code berekent het punt onder de curve waar 90% van de leerlingen in een populatie die normaal verdeeld is met gemiddelde 1100 en standaardafwijking 200 onder zal liggen. Je kunt de waarden veranderen afhankelijk van de situatie. Als je het 45e percentiel van een normale verdeling wilt berekenen, schrijf dan qnorm(0.45, mean = 1100, sd = 200).",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Normaalverdeling</span>"
    ]
  },
  {
    "objectID": "analysis_05_normal_distribution.html#gebied-onder-de-curve-met-visualize",
    "href": "analysis_05_normal_distribution.html#gebied-onder-de-curve-met-visualize",
    "title": "11  Normaalverdeling",
    "section": "11.4 Gebied onder de curve met visualize",
    "text": "11.4 Gebied onder de curve met visualize\nAls alternatief kunnen we het visualize package gebruiken om kansverdelingen grafisch weer te geven. Dit package is erg handig omdat we hiermee ook de gezochte waarde kunnen afbeelden.\n\nlibrary(visualize)\n\nStel dat we het gebied onder de curve onder SAT-scores van 950 willen plotten bij een normaalverdeling van SAT-scores (gemiddelde = 1100 en sd = 200), dan moeten we schrijven:\n\nvisualize.norm(stat = 950, \n               mu = 1100, \n               sd = 200, \n               section = \"lower\")\n\n\n\n\n\n\n\n\n\nvisualize.norm(...)\n\nvisualize.norm() genereert een plot van de normaalverdeling met door de gebruiker opgegeven parameters.\n\nstat = 950\n\nHier geven we de grenswaarde op (in dit voorbeeld een SAT-score van 950).\n\nmu = 1100\n\nDit specificeert het gemiddelde van de normaalverdeling.\n\nsd = 200\n\nDit specificeert de standaardafwijking van de normaalverdeling.\n\nsection = \"lower\"\n\nHier kies je welk gebied je wilt arceren en berekenen. De opties zijn “lower” (gebied onder de grenswaarde), “upper” (gebied boven de grenswaarde), “bounded” (gebied tussen twee grenswaardes) en “tails” (de twee staarten van de verdeling).\n\n\nOm de oppervlakte onder de curve tussen SAT-scores van 950 en 1200 in een normaalverdeling van SAT-scores (gemiddelde = 1100 en sd = 200) uit te zetten, moeten we schrijven:\n\nvisualize.norm(stat = c(950, 1200), \n               mu = 1100, \n               sd = 200, \n               section = \"bounded\")\n\n\n\n\n\n\n\n\n\nvisualize.norm(...)\n\nvisualize.norm() genereert een plot van de normaalverdeling met door de gebruiker opgegeven parameters.\n\nstat = c(950, 1200)\n\nWe willen de grootte van het gebied tussen twee punten berekenen, dus definiëren we stat = c(&lt;ondergrens&gt;, &lt;bovengrens&gt;).\n\nmu = 1100\n\nDit specificeert het gemiddelde van de normaalverdeling.\n\nsd = 200\n\nDit specificeert de standaardafwijking van de normaalverdeling.\n\nsection = \"bounded\"\n\nHier kies je welk gebied je wilt arceren en berekenen. De opties zijn “lower” (gebied onder de grenswaarde), “upper” (gebied boven de grenswaarde), “bounded” (gebied tussen twee grenswaardes) en “tails” (de twee staarten van de verdeling).",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Normaalverdeling</span>"
    ]
  },
  {
    "objectID": "analysis_06_proportions.html",
    "href": "analysis_06_proportions.html",
    "title": "12  Inferentie voor proporties",
    "section": "",
    "text": "12.1 Inferentie voor één proportie",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Inferentie voor proporties</span>"
    ]
  },
  {
    "objectID": "analysis_06_proportions.html#inferentie-voor-één-proportie",
    "href": "analysis_06_proportions.html#inferentie-voor-één-proportie",
    "title": "12  Inferentie voor proporties",
    "section": "",
    "text": "12.1.1 Betrouwbaarheidsinterval voor één proportie\n\n12.1.1.1 Berekenen ‘met de hand’ met behulp van R\nEén benadering is het berekenen van de normale benadering van de binomiale verdeling (Wald-interval), zoals beschreven in het OpenIntro-boek. Dit is eigenlijk hetzelfde als de ‘handmatige’ berekening, maar dan in R.\nAls voorbeeld gebruiken we een enquête onder kiezers waarin 23% aangeeft de Conservatieven te steunen. We schatten een 95% betrouwbaarheidsinterval voor deze schatting:\n\n# Input definiëren (verander deze waarden)\np_hat &lt;- 0.23\nn &lt;- 1000\nconfidence &lt;- 0.95\n\n\n# Voer berekeningen uit (je hoeft hier niets te veranderen)\nse &lt;- sqrt(p_hat * (1 - p_hat)/ n)     # Standaardfout berekenen\nz_star &lt;- qnorm((1 + confidence) / 2)  # Z*-waarde berekenen\nlower &lt;- p_hat - z_star * se           # Ondergrens betrouwbaarheidsinterval\nupper &lt;- p_hat + z_star * se           # Bovengrens betrouwbaarheidsinterval\nc(lower, upper)\n\n[1] 0.203917 0.256083\n\n\n\n\n12.1.1.2 Samengevatte gegevens\nWanneer je alleen beknopte gegevens hebt, d.w.z. informatie over de steekproefgrootte en de steekproefproportie, raden we aan prop.test te gebruiken voor het berekenen van een betrouwbaarheidsinterval voor een enkele proportie.1 De functie prop.test maakt deel uit van het package stats, dat een van de weinige packages is die R automatisch laadt wanneer het start.\n\n# Input definiëren (verander deze waarden)\np_hat &lt;- 0.23\nn &lt;- 1000\n\n# Voer berekeningen uit (pas zo nodig alleen conf.level aan)\nprop.test(x = p_hat * n, \n          n = n, \n          conf.level = 0.95)\n\n\nprop.test\n\nDit is de functie die een test uitvoert voor een proportie en het bijbehorende betrouwbaarheidsinterval.\n\nx = p_hat * n\n\nDe eerste opgegeven waarde moet het aantal successen zijn. In ons voorbeeld is dat het aantal mensen dat de Conservatieven steunt. We kunnen dit berekenen als de proportie in de steekproef ($ $) keer de steekproefomvang.\n\nn = n\n\nDe tweede opgegeven waarde is het aantal proeven (lees: het aantal waarnemingen in onze dataset). In ons geval: het aantal respondenten in de dataset.\n\nconf.level = 0.95\n\nDit bepaalt het betrouwbaarheidsniveau. De standaardwaarde is 0.95, wat overeenkomt met een betrouwbaarheidsinterval van 95%.\n\n\n\n\n\n    1-sample proportions test with continuity correction\n\ndata:  p_hat * n out of n, null probability 0.5\nX-squared = 290.52, df = 1, p-value &lt; 2.2e-16\nalternative hypothesis: true p is not equal to 0.5\n95 percent confidence interval:\n 0.2045014 0.2576046\nsample estimates:\n   p \n0.23 \n\n\nEr is een kleine afwijking t.o.v. de handmatige berekening, omdat R automatisch een continuïteitscorrectie toepast en een Wilson score interval gebruikt (een iets geavanceerdere versie van het betrouwbaarheidsinterval).\n\n\n12.1.1.3 Gegevens in een dataframe\nAls je een dataframe hebt met een variabele die voor elk geval het succes (of niet) weergeeft, kunnen we de volgende procedure gebruiken. In ons voorbeeld hebben we een variabele die de stemintentie van een respondent registreert, die ofwel Conservative ofwel Other party is:\n\n# Voor dit voorbeeld maken we een dataset van 1000 respondenten waarvan er 230 een voorkeur voor de Conservatieven hebben.\nexample_data &lt;- data.frame(party_choice = factor(c(rep(\"Conservatives\", 230), \n                                                  rep(\"Other party\", 770))))\ntable(example_data$party_choice)\n\n\nConservatives   Other party \n          230           770 \n\n\nAls we dergelijke gegevens hebben, kunnen we direct het betrouwbaarheidsinterval berekenen door prop.test uit te voeren voor de tabel:\n\nprop.test(table(example_data$party_choice),\n          conf.level = 0.95)\n\n\ntable(example_data$party_choice)\n\nHet eerste argument is een tabel met onze variabele, die we met deze code kunnen aanmaken. Als je je eigen gegevens gebruikt, vervang dan example_data door de naam van je dataframe en party_choice door de naam van de variabele. 2\nNoot: De variabele/tabel mag slechts twee categorieën bevatten. R zal het betrouwbaarheidsinterval berekenen voor de eerste categorie in de tabel (in ons geval: Conservatieven). 3\n\nconf.level = 0.95\n\nDit bepaalt het betrouwbaarheidsniveau. De standaardwaarde is 0.95, wat overeenkomt met een betrouwbaarheidsinterval van 95%.\n\n\n\n\n\n    1-sample proportions test with continuity correction\n\ndata:  table(example_data$party_choice), null probability 0.5\nX-squared = 290.52, df = 1, p-value &lt; 2.2e-16\nalternative hypothesis: true p is not equal to 0.5\n95 percent confidence interval:\n 0.2045014 0.2576046\nsample estimates:\n   p \n0.23 \n\n\nDe resultaten zijn identiek aan de berekening op basis van de samengevatte gegevens.\n\n\n\n\n\n\nRapportage\n\n\n\n\nHet 95% betrouwbaarheidsinterval voor de steun van kiezers voor de Conservatieve partij loopt van 20,5% tot 25,8% (N = 1000).\nIn deze peiling (N = 1000) was de steun van kiezers voor de Conservatieve partij gelijk aan 23%, 95% CI [20,5%; 25,8%].\n\nNeem dus naast een omschrijving in je rapportage op:\n\nDe onder- en bovengrens van het interval.\nOm welk betrouwbaarheidsinterval het gaat: 90%, 95%, 99% (of nog anders)\nZeker bij peilingen is het gebruikelijk en aanbevelingswaardig om de steekproefomvang te vermelden.\n\n\n\n\n\n\n12.1.2 Hypothesetoetsen voor een enkele proportie\n\n12.1.2.1 Samengevatte gegevens\nWanneer je alleen informatie hebt over de steekproefgrootte en de proportie, raden we aan prop.test te gebruiken voor het uitvoeren van een hypothesetoets.4\n\n# Input definiëren (verander deze waarden)\np_hat &lt;- 0.23\nn &lt;- 1000\n\n# Voer berekeningen uit\nprop.test(x = p_hat * n, \n          n = n, \n          p = 0.25,\n          alternative = \"two.sided\")\n\n\nprop.test\n\nDit is de functie die een test uitvoert voor een proportie en het bijbehorende betrouwbaarheidsinterval.\n\nx = p_hat * n\n\nDe eerste opgegeven waarde moet het aantal successen zijn. In ons voorbeeld is dat het aantal mensen dat de Conservatieven steunt. We kunnen dit berekenen als de proportie in de steekproef (\\(hat{p}\\)) keer de steekproefomvang.\n\nn = n\n\nDe tweede opgegeven waarde is het aantal proeven (lees: het aantal waarnemingen in onze dataset). In ons geval: het aantal respondenten in de dataset.\n\np = 0.25\n\nDit specificeert de waarde onder de nulhypothese. In dit voorbeeld is dit 0.25 of 25%, dus testen we de nulhypothese \\(mu_0 = 0.25\\).\n\nalternative = \"two.sided\"\n\nBepaalt of we een tweezijdige of een eenzijdige test willen gebruiken. Opties zijn “tweezijdig” (standaard), “less” (als \\(H_1: \\mu &lt; p\\)) of “greater” (als \\(H_1: \\mu &gt; p\\)).\n\n\n\n\n\n    1-sample proportions test with continuity correction\n\ndata:  p_hat * n out of n, null probability 0.25\nX-squared = 2.028, df = 1, p-value = 0.1544\nalternative hypothesis: true p is not equal to 0.25\n95 percent confidence interval:\n 0.2045014 0.2576046\nsample estimates:\n   p \n0.23 \n\n\n\n\n12.1.2.2 Gegevens in een dataframe\nAls je een dataframe hebt met een variabele die voor elk geval het succes (of niet) weergeeft, kunnen we de volgende procedure gebruiken. In ons voorbeeld hebben we een variabele die de stemintentie van een respondent registreert, die ofwel Conservative ofwel Other Party is (voor het voorbereiden van de data zie hierboven Gegevens in een dataframe).\n\nprop.test(table(example_data$party_choice),\n          p = 0.25,\n          alternative = \"two.sided\")\n\n\ntable(example_data$party_choice)\n\nHet eerste argument is een tabel met onze variabele, die we met deze code kunnen aanmaken. Als je je eigen gegevens gebruikt, vervang dan example_data door de naam van je dataframe en party_choice door de naam van de variabele.\nNoot: De variabele/tabel mag slechts twee categorieën bevatten. R voert de test uit dat de proportie voor de eerste categorie (in ons geval ‘Conservatieven’) gelijk is aan de hypothetische waarde (p, zie hieronder).\n\np = 0.25\n\nDit specificeert de waarde onder de nulhypothese. In dit voorbeeld is dit 0.25 of 25%, dus testen we de nulhypothese \\(mu_0 = 0.25\\).\n\nalternative = \"two.sided\"\n\nBepaalt of we een tweezijdige of een eenzijdige test willen gebruiken. Opties zijn “tweezijdig” (standaard), “less” (als \\(H_1: \\mu &lt; p\\)) of “greater” (als \\(H_1: \\mu &gt; p\\)).\n\n\n\n\n\n    1-sample proportions test with continuity correction\n\ndata:  table(example_data$party_choice), null probability 0.25\nX-squared = 2.028, df = 1, p-value = 0.1544\nalternative hypothesis: true p is not equal to 0.25\n95 percent confidence interval:\n 0.2045014 0.2576046\nsample estimates:\n   p \n0.23 \n\n\n\n\n\n\n\n\nRapportage\n\n\n\n\nHet in onze steekproef (N = 1000) gevonden percentage steun voor de Conservatieve partij (23%) wijkt statistisch significant af van de testwaarde (25%), \\(\\chi^2(1) = 2{,}028\\), p = 0,154.\n\nof, equivalent (waarbij we de z-waarde rapporteren, die gelijk is aan de wortel van bovengenoemde \\(\\chi^2\\)-waarde):\n\nHet in onze steekproef (N = 1000) gevonden percentage steun voor de Conservatieve partij (23%) wijkt statistisch significant af de testwaarde (25%), z = 1,42, p = 0,154.\n\nNeem dus naast een inhoudelijke omschrijving in je rapportage op:\n\nDe twee percentages/proporties die worden vergeleken.\nDe z-waarde of Chikwadraatwaarde. Als je de laatste gebruikt ook het aantal vrijheidsgraden tussen haken, dat is voor dit soort berekeningen altijd 1.\np = p-waarde. Maar: schrijf nooit \\(p = 0,000\\). Want de p-waarde is nooit precies nul, maar heel klein. Het is dan beter om te zeggen \\(p &lt; 0,001\\). Als de hypothesetoets handmatig uitvoert schrijf je p &lt; α-waarde, bijvoorbeeld \\(p &lt; 0,05\\).",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Inferentie voor proporties</span>"
    ]
  },
  {
    "objectID": "analysis_06_proportions.html#twee-onafhankelijke-proporties-vergelijken",
    "href": "analysis_06_proportions.html#twee-onafhankelijke-proporties-vergelijken",
    "title": "12  Inferentie voor proporties",
    "section": "12.2 Twee onafhankelijke proporties vergelijken",
    "text": "12.2 Twee onafhankelijke proporties vergelijken\nHierboven hebben we een betrouwbaarheidsinterval berekend voor één proportie. In deze paragraaf behandelen we twee (onafhankelijke) proporties. De onderstaande berekeningen gelden voor het geval dat de twee proporties afkomstig zijn uit verschillende steekproeven of deelsteekproeven, bijvoorbeeld de steun voor een partij in twee afzonderlijke opiniepeilingen (deze groepen zijn onafhankelijk omdat de samenstelling van de steekproef doorgaans verschilt van steekproef tot steekproef) of het links-rechtsstandpunt van respondenten die in de hoofdstad wonen en respondenten die daar niet wonen (deze groepen zijn onafhankelijk omdat je er maar tot één kunt behoren).\n\n12.2.1 Betrouwbaarheidsinterval voor het verschil tussen twee proporties\nWe gebruiken de CPR dataset uit het openintro package (zie p. 218). De dataset bevat gegevens over patiënten die willekeurig werden verdeeld in een behandelingsgroep waar ze een bloedverdunner kregen of de controlegroep waar ze geen bloedverdunner kregen. De uitkomstvariabele was of de patiënten ten minste 24 uur overleefden.\n\nlibrary(tidyverse)\nlibrary(openintro)\nlibrary(flextable) \n\n\ndata(cpr)\n\n# Factorniveaus van variabelen aanpassen om ervoor te zorgen dat de volgorde hetzelfde is als in de tabel in het tekstboek\n\ncpr &lt;- cpr |&gt;\n  mutate(group = factor(group, levels = c(\"control\", \"treatment\"), ordered = TRUE),\n         outcome = factor(outcome, levels = c(\"survived\", \"died\"), ordered = TRUE))\n\ntable_example &lt;- proc_freq(x = cpr, \n                           row = \"group\", \n                           col = \"outcome\", \n                           include.row_percent = FALSE, \n                           include.column_percent = FALSE, \n                           include.table_percent = FALSE) \ntable_example\n\ngroupoutcomesurviveddiedTotalcontrol113950treatment142640Total256590\n\n\nMerk op dat we gewoonlijk de onafhankelijke variabele in de kolommen zetten. Het boek volgt deze conventie echter niet.\n\n12.2.1.1 Met de hand berekenen met R\nOm een 90 % betrouwbaarheidsinterval van het verschil voor de overlevingspercentages (\\(p_{1}\\) en \\(p_{2}\\)) met de hand te berekenen, kunnen we schrijven:\n\n# Definieer invoer (pas deze aan voor je eigen berekeningen)\np_hat_1 &lt;- 14 / 40  # Treatment group\np_hat_2 &lt;- 11 / 50  # Control group\nn_1 &lt;- 40\nn_2 &lt;- 50\nconfidence = 0.9\n\n# Voer berekeningen uit (je hoeft hier niets te veranderen)\np_hat &lt;- p_hat_1 - p_hat_2\nse &lt;- sqrt((p_hat_1*(1-p_hat_1)/n_1) + (p_hat_2*(1-p_hat_2)/n_2))\nz_star &lt;- qnorm((1 + confidence) / 2)  # Bereken z*-value \nlower &lt;- p_hat - z_star * se   # Ondergrens betrouwbaarheidsinterval\nupper &lt;- p_hat + z_star * se   # Bovengrens betrouwbaarheidsinterval\nc(lower, upper)\n\n[1] -0.02707706  0.28707706\n\n\nMerk op dat we de volgorde van het boek volgen (p1 is de behandelingsgroep en p2 is de controlegroep).\n\n\n12.2.1.2 Samengevatte gegevens\nWanneer je alleen samenvattende gegevens hebt, d.w.z. informatie over de steekproefgrootte en de steekproefproportie, raden we aan prop.test te gebruiken om een betrouwbaarheidsinterval te berekenen voor het verschil tussen twee proporties in twee steekproeven. De functie prop.test maakt deel uit van het package stats, dat een van de weinige packages is die R automatisch laadt bij het starten.\n\nprop.test(x = c(14, 11),\n          n = c(40, 50),\n          conf.level = 0.90,\n          correct=FALSE)\n\n\nprop.test\n\nDit is de functie die hypothesetoetsen voor porporties uitvoert en bijbehorende betrouwbaarheidsintervallen berekent.\n\nx = c(14, 11)\n\nHier geven we het aantal “successen” voor elke groep aan (in dit geval het aantal overlevenden in elke groep).\n\nn = c(40, 50)\n\nDe tweede opgegeven waarde moet het aantal casussen zijn voor elk van de twee steekproeven. In ons geval: het aantal deelnemers in beide groepen van de studie.\n\nconf.level = 0.90\n\nDit bepaalt het betrouwbaarheidsniveau. De standaardwaarde is 0.95, wat overeenkomt met een betrouwbaarheidsinterval van 95%. Wij stellen het interval in op 0.90.\n\ncorrect = FALSE\n\nDit zet de continuïteitscorrectie op FALSE. Dit zou dezelfde resultaten moeten opleveren als de handmatige berekeningen hierboven.\n\n\n\n\n\n    2-sample test for equality of proportions without continuity correction\n\ndata:  c(14, 11) out of c(40, 50)\nX-squared = 1.872, df = 1, p-value = 0.1712\nalternative hypothesis: two.sided\n90 percent confidence interval:\n -0.02707706  0.28707706\nsample estimates:\nprop 1 prop 2 \n  0.35   0.22 \n\n\n\n\n\n\n\n\nRapportage\n\n\n\n\nHet 90% betrouwbaarheidsinterval voor het verschil van de overlevingspercentages met of zonder behandeling loopt van -2,71% tot 28,7% (N = 90).\n\nof\n\nIn dit onderzoek (N = 90) was het verschil tussen de overlevingspercentages met of zonder behandeling gelijk aan 13%, 90% CI [-2,71%; 28,7%].\n\nNeem dus naast een omschrijving in je rapportage op:\n\nDe onder- en bovengrens van het interval.\nOm welk betrouwbaarheidsinterval het gaat: 90%, 95%, 99% (of nog anders)\nZeker bij peilingen is het gebruikelijk en aanbevelingswaardig om de steekproefomvang te vermelden.\n\n\n\n\n\n\n12.2.2 Hypothesetoets voor het verschil tussen twee proporties\nWe gebruiken de mammogram dataset uit het openintro package. De dataset bevat gegevens van een experiment waarbij 89.835 vrouwen werden gerandomiseerd om al dan niet een mammogram te ondergaan. De gemeten respons was of zij binnen 25 jaar aan borstkanker waren overleden.\n\nlibrary(tidyverse)\nlibrary(openintro)\nlibrary(flextable) \ndata(mammogram)\n\n# Factorniveaus van variabelen aanpassen om ervoor te zorgen dat de volgorde hetzelfde is als in de tabel in het tekstboek\nmammogram &lt;- mammogram |&gt;\n  mutate(breast_cancer_death = factor(breast_cancer_death, levels = c(\"yes\", \"no\"), ordered=TRUE)) |&gt;\n  mutate(treatment = factor(treatment, levels = c(\"mammogram\", \"control\"), ordered = TRUE))\n\ntable_example &lt;- proc_freq(x = mammogram, \n                           row = \"treatment\", \n                           col = \"breast_cancer_death\", \n                           include.row_percent = FALSE, \n                           include.column_percent = FALSE, \n                           include.table_percent = FALSE) \ntable_example\n\ntreatmentbreast_cancer_deathyesnoTotalmammogram50044,42544,925control50544,40544,910Total1,00588,83089,835\n\n\nDeze tabel is dezelfde als tabel 6.2 op blz. 219 van Openintro Statistics.\n\n12.2.2.1 Handmatige berekening met behulp van R\nOm de hypothese of er een verschil was in borstkankersterfte in de twee groepen met de hand te toetsen kunnen we schrijven:\n\n# Definieer invoer (pas deze aan voor je eigen berekeningen)\np_hat_1 &lt;- 500 / (500 + 44425)\np_hat_2 &lt;- 505 / (505 + 44405)\nn_1 &lt;- 500 + 44425 # Totaal aantal deelnemers in de eerste groep\nn_2 &lt;- 505 + 44405 # Totaal aantal deelnemers in de tweede groep\nnull_value &lt;- 0\n\n# Voer berekeningen uit (je hoeft hier niets te veranderen)\np_hat_pooled &lt;- (p_hat_1 * n_1 + p_hat_2 * n_2) / (n_1 + n_2)\npoint_est &lt;- p_hat_1 - p_hat_2\nse &lt;- sqrt((p_hat_pooled*(1-p_hat_pooled)/n_1)+(p_hat_pooled*(1-p_hat_pooled)/n_2))\nz &lt;- (point_est - null_value)/se\npnorm(z)\n\n[1] 0.434892\n\n\nDe oppervlakte onder de onderste staart is 0,4349 (klein verschil met het boek door afronding). De p-waarde, gevormd door de beide staarten samen, is \\(0,434892 * 2 = 0,869784\\). Omdat deze waarde \\(p &gt; 0,05\\), verwerpen we de nulhypothese niet.\nWe kunnen dit als volgt visualiseren:\n\nlibrary(visualize)\nvisualize.norm(stat = c(-z, z), section = \"tails\")\n\n\n\n\n\n\n\n\n\n\n12.2.2.2 Samengevatte gegevens\nAls alternatief kunnen we de R-functie prop.test() gebruiken om de significantie van het verschil tussen de twee groepen te testen. De functie prop.test maakt deel uit van het package stats, dat een van de weinige packages is die R automatisch laadt bij het opstarten.\nWe hebben prop.test al gebruikt voor een hypothesetoets bij één proportie, maar we kunnen deze functie ook gebruiken voor een toets met twee proporties:\n\nresult &lt;- prop.test(x = c(500, 505), \n                    n = c(44925, 44910),\n                    alternative = \"two.sided\",\n                    correct = FALSE)\nresult\n\n\nprop.test(\n\nDit is de functie die een test voor een proportie uitvoert.\n\nx = c(500, 505),\n\nHier geven wij het aantal gevallen aan dat zich in onze twee groepen bevindt. In dit voorbeeld: 500 patiënten die een mammografie kregen en stierven en 505 patiënten die geen mammografie kregen en stierven. Omdat dit twee waarden zijn, combineren we ze met c().\n\nn = c(44925, 44910),\n\nDe tweede opgegeven waarde moet het totale aantal mensen per studiegroep zijn. Omdat dit twee waarden zijn, combineren we ze met c().\n\nalternative = \"two.sided\"\n\nBepaal of we een tweezijdige of een eenzijdige test willen gebruiken. Opties zijn “two.sided” (standaard), “less” (als \\(H_1: \\mu &lt; p\\)) of “greater” (als \\(H_1: \\mu &gt; p\\)).\n\ncorrect = FALSE)\n\nHiermee geven we aan dat we het betrouwbaarheidsinterval niet willen berekenen met een ‘continuïteitscorrectie’. Standaard staat deze waarde op “TRUE”.\n\n\n\n\n\n    2-sample test for equality of proportions without continuity correction\n\ndata:  c(500, 505) out of c(44925, 44910)\nX-squared = 0.026874, df = 1, p-value = 0.8698\nalternative hypothesis: two.sided\n95 percent confidence interval:\n -0.001490590  0.001260488\nsample estimates:\n    prop 1     prop 2 \n0.01112966 0.01124471 \n\n\n\n\n12.2.2.3 Gegevens in een dataframe\nWe kunnen bovenstaande analyse ook uitvoeren op de gegevens uit het dataframe.\n\nprop.test(table(mammogram$treatment, mammogram$breast_cancer_death), \n          alternative = \"two.sided\",\n          correct = FALSE)\n\n\n    2-sample test for equality of proportions without continuity correction\n\ndata:  table(mammogram$treatment, mammogram$breast_cancer_death)\nX-squared = 0.026874, df = 1, p-value = 0.8698\nalternative hypothesis: two.sided\n95 percent confidence interval:\n -0.001490590  0.001260488\nsample estimates:\n    prop 1     prop 2 \n0.01112966 0.01124471 \n\n\n\nprop.test(table(mammogram$treatment, mammogram$breast_cancer_death),\n\nDit is de functie die een test voor een proportie uitvoert. We selecteren de onafhankelijke (mammogram$treatment) en afhankelijke variabele (mammogram$breast_cancer_death). Let op: de volgorde van de variabelen is van belang voor het betrouwbaarheidsinterval: vermeld dus eerst de onafhankelijke en dan de afhankelijke variabele.\n\nalternative = \"two.sided\"\n\nBepaal of we een tweezijdige of een eenzijdige test willen gebruiken. Opties zijn “two.sided” (standaard), “less” (als \\(H_1: \\mu &lt; p\\)) of “greater” (als \\(H_1: \\mu &gt; p\\)).\n\ncorrect = FALSE)\n\nHiermee geven we aan dat we het betrouwbaarheidsinterval niet willen berekenen met een ‘continuïteitscorrectie’. Standaard staat deze waarde op “TRUE”.\n\n\nDe uitkomst is exact hetzelfde als hierboven onder ‘samengevatte gegevens’.\n\n\n\n\n\n\nRapportage\n\n\n\n\nHet in ons onderzoek (N = 89835) gevonden percentage overledenen is 1,11% voor vrouwen die een mamografie kregen, hetgeen niet statistisch significant verschilt van het percentage overlenden van 1,12% onder vrouwen die geen mamografie kregen, \\(\\chi^2(1) = 0{,}027\\), p = 0,8698.\n\n\nNeem dus naast een inhoudelijke omschrijving in je rapportage op:\n\nDe twee percentages/proporties die worden vergeleken.\nDe z-waarde of Chikwadraatwaarde. Als je de laatste gebruikt ook het aantal vrijheidsgraden tussen haken, dat is voor dit soort berekeningen altijd 1. Aangezien R de chikwadraatwaarde rapporteert, is deze het meest logisch om op te nemen.\np = p-waarde. Maar: schrijf nooit \\(p = 0,000\\). Want de p-waarde is nooit precies nul, maar heel klein. Het is dan beter om te zeggen \\(p &lt; 0,001\\). Als de hypothesetoets handmatig uitvoert schrijf je p &lt; α-waarde, bijvoorbeeld \\(p &lt; 0,05\\).",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Inferentie voor proporties</span>"
    ]
  },
  {
    "objectID": "analysis_06_proportions.html#footnotes",
    "href": "analysis_06_proportions.html#footnotes",
    "title": "12  Inferentie voor proporties",
    "section": "",
    "text": "Deze gebruikt een iets ingewikkelder formule voor de berekening van het betrouwbaarheidsinterval (Wilson score-interval), waarin ook een “continuïteitscorrectie” is opgenomen (die rekening houdt met het feit dat we een continue normale verdeling gebruiken om een discreet fenomeen te benaderen, namelijk het aantal successen).↩︎\nAls je echt van pipes houdt, kun je ook gebruiken: example data |&gt; pull(party_choice) |&gt; table().↩︎\nAls je het betrouwbaarheidsinterval voor de tweede categorie wilt berekenen, kun je bijvoorbeeld relevel gebruiken om de categorieën van de eerste variabele opnieuw te rangschikken:\n\nprop.test(table(relevel(example_data$party_choice, ref = \"Other party\")),\n          conf.level = 0.95)\n\n\n    1-sample proportions test with continuity correction\n\ndata:  table(relevel(example_data$party_choice, ref = \"Other party\")), null probability 0.5\nX-squared = 290.52, df = 1, p-value &lt; 2.2e-16\nalternative hypothesis: true p is not equal to 0.5\n95 percent confidence interval:\n 0.7423954 0.7954986\nsample estimates:\n   p \n0.77 \n\n\n↩︎\nDit gebruikt een iets ingewikkelder formule voor de berekening van het betrouwbaarheidsinterval (Wilson score-interval), waarin ook een “continuïteitscorrectie” is opgenomen (die rekening houdt met het feit dat we een continue normale verdeling gebruiken om een discreet fenomeen te benaderen, d.w.z. het aantal successen).↩︎",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Inferentie voor proporties</span>"
    ]
  },
  {
    "objectID": "analysis_07_chi_squared.html",
    "href": "analysis_07_chi_squared.html",
    "title": "13  Chi-kwadraattoets en associatiematen",
    "section": "",
    "text": "13.1 Chi-kwadraattoets voor één variabele\nIn R voert de functie chisq.test chi-kwadraattoetsen uit.\nWe kunnen een chi-kwadraat toets gebruiken om te bepalen of een steekproef representatief is voor de algemene populatie. In het boek worden gegevens gepresenteerd van een willekeurige steekproef van 275 juryleden in een kleine provincie. Stel dat we zo’n tabel hebben met frequenties voor een categoriale variabele en het gegeven aandeel van elke groep in de populatie. In dat geval kunnen we de chi-kwadraattoets als volgt berekenen:\n# Openintro example from p. 229 - 235\nchisq &lt;- chisq.test(x = c(205, 26, 25, 19), \n                    p = c(0.72, 0.07, 0.12, 0.09))\nWe kunnen de resultaten zien door te kijken naar het object chisq.\nchisq\n\n\n    Chi-squared test for given probabilities\n\ndata:  c(205, 26, 25, 19)\nX-squared = 5.8896, df = 3, p-value = 0.1171\nDe uitvoer vermeldt de titel van de test, welke variabelen zijn gebruikt, de \\(\\chi^2\\)-teststatistiek, de vrijheidsgraden en de p-waarde.\nJe kunt de verwachte frequenties krijgen via:\nchisq$expected\n\n[1] 198.00  19.25  33.00  24.75",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Chi-kwadraattoets en associatiematen</span>"
    ]
  },
  {
    "objectID": "analysis_07_chi_squared.html#chi-kwadraattoets-voor-één-variabele",
    "href": "analysis_07_chi_squared.html#chi-kwadraattoets-voor-één-variabele",
    "title": "13  Chi-kwadraattoets en associatiematen",
    "section": "",
    "text": "chisq &lt;- chisq.test(\n\nDit voert een chi-kwadraat test uit en slaat de resultaten op in een object genaamd chisq. Je kunt een andere naam kiezen voor chisq.\n\nx = c(205, 26, 25, 19),\n\nDit zijn de geselecteerde juryleden (dezelfde gegevens als in het boek).\n\np = c(0.72, 0.07, 0.12, 0.09))\n\nDit zijn de proporties in de populatie.\n\n\n\n\n\n\n\n\nchisq$expected\n\nDit geeft een vector met verwachte frequenties (expected frequencies). Als je een andere naam hebt gekozen voor chisq, verander die dan ook hier.\n\n\n\n\n\n\n\n\nRapportage\n\n\n\nDe uitkomst van de chikwadraattoets voor één variabele kan men als volgt rapporteren:\n\nEr is geen significant verschil tussen de verdeling van etniciteit van juryleden in de kleine provincie en in het hele land, \\(\\chi^{2}(3) = 5{,}89,\\ \\ p = 0{,}117\\).\n\nNa een samenvatting in woorden volgt dus:\n\n\\(\\chi_{}^{\\mathbf{2}}\\) (aantal vrijheidsgraden) = waarde chikwadraat\nHet aantal vrijheidsgraden is gelijk aan (aantal groepen – 1) en kan ook in de output worden afgelezen (bij ‘df’).\np = p-waarde, maar: schrijf nooit \\(p = 0,000\\). Want de p-waarde is nooit precies nul, maar heel klein. Het is dan beter om te zeggen \\(p &lt; 0,001\\).",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Chi-kwadraattoets en associatiematen</span>"
    ]
  },
  {
    "objectID": "analysis_07_chi_squared.html#chi-kwadraattoets-voor-een-kruistabel",
    "href": "analysis_07_chi_squared.html#chi-kwadraattoets-voor-een-kruistabel",
    "title": "13  Chi-kwadraattoets en associatiematen",
    "section": "13.2 Chi-kwadraattoets voor een kruistabel",
    "text": "13.2 Chi-kwadraattoets voor een kruistabel\nWe demonstreren het gebruik van de chi-kwadraattoets voor een kruistabel met twee variabelen uit de Canadese verkiezingsstudie van 2019:\n\nlibrary(tidyverse)  # Tidyverse t.b.v. voorbereiden van de data\nlibrary(rio) # Dataset laden\nlibrary(flextable) # Package voor een kruistabel\ncanada &lt;- import(\"2019 Canadian Election Study.rds\")\n\nDe eerste variabele cps19_fed_gov_sat meet de algemene tevredenheid met de regering en de tweede variabele meet de algemene tevredenheid met de democratie (cps19_demsat).\nEerst behandelen we de antwoordoptie “Don’t know/ Prefer not to answer” als ontbrekende gegevens (zie paragraaf “Hercodering van ontbrekende gegevens” in week 4):\n\n# Ontbrekende waarden als NA hercoderen en factorniveaus die niet aanwezig zijn in de gegevens laten vallen (droplevels)\ncanada &lt;- canada |&gt;\n  mutate(cps19_fed_gov_sat = na_if(cps19_fed_gov_sat, \"Don't know/ Prefer not to answer\")) |&gt;\n  mutate(cps19_demsat = na_if(cps19_demsat, \"Don't know/ Prefer not to answer\")) |&gt;\n  mutate(cps19_fed_gov_sat = droplevels(cps19_fed_gov_sat)) |&gt;\n  mutate(cps19_demsat = droplevels(cps19_demsat))\n\n# Maak een kruistabel\ntable_example &lt;- proc_freq(x = canada, \n                           row = \"cps19_demsat\", \n                           col = \"cps19_fed_gov_sat\", \n                           include.row_percent = FALSE, \n                           include.table_percent = FALSE) \ntable_example\n\ncps19_demsatcps19_fed_gov_satVery satisfiedFairly satisfiedNot very satisfiedNot at all satisfiedMissingTotalVery satisfiedCount1,6042,407913804525,780Col. pct55.5%18.2%9.2%7.2%7.7%Fairly satisfiedCount1,1099,0775,9774,67330921,145Col. pct38.4%68.7%60.1%42.1%45.8%Not very satisfiedCount1151,3952,5703,8261218,027Col. pct4.0%10.6%25.8%34.5%18.0%Not at all satisfiedCount221372511,497281,935Col. pct0.8%1.0%2.5%13.5%4.2%MissingCount40199232300164935Col. pct1.4%1.5%2.3%2.7%24.3%TotalCount2,89013,2159,94311,10067437,822\n\n\nOm \\(\\chi^2\\) te berekenen, gebruiken we de functie chisq.test().\n\nchisq &lt;- chisq.test(canada$cps19_demsat, canada$cps19_fed_gov_sat)\nchisq\n\n\n    Pearson's Chi-squared test\n\ndata:  canada$cps19_demsat and canada$cps19_fed_gov_sat\nX-squared = 9053.6, df = 9, p-value &lt; 2.2e-16\n\n\n\nchisq &lt;- chisq.test(\n\nDit voert een chi-kwadraat test uit en slaat de resultaten op in een object genaamd chisq. Je kunt een andere naam kiezen voor chisq.\n\ncanada$cps19_demsat, canada$cps19_fed_gov_sat)\n\nWe geven de twee variabelen aan die we willen gebruiken. Merk op dat je hier de dollartekennotatie moet gebruiken, dus &lt;dataset&gt;$&lt;variabele&gt;.\n\n\nDe output vermeldt de titel van de test, welke variabelen zijn gebruikt, de \\(\\chi^2\\) teststatistiek, de vrijheidsgraden en de p-waarde.\nMerk op dat de \\(\\chi^2\\)-waarde kan worden afgerond als deze erg groot is (meer dan 5 cijfers). In ieder geval kun je de exacte waarde van \\(\\chi^2\\) krijgen door te schrijven:\n\nchisq$statistic \n\nX-squared \n 9053.595 \n\n\nJe kunt de verwachte frequenties krijgen via:\n\nchisq$expected\n\n                      canada$cps19_fed_gov_sat\ncanada$cps19_demsat    Very satisfied Fairly satisfied Not very satisfied\n  Very satisfied             448.7671        2049.5271           1529.115\n  Fairly satisfied          1632.4216        7455.2980           5562.262\n  Not very satisfied         619.4051        2828.8340           2110.541\n  Not at all satisfied       149.4062         682.3408            509.082\n                      canada$cps19_fed_gov_sat\ncanada$cps19_demsat    Not at all satisfied\n  Very satisfied                  1700.5910\n  Fairly satisfied                6186.0186\n  Not very satisfied              2347.2194\n  Not at all satisfied             566.1709\n\n\n\nchisq$expected\n\nDit geeft een tabel met verwachte frequenties. Als je een andere naam hebt gekozen voor chisq, verander die dan ook hier. Afhankelijk van je schermgrootte kan de tabel in verschillende delen worden opgedeeld (zie “Not at all satisfied”).\n\n\n\n\n\n\n\n\nRapportage\n\n\n\nDe uitkomst van de chikwadraattoets kan men als volgt rapporteren:\n\nEr is een significant verband tussen de algemene tevredenheid met de democratie en de tevredenheid met de regering in Canada, \\(\\chi^{2}(9) = 9053{,}6,\\ \\ p &lt; 0{,}001\\).\n\nNa een samenvatting in woorden volgt dus:\n\n\\(\\chi_{}^{\\mathbf{2}}\\) (aantal vrijheidsgraden) = waarde chikwadraat\nHet aantal vrijheidsgraden is gelijk aan (aantal rijen – 1)*(aantal kolommen – 1) en kan ook in de output worden afgelezen (bij ‘df’).\np = p-waarde, maar: schrijf nooit \\(p = 0,000\\). Want de p-waarde is nooit precies nul, maar heel klein. Het is dan beter om te zeggen \\(p &lt; 0,001\\).\nN.B. Een chikwadraattoets zegt niets over de richting van een verband; daarvoor moet je naar de kruistabel zelf kijken en daar een interpretatie van geven (zie hierboven).\n\n\n\n\n13.2.1 Als de verwachte frequenties klein zijn\nAls de kleinste verwachte frequenties lager zijn dan 5, kun je ofwel:\n\nenkele niveaus met een klein aantal waarnemingen combineren om het aantal waarnemingen in deze subgroepen te vergroten, of\nalternatieve tests gebruiken, zoals de Fisher’s exact test.\n\nStel je hebt de volgende (fictieve) data van 20 landen waarvoor we gegevens hebben verzameld over hun OESO-lidmaatschap en hun economische ontwikkeling:\n\n# Definieer dataset\ndata &lt;- data.frame(oecd = c(rep(\"no\", 9), rep(\"no\", 1), rep(\"yes\", 2), rep(\"yes\", 8)), \n                   econ = c(rep(\"low\", 9), rep(\"high\", 1), rep(\"low\", 2), rep(\"high\", 8)))\n# Print een kruistabel\ntable(data$econ, data$oecd)\n\n      \n       no yes\n  high  1   8\n  low   9   2\n\n\nDe verwachte frequenties in sommige cellen zullen &lt; 5 zijn.\n\n\n\n\n\n\nWaarschuwing\n\n\n\nSoms geeft R een waarschuwing “Chi-squared approximation may be incorrect”. Dit betekent dat de verwachte waarden zeer klein zijn en dat daarom de benaderingen van \\(p\\) mogelijk niet juist zijn.\n\n\nWe kunnen de waarde van \\(\\chi^2\\) berekenen met chisq.test() zoals we eerder deden:\n\nchisq &lt;- chisq.test(data$econ, data$oecd)\n\nWarning in chisq.test(data$econ, data$oecd): Chi-squared approximation may be\nincorrect\n\nchisq\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  data$econ and data$oecd\nX-squared = 7.2727, df = 1, p-value = 0.007001\n\n\nDe uitvoer geeft aan dat R automatisch ‘Pearson’s Chi-kwadraattest met Yates’ continuïteitscorrectie’ berekent (zie de titel van de test). De rest van de uitvoer is hetzelfde als bij de standaard Chikwadraattoets (welke variabelen zijn gebruikt, de teststatistiek van \\(\\chi^2\\), de vrijheidsgraden en de p-waarde). Het gebruik van de continuïteitscorrectie heeft niet onze voorkeur en lost het probleem van de lage verwachte aantallen niet op.\n\n\n13.2.2 Fisher’s exact test\nEen onafhankelijkheidstest voor een kleine steekproef met lage frequenties kunnen we uitvoeren met de Fisher’s exact test. Deze toets is vooral geschikt voor kleine tabellen (2x2) met lage frequenties.\nOm deze test in R uit te voeren, gebruik je de functie fisher.test() zoals je zou doen voor de Chi-kwadraattoets:\n\nfisher.t &lt;- fisher.test(data$econ, data$oecd)\nfisher.t\n\n\n    Fisher's Exact Test for Count Data\n\ndata:  data$econ and data$oecd\np-value = 0.005477\nalternative hypothesis: true odds ratio is not equal to 1\n95 percent confidence interval:\n 0.0005746857 0.4859089384\nsample estimates:\nodds ratio \n0.03659475 \n\n\n\nfisher.test &lt;- fisher.test(\n\nDit voert de Fisher’s exact test uit en slaat de resultaten op in een object genaamd fisher.t. Je kunt een andere naam kiezen voor fisher.t.\n\nfisher.test(data$econ, data$oecd)\n\nWe noemen de twee variabelen voor de functie fisher.test(), met dollartekennotatie zoals bij de chikwadraattoets.\n\n\nDe uitvoer vermeldt de titel van de test, welke variabelen zijn gebruikt en de p-waarde.\n\n\n\n\n\n\nRapportage\n\n\n\nDe uitkomst van de Fisher’s exact test kun je als volgt rapporteren:\n\nEr is een significant verband tussen het OESO-lidmaatschap van een land en de economische ontwikkeling ervan, \\(p = 0{,}005\\) (Fisher’s exact test).\n\n\n\n\n\n13.2.3 Gebruik van simulatie\nIndien je een tabel groter dan 2 x 2 hebt, maar toch lage verwachte frequenties in meerdere cellen, kan R de p-waarde van een Chikwadraattoets op basis van simulaties uitrekenen.\nWe illustreren die met behulp van de samenhang tussen gender en stemkeuze. Bij gender is er één categorie (Other) waarin weinig observaties zitten en ook bij stemkeuze zijn bepaalde partijen weinig populair. Dit leidt tot lage verwachte waarden in sommige cellen. We bereiden eerst de data voor:\n\n# Definieer missende data en verwijder factor levels die niet voorkomen in de data\ncanada &lt;- canada |&gt;\n  mutate(cps19_votechoice = na_if(cps19_votechoice, \"Don't know/ Prefer not to answer\")) |&gt;\n  mutate(cps19_votechoice = droplevels(cps19_votechoice)) \n\nDan kunnen we de chikwadraattoets draaien met de optie simulate.p.value = TRUE:\n\nchisq.test(canada$cps19_votechoice, canada$cps19_gender, simulate.p.value = TRUE)\n\n\n    Pearson's Chi-squared test with simulated p-value (based on 2000\n    replicates)\n\ndata:  canada$cps19_votechoice and canada$cps19_gender\nX-squared = 528.57, df = NA, p-value = 0.0004998",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Chi-kwadraattoets en associatiematen</span>"
    ]
  },
  {
    "objectID": "analysis_07_chi_squared.html#associatiematen",
    "href": "analysis_07_chi_squared.html#associatiematen",
    "title": "13  Chi-kwadraattoets en associatiematen",
    "section": "13.3 Associatiematen",
    "text": "13.3 Associatiematen\n\n13.3.1 Phi/Cramér’s V\nPhi en Cramér’s V zijn maatstaven voor de sterkte van de associatie tussen twee nominale of ordinale variabelen. Ze gaan van 0 tot 1. Het DescTools package bevat de functies Phi (met een hoofdletter P) en CramerV (met een hoofdletter C en een hoofdletter V). Als het nog niet geïnstalleerd is kun je dat doen via install.packages(\"DescTools\"); dit is niet nodig op universiteitscomputers.\n\nlibrary(DescTools)\n\nVervolgens kun je de associatiemaat berekenen. Merk op dat je de functie Phi alleen kunt gebruiken voor 2x2 kruistabellen. CramerV werkt voor 2x2 kruistabellen (die hetzelfde resultaat geven als Phi) en grotere kruistabellen (Cramér’s V).\n\nPhi(data$econ, data$oecd) #2x2 kruistabel\n\n[1] 0.7035265\n\nCramerV(data$econ, data$oecd) #2x2 kruistabel\n\n[1] 0.7035265\n\nCramerV(canada$cps19_demsat, canada$cps19_fed_gov_sat) # grotere kruistabel\n\n[1] 0.2880292\n\n\n\n\n\n\n\n\nRapportage\n\n\n\nDoorgaans wordt phi of Cramèrs V gerapporteerd na de bijbehorende chikwadraattoets of Fisher’s exact test:\n\nEr is een significant verband tussen het OESO-lidmaatschap van een land en de economische ontwikkeling ervan, \\(p = 0{,}005\\) (Fisher’s exact test). OESO-leden zijn vaker hoog ontwikkeld dan niet-OESO-leden. Dit is een sterk verband, \\(\\varphi = 0{,}70\\).\nEr is een significant verband tussen de algemene tevredenheid met de democratie en de tevredenheid met de regering in Canada, \\(\\chi^{2}(9) = 9053{,}6,\\ \\ p &lt; 0{,}001\\). Kiezers die meer tevreden zijn met de regering, zijn doorgaans ook meer tevreden over de democratie in het algemeen. Dit is een zwak verband, \\(\\text{Cramérs V} = 0{,}29\\).\n\n\n\n\n\n13.3.2 Goodman en Kruskals Lambda\nDe lambda van Goodman en Kruskal (\\(lambda\\)) kan worden berekend met een functie uit het DescTools package.\n\nlibrary(DescTools)\n\nWe demonstreren het gebruik van Lambda met twee variabelen uit de Canadese verkiezingsstudie van 2019. Als onafhankelijke variabele gebruiken we een variabele betreffende de gender van de respondenten (cps19_gender) en als afhankelijke variabele gebruiken we de partij waarop de respondent van plan is te stemmen (cps19_votechoice). Wij behandelen de antwoordoptie “Don’t know/ Prefer not to answer” als ontbrekende gegevens:\n\ncanada &lt;- canada |&gt;\n  mutate(cps19_votechoice = na_if(cps19_votechoice, \"Don't know/ Prefer not to answer\")) |&gt;\n  mutate(cps19_votechoice = droplevels(cps19_votechoice)) \n\n\n# Maak een kruistabel\ntable_example &lt;- proc_freq(x = canada, \n                           row = \"cps19_votechoice\", \n                           col = \"cps19_gender\", \n                           include.row_percent = FALSE, \n                           include.table_percent = FALSE) \ntable_example\n\ncps19_votechoicecps19_genderA manA womanOther (e.g. Trans, non-binary, two-spirit, gender-queer)TotalLiberal PartyCount3,7765,122518,949Col. pct24.3%23.3%17.5%Conservative PartyCount4,2824,388438,713Col. pct27.5%20.0%14.8%ndpCount1,3532,896794,328Col. pct8.7%13.2%27.1%Bloc QuébécoisCount71068861,404Col. pct4.6%3.1%2.1%Green PartyCount9121,522222,456Col. pct5.9%6.9%7.6%People's PartyCount3152864605Col. pct2.0%1.3%1.4%Another party (please specify)Count100983201Col. pct0.6%0.4%1.0%MissingCount4,1036,9808311,166Col. pct26.4%31.8%28.5%TotalCount15,55121,98029137,822\n\n\nOm Lambda te berekenen, schrijf je:\n\nLambda(x = canada$cps19_votechoice, \n       y = canada$cps19_gender,\n       direction = \"row\")\n\n[1] 0.03015756\n\n\n\nLambda\n\nHiermee wordt de Lambda van Goodman-Kruskal berekend. Gebruik een hoofdletter “L” voor de functie.\n\nx = canada$cps19_votechoice\n\nNeem hier de variabele op die in de rijen staat (de afhankelijke variabele).\n\ny = canada$cps19_gender\n\nNeem hier de variabele op die in de kolommen staat (de onafhankelijke variabele).\n\ndirection = \"row\"\n\ndirection kan drie waarden aannemen: \"symmetric\" (standaard), \"row\" of \"column\". Als onze afhankelijke variabele zich in de rijen bevindt, raden wij aan dit in te stellen op row, waardoor de verbetering in het voorspellen van de rijvariabele wordt berekend als we informatie hebben over de kolomvariabele.\n\n\n\n\n\n\n\n\nRapportage\n\n\n\nDoorgaans wordt Lambda gerapporteerd na de bijbehorende chikwadraattoets:\n\nEr is een significant verband tussen de gender van een respondent en diens stemkeuze, \\(\\chi^{2}(14) = 768{,}16,\\ \\ p &lt; 0{,}001\\). Dit is een (zeer) zwak verband, \\(\\lambda = 0{,}03\\).\n\n\n\n\n\n13.3.3 Goodman en Kruskals Gamma\nGoodman en Kruskals Gamma (\\(\\gamma\\)) kan worden berekend met een functie uit het DescTools package.\nGamma is alleen geschikt wanneer beide variabelen ordinaal zijn. Wij gebruiken de twee variabelen van hierboven (de algemene tevredenheid met de regering en de algemene tevredenheid met de democratie). Het is nuttig om de data te inspecteren met behulp van een eenvoudige kruistabel - zo kun je zien of de categorieën in de juiste volgorde staan:\n\ntable(canada$cps19_demsat, canada$cps19_fed_gov_sat)\n\n                      \n                       Very satisfied Fairly satisfied Not very satisfied\n  Very satisfied                 1604             2407                913\n  Fairly satisfied               1109             9077               5977\n  Not very satisfied              115             1395               2570\n  Not at all satisfied             22              137                251\n                      \n                       Not at all satisfied\n  Very satisfied                        804\n  Fairly satisfied                     4673\n  Not very satisfied                   3826\n  Not at all satisfied                 1497\n\n\n\n\n\n\n\n\nOpmerking\n\n\n\nDe volgorde van de waarden is zeer belangrijk voor de berekening van Gamma. Controleer daarom altijd of de categorieën in de variabelen in de juiste volgorde staan (bijvoorbeeld door een kruistabel te maken)\n\n\nOm Gamma te berekenen, gebruik je de volgende code:\n\nGoodmanKruskalGamma(canada$cps19_demsat, canada$cps19_fed_gov_sat)\n\n[1] 0.5528955\n\n\n\nGoodmanKruskalGamma(\n\nDit berekent de Gamma van Goodman en Kruskal. Zorg ervoor dat je de hele functienaam correct schrijft (inclusief hoofdlettergebruik).\n\ncanada$cps19_demsat, canada$cps19_fed_gov_sat)\n\nDe twee variabelen die we gebruiken voor onze berekening. Het maakt niet uit welke variabele je het eerst vermeld.\n\n\n\n\n\n\n\n\nRapportage\n\n\n\nDoorgaans wordt Gamma gerapporteerd na de bijbehorende chikwadraattoets:\n\nEr is een significant verband tussen de algemene tevredenheid met de democratie en de tevredenheid met de regering in Canada, \\(\\chi^{2}(9) = 9053{,}6,\\ \\ p &lt; 0{,}001\\). Kiezers die meer tevreden zijn met de regering, zijn doorgaans ook meer tevreden over de democratie in het algemeen. Dit is een sterk verband, \\(\\gamma = 0{,}55\\)",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Chi-kwadraattoets en associatiematen</span>"
    ]
  },
  {
    "objectID": "analysis_08_t-test.html",
    "href": "analysis_08_t-test.html",
    "title": "14  T-toets voor het gemiddelde",
    "section": "",
    "text": "14.1 Standaardfout van het gemiddelde\nDe standaardfout van het gemiddelde kan worden geschat als \\(\\frac{s}{\\sqrt{n}}\\). In R kunnen we de functie MeanSE uit package DescTools gebruiken:\nlibrary(DescTools)\nexample_vector &lt;- rnorm(20)  # Voorbeeldgegevens van 20 normaal verdeelde willekeurige getallen.\n\nMeanSE(x = example_vector, \n       na.rm = TRUE)\n\n[1] 0.248909\nJe kunt ook MeanSE gebruiken voor een variabele in een dataframe:\n# $ gebruiken om een variabele uit een dataframe te selecteren\nMeanSE(canada$cps19_age, na.rm = TRUE)  \n\n[1] 0.08541655\n\n# Met behulp van de functie summarise\ncanada |&gt;\n  summarise(SE_age = MeanSE(cps19_age, na.rm = TRUE))\n\n      SE_age\n1 0.08541655\nDe functie describe in package psych geeft de standaardfout voor de gemiddelde voor alle variabelen in een dataframe. Dit is vooral nuttig wanneer we snel de standaardfout voor meerdere variabelen willen berekenen. In dit voorbeeld selecteren we drie interval-ratio variabelen uit de Canadian Election Study van 2019 (die we hierboven hebben geïmporteerd):\nlibrary(psych)\n\n# Selecteer drie variabelen van \"canada\" en wijs toe aan dataset \"canada_selectie\"\ncanada_selection &lt;- canada |&gt; \n  select(cps19_age, cps19_lr_parties_1, cps19_lr_parties_2)\n\n# Gebruik describe om samenvattende statistieken te berekenen voor \"canada_selectie\"\ndescribe(canada_selection)\n\n                   vars     n  mean    sd median trimmed   mad min max range\ncps19_age             1 37822 48.69 16.61     49   48.66 20.76  18  99    81\ncps19_lr_parties_1    2 27743  4.27  2.79      4    4.19  2.97   0  10    10\ncps19_lr_parties_2    3 28210  6.90  2.79      8    7.28  2.97   0  10    10\n                    skew kurtosis   se\ncps19_age           0.04    -0.91 0.09\ncps19_lr_parties_1  0.19    -0.77 0.02\ncps19_lr_parties_2 -0.97     0.14 0.02\nDe kolom se geeft de standaardfout van het gemiddelde weer (standaard afgerond op twee decimalen).",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>T-toets voor het gemiddelde</span>"
    ]
  },
  {
    "objectID": "analysis_08_t-test.html#sec-analysis-t-test-standard-error",
    "href": "analysis_08_t-test.html#sec-analysis-t-test-standard-error",
    "title": "14  T-toets voor het gemiddelde",
    "section": "",
    "text": "MeanSE(…)\n\nDeze functie berekent de standaardfout van het gemiddelde voor een vector van getallen.\n\nx = example_vector\n\nWe willen de SE van het gemiddelde berekenen voor de waarden in example_vector. Voor je eigen gegevens verander je dit in de juiste vectornaam.\n\nna.rm = TRUE\n\nDeze optie zorgt ervoor dat ontbrekende waarden worden genegeerd.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>T-toets voor het gemiddelde</span>"
    ]
  },
  {
    "objectID": "analysis_08_t-test.html#t-toetsen",
    "href": "analysis_08_t-test.html#t-toetsen",
    "title": "14  T-toets voor het gemiddelde",
    "section": "14.2 T-toetsen",
    "text": "14.2 T-toetsen\n\n14.2.1 Enkelvoudige T-toets\nOm een enkelvoudige T-toets (one sample t-test) te berekenen gebruiken we de functie t.test:\nIn het onderstaande voorbeeld meten we of de leeftijd van de respondenten afwijkt van een hypothetisch gemiddelde van 48,5:1\n\nt.test(formula = cps19_age ~ 1,\n       data = canada,\n       alternative = \"two.sided\",\n       mu = 48.5,\n       conf.level = 0.95)\n\n\n    One Sample t-test\n\ndata:  cps19_age\nt = 2.2395, df = 37821, p-value = 0.02513\nalternative hypothesis: true mean is not equal to 48.5\n95 percent confidence interval:\n 48.52387 48.85871\nsample estimates:\nmean of x \n 48.69129 \n\n\n\nformula = cps19_age ~ 1\n\nAangezien we slechts één variabele hebben in een t-test met één steekproef, specificeren we de formule in de vorm &lt;variabelenaam&gt; ~ 1.\n\ndata = canada\n\nWe specificeren het dataframe dat we willen gebruiken.\n\nalternative = \"two.sided\"\n\nBepaalt of we een tweezijdige of een eenzijdige test willen gebruiken. Opties zijn “two.sided” (standaard), “less” (als \\(H_1: \\mu &lt; p\\)) of “greater” (als \\(H_1: \\mu &gt; p\\)).\n\nmu = 48.5\n\nDe mu parameter moet worden ingesteld op de waarde van het gemiddelde onder de nulhypothese.\n\nconf.level = 0.95\n\nDit bepaalt het betrouwbaarheidsniveau van het gerapporteerde betrouwbaarheidsinterval. De standaardwaarde is 0.95 (een 95%-betrouwbaarheidsinterval).\n\n\nVoor een volledige en juiste rapportage van de t-toets, is het ook nodig om de standaardfout uit te rekenen (zie paragraaf 14.1):\n\nlibrary(DescTools)\nMeanSE(canada$cps19_age)\n\n[1] 0.08541655\n\n\n\n\n\n\n\n\nRapportage\n\n\n\n\nDe gemiddelde leeftijd van Canadese kiezers was 48,7 (SE = 0,08). Dit wijkt significant af van 48,5, de gegeven testwaarde, \\(t(37821) = -2{,}24\\), \\(p = 0,025\\).\n\nGeef dus naast de conclusie in woorden in elk geval de volgende informatie:\n\nGemiddelde (in de tekst of M = …) en standaardfout (SE = …).\nt(aantal vrijheidsgraden) = t-observed\np = p-waarde. Maar: schrijf nooit \\(p = 0,000\\). Want de p-waarde is nooit precies nul, maar heel klein. Het is dan beter om te zeggen \\(p &lt; 0,001\\). Als de t-toets handmatig uitvoert schrijf je p &lt; α-waarde, bijvoorbeeld \\(p &lt; 0,05\\).\n\n\n\n\n\n14.2.2 T-toets voor gepaarde steekproeven\nIn een t-toets met gepaarde steekproeven (paired samples t-test) vergelijken we de gemiddelde waarde van twee interval-ratio variabelen.\nIn het onderstaande voorbeeld testen we de nulhypothese dat het gemiddelde verschil van de links-rechts plaatsing van de Liberale partij (variabele cps_lr_parties_1) en de Conservatieve partij (variabele cps19_lr_parties_2) gelijk is aan 0 in de populatie.\nWe kunnen de test als volgt specificeren:2\n\nt.test(formula = Pair(cps19_lr_parties_1, cps19_lr_parties_2) ~ 1,\n       data = canada,\n       alternative = \"two.sided\",\n       mu = 0,\n       conf.level = 0.95)\n\n\n    Paired t-test\n\ndata:  Pair(cps19_lr_parties_1, cps19_lr_parties_2)\nt = -95.406, df = 26718, p-value &lt; 2.2e-16\nalternative hypothesis: true mean difference is not equal to 0\n95 percent confidence interval:\n -2.691519 -2.583155\nsample estimates:\nmean difference \n      -2.637337 \n\n\n\nformula = Pair(cps19_lr_parties_1, cps19_lr_parties_2) ~ 1\n\nWe hebben twee gepaarde interval-ratio variabelen en gebruiken daarom een formule van de vorm Pair(&lt;variabelenaam 1&gt;, &lt;variabelenaam 2&gt;) ~ 1.\n\ndata = canada\n\nWe specificeren het dataframe dat we willen gebruiken.\n\nalternative = \"two.sided\"\n\nBepaalt of we een tweezijdige of een eenzijdige test willen gebruiken. Opties zijn “two.sided” (standaard), “less” (als \\(H_1: \\mu &lt; p\\)) of “greater” (als \\(H_1: \\mu &gt; p\\)).\n\nmu = 0\n\nDe mu parameter moet worden ingesteld op de waarde van het gemiddelde onder de nulhypothese. In het geval van een gepaarde steekproef t-test veronderstellen we meestal dat het verschil tussen de twee gemiddelden in de populatie 0 is, dus mu = 0.\n\nconf.level = 0.95\n\nDit bepaalt het betrouwbaarheidsniveau van het gerapporteerde betrouwbaarheidsinterval. De standaardwaarde is 0.95 (een 95%-betrouwbaarheidsinterval).\n\n\nVoor een volledige en juiste rapportage van de t-toets, is het ook nodig om de standaardfout uit te rekenen (zie paragraaf 14.1). In dit geval berekenen we de standaardfout voor beide variabelen, maar alleen voor de casussen (rijen in de dataset) waarvoor we geen missende waarden hebben op deze variabelen:\n\nlibrary(psych, warn.conflicts=FALSE)\n# Create overview of descriptive statistics, dropping missing values\ndescribe(canada |&gt; select(cps19_lr_parties_1, cps19_lr_parties_2) |&gt; drop_na())\n\n                   vars     n mean   sd median trimmed  mad min max range  skew\ncps19_lr_parties_1    1 26719 4.25 2.77      4    4.16 2.97   0  10    10  0.20\ncps19_lr_parties_2    2 26719 6.88 2.80      8    7.26 2.97   0  10    10 -0.97\n                   kurtosis   se\ncps19_lr_parties_1    -0.75 0.02\ncps19_lr_parties_2     0.12 0.02\n\n\n\n\n\n\n\n\nRapportage\n\n\n\n\nCanadese kiezers plaatsen de Liberale partij (M = 4,25; SE = 0,02) gemiddeld genomen linkser dan de Conservatieve partij (M = 6,88; SE = 0,02). Dit verschil, -2,64, was statistisch significant, \\(t(26718) = -95{,}41\\), \\(p &lt; 0{,}001\\).\n\nGeef dus naast de conclusie in woorden in elk geval de volgende informatie:\n\nGemiddelde (in de tekst of M = …) en standaardfout (SE = …) voor elke variabele.\nHet gemiddelde verschil (in bovenstaand voorbeeld -2,64).\nt(aantal vrijheidsgraden) = t-observed\np = p-waarde. Maar: schrijf nooit \\(p = 0{,}000\\). Want de p-waarde is nooit precies nul, maar heel klein. Het is dan beter om te zeggen \\(p &lt; 0{,}001\\). Als je een handmatige toets uitvoert schrijf je p &lt; α-waarde, bijvoorbeeld \\(p &lt; 0{,}05\\).\n\n\n\n\n\n14.2.3 T-toets voor onafhankelijke steekproeven\nDe T-toets voor onafhankelijke steekproeven (independent samples t-test) wordt gebruikt om te vergelijken of de gemiddelden van twee groepen statistisch significant verschillend zijn. We hebben dus een numerieke variabele, waarvoor we een gemiddelde kunnen berekenen, en een groeperingsvariabele, een categoriale variabele die het groepslidmaatschap bepaalt. In ons voorbeeld testen we of er een statistisch significant verschil is in de gemiddelde plaatsing van de Liberale partij door degenen die in Canada geboren zijn en degenen die dat niet zijn.\nEerst inspecteren we de categoriale variabele:\n\ntable(canada$cps19_bornin_canada)\n\n\n                          Yes                            No \n                        31556                          6046 \nDon't know/ Prefer not to say \n                          220 \n\n\nHet blijkt dat deze variabele drie categorieën heeft. De categorie Weet niet (Don’t know/Prefer not to say) willen we negeren, dus die behandelen we als missend:\n\ncanada &lt;- canada |&gt;\n  mutate(cps19_bornin_canada = na_if(cps19_bornin_canada, \"Don't know/ Prefer not to say\")) \n\nNu kunnen we de t-test uitvoeren:\n\nt.test(formula = cps19_lr_parties_1 ~ cps19_bornin_canada,\n       data = canada,\n       alternative = \"two.sided\", \n       mu = 0,\n       conf.level = .95)\n\n\nformula = cps19_lr_parties_1 ~ cps19_bornin_canada\n\nWij hebben een interval-ratio variabele en een categoriale variabele (factor) die aangeeft tot welke groep een waarneming behoort, dus gebruiken wij een formule van de vorm &lt;interval-ratio variabele&gt; ~ &lt;categoriale variabele&gt;.\n\ndata = canada\n\nWe specificeren het dataframe dat we willen gebruiken.\n\nalternative = \"two.sided\"\n\nBepaalt of we een tweezijdige of een eenzijdige test willen gebruiken. Opties zijn “two.sided” (standaard), “less” (als \\(H_1: \\mu &lt; p\\)) of “greater” (als \\(H_1: \\mu &gt; p\\)).\n\nmu = 0\n\nDe mu parameter moet worden ingesteld op de waarde van het gemiddelde onder de nulhypothese. In het geval van een T-toets voor onafhankelijke steekproeven wordt gewoonlijk verondersteld dat het verschil tussen de twee groepsgemiddelden 0 is in de populatie, dus mu = 0.\n\nconf.level = 0.95\n\nDit bepaalt het betrouwbaarheidsniveau van het gerapporteerde betrouwbaarheidsinterval. De standaardwaarde is 0.95 (een 95%-betrouwbaarheidsinterval).\n\n\n\n\n\n    Welch Two Sample t-test\n\ndata:  cps19_lr_parties_1 by cps19_bornin_canada\nt = -8.9025, df = 6809.2, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group Yes and group No is not equal to 0\n95 percent confidence interval:\n -0.4886007 -0.3122543\nsample estimates:\nmean in group Yes  mean in group No \n         4.196678          4.597106 \n\n\nR toont het resultaat van de Welch Two Sample t-test, een versie van de T-toets voor onafhankelijke steekproeven die van toepassing is wanneer geen gelijke varianties worden aangenomen.\nVoor een volledige en juiste rapportage van de t-toets, is het ook nodig om de standaardfout uit te rekenen (zie paragraaf 14.1). In dit geval berekenen we de standaardfout van het gemiddelde voor elke groep in de data (dus voor degenen die wel en niet in Canada zijn geboren):\n\ncanada |&gt;\n  group_by(cps19_bornin_canada) |&gt;\n  summarise(mean = mean(cps19_lr_parties_1, na.rm=TRUE),\n            SE = MeanSE(cps19_lr_parties_1, na.rm=TRUE))\n\n# A tibble: 3 × 3\n  cps19_bornin_canada  mean     SE\n  &lt;fct&gt;               &lt;dbl&gt;  &lt;dbl&gt;\n1 Yes                  4.20 0.0184\n2 No                   4.60 0.0411\n3 &lt;NA&gt;                 5.14 0.216 \n\n\n\n\n\n\n\n\nRapportage\n\n\n\n\nMensen die zijn geboren in Canada plaatsen de Liberale partij gemiddeld genomen linkser (M = 4,20; SE = 0,02) dan mensen die niet zijn geboren in Canada (M = 4,60; SE = 0,04). Dit verschil, -0,40, was statistisch significant, \\(t(6809{,}2) = -8{,}9025\\), \\(p &lt; 0{,}001\\).\n\nGeef dus naast de conclusie in woorden in elk geval de volgende informatie:\n\nGemiddelde (in de tekst of M = …) en standaardfout (SE = …) voor elke groep.\nHet gemiddelde verschil (in bovenstaand voorbeeld -0,40).\nt(aantal vrijheidsgraden) = t-observed\np = p-waarde. Maar: schrijf nooit \\(p = 0,000\\). Want de p-waarde is nooit precies nul, maar heel klein. Het is dan beter om te zeggen \\(p &lt; 0,001\\). Als je een handmatige toets uitvoert schrijf je p &lt; α-waarde, bijvoorbeeld \\(p &lt; 0,05\\).",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>T-toets voor het gemiddelde</span>"
    ]
  },
  {
    "objectID": "analysis_08_t-test.html#effectgroottes-voor-t-toetsen",
    "href": "analysis_08_t-test.html#effectgroottes-voor-t-toetsen",
    "title": "14  T-toets voor het gemiddelde",
    "section": "14.3 Effectgroottes voor t-toetsen",
    "text": "14.3 Effectgroottes voor t-toetsen\nWe kunnen Cohen’s \\(d\\) of Hedges’ \\(g^*_s\\) berekenen als effectgrootte voor een t-toets. We gebruiken de functies cohens_d en hedges_g uit package effectsize.\n\n14.3.1 Cohen’s \\(d\\) voor één steekproef\nWe gebruiken de functie cohens_d uit package effectsize. De parameters zijn vrijwel gelijk aan die van de functie t.test:\n\nlibrary(effectsize)\ncohens_d(cps19_age ~ 1, \n         data = canada, \n         mu = 48.5)\n\nCohen's d |       95% CI\n------------------------\n0.01      | [0.00, 0.02]\n\n- Deviation from a difference of 48.5.\n\n\n\ncps19_age ~ 1\n\nAangezien we slechts één variabele hebben, specificeren we de formule in de vorm &lt;variabelenaam&gt; ~ 1.\n\ndata = canada\n\nWe specificeren het dataframe dat we willen gebruiken.\n\nmu = 48.5\n\nDe mu parameter moet worden ingesteld op de waarde van het gemiddelde onder de nulhypothese.\n\n\n\n\n\n\n\n\nRapportage\n\n\n\nIndien een associatiemaat wordt berekend, kan die achteraan de rapportagen worden toegevoegd:\n\nDe gemiddelde leeftijd van Canadese kiezers was 48,7 (SE = 0,08). Dit wijkt significant af van 48,5, de gegeven testwaarde, \\(t(37821) = -2{,}24\\), \\(p = 0,025\\). Dit representeert een zeer zwak effect, Cohen’s d = 0,01.\n\nDe volgende vuistregels worden doorgaans gebruikt voor de kwalificatie van effectgroottes van Cohen’s d en Hedges g:\n\nTen minste 0,2: zwak\nTen minste 0,5: matig\nTen minste 0,8: sterk\n\n\n\n\n\n14.3.2 Cohen’s d voor gepaarde steekproeven\nWe gebruiken de functie cohens_d uit package effectsize. De parameters zijn vrijwel gelijk aan die van de functie t.test:\n\nlibrary(effectsize)\ncohens_d(Pair(cps19_lr_parties_1, cps19_lr_parties_2) ~ 1, \n         data = canada, \n         mu = 0)\n\nCohen's d |         95% CI\n--------------------------\n-0.58     | [-0.60, -0.57]\n\n\n\nPair(cps19_lr_parties_1, cps19_lr_parties_2) ~ 1\n\nWe hebben twee gepaarde interval-ratio variabelen en gebruiken daarom een formule van de vorm Pair(&lt;variabelenaam 1&gt;, &lt;variabelenaam 2&gt;) ~ 1.\n\ndata = canada\n\nWe specificeren het dataframe dat we willen gebruiken.\n\nmu = 0\n\nDe mu parameter moet worden ingesteld op de waarde van het gemiddelde onder de nulhypothese. In het geval van een gepaarde steekproef veronderstellen we meestal dat het verschil tussen de twee gemiddelden in de populatie 0 is, dus mu = 0.\n\n\n\n\n\n\n\n\nRapportage\n\n\n\nIndien een associatiemaat wordt berekend, kan die achteraan de rapportagen worden toegevoegd:\n\nCanadese kiezers plaatsen de Liberale partij (M = 4,25; SE = 0,02) gemiddeld genomen linkser dan de Conservatieve partij (M = 6,88; SE = 0,02). Dit verschil, -2,64, was statistisch significant, \\(t(26718) = -95{,}41\\), \\(p &lt; 0{,}001\\). Dit representeert een matig effect, Cohen’s d = -0,58.\n\nDe volgende vuistregels worden doorgaans gebruikt voor de kwalificatie van effectgroottes van Cohen’s d en Hedges g:\n\nTen minste 0,2: zwak\nTen minste 0,5: matig\nTen minste 0,8: sterk\n\n\n\n\n\n14.3.3 Hedges’ \\(g^*_s\\) voor onafhankelijke steekproeven\nVoor twee onafhankelijke steekproeven wordt aanbevolen Hedges \\(g^*_s\\) te berekenen als maat voor de effectgrootte (Delacre et al. 2021). De interpretatie ervan is vergelijkbaar met Cohen’s \\(d\\), maar gecorrigeerd voor bias en aangepast aan een situatie waarin geen gelijke varianties kunnen worden aangenomen. De waarden lijken sterk op Cohen’s \\(d\\) voor grotere steekproeven.\nMerk op dat wij voor ons voorbeeld de gewijzigde versie van de variabele cps19_bornin_canada gebruiken (zie T-toets voor onafhankelijke steekproeven):\n\nlibrary(effectsize)\nhedges_g(cps19_lr_parties_1 ~ cps19_bornin_canada, \n         data = canada, \n         mu = 0,\n         pooled_sd = FALSE)\n\nHedges' g |         95% CI\n--------------------------\n-0.14     | [-0.17, -0.11]\n\n- Estimated using un-pooled SD.\n\n\n\ncps19_lr_parties_1 ~ cps19_bornin_canada\n\nWij hebben een interval-ratio variabele en een categoriale variabele (factor) die aangeeft tot welke groep een waarneming behoort, dus gebruiken wij een formule van de vorm &lt;interval-ratio variabele&gt; ~ &lt;categoriale variabele&gt;.\n\ndata = canada\n\nWe specificeren het dataframe dat we willen gebruiken.\n\nmu = 0\n\nDe mu parameter moet worden ingesteld op de waarde van het gemiddelde onder de nulhypothese. In het geval van een onafhankelijke steekproef wordt gewoonlijk verondersteld dat het verschil tussen de twee groepsgemiddelden 0 is in de populatie, dus mu = 0.\n\npooled_sd = FALSE\n\nDit geeft aan dat we de gepoolde standaardafwijking niet gebruiken, wat wordt aanbevolen bij gebruik van Welch’ t-test (waarbij niet wordt aangenomen dat varianties gelijk zijn), die t.test standaard doet voor de onafhankelijke steekproef t-test.\n\n\n\n\n\n\n\n\nRapportage\n\n\n\nIndien een associatiemaat wordt berekend, kan die achteraan de rapportagen worden toegevoegd:\n\nMensen die zijn geboren in Canada plaatsen de Liberale partij gemiddeld genomen linkser (M = 4,20; SE = 0,02) dan mensen die niet zijn geboren in Canada (M = 4,60; SE = 0,04). Dit verschil, -0,40, was statistisch significant, \\(t(6809{,}2) = -8{,}9025\\), \\(p &lt; 0{,}001\\). Dit representeert een zeer zwak effect, Hedges’ \\(g^*_s\\) = -0,14.\n\nDe volgende vuistregels worden doorgaans gebruikt voor de kwalificatie van effectgroottes van Cohen’s d en Hedges g:\n\nTen minste 0,2: zwak\nTen minste 0,5: matig\nTen minste 0,8: sterk",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>T-toets voor het gemiddelde</span>"
    ]
  },
  {
    "objectID": "analysis_08_t-test.html#footnotes",
    "href": "analysis_08_t-test.html#footnotes",
    "title": "14  T-toets voor het gemiddelde",
    "section": "",
    "text": "In dit overzicht gebruiken we de zogenaamde ‘formule-interface’ van t.test. U kunt ook de zogenaamde traditionele interface gebruiken. Voor het voorbeeld van de one-sample t-test is de equivalente code:\n\nt.test(x = canada$cps19_age,\n       alternative = \"two.sided\",\n       mu = 48.5,\n       conf.level = 0.95)\n\n\n    One Sample t-test\n\ndata:  canada$cps19_age\nt = 2.2395, df = 37821, p-value = 0.02513\nalternative hypothesis: true mean is not equal to 48.5\n95 percent confidence interval:\n 48.52387 48.85871\nsample estimates:\nmean of x \n 48.69129 \n\n\n↩︎\nIn dit overzicht gebruiken we de zogenaamde ‘formule-interface’ van t.test. Je kunt ook de zogenaamde traditionele interface gebruiken. Voor het voorbeeld van de t-toets met gepaarde steekproeven is de equivalente code:\n\nt.test(x = canada$cps19_lr_parties_1, \n       y = canada$cps19_lr_parties_2,\n       data = canada,\n       alternative = \"two.sided\",\n       mu = 0,\n       paired = TRUE,\n       conf.level = 0.95)\n\n\n    Paired t-test\n\ndata:  canada$cps19_lr_parties_1 and canada$cps19_lr_parties_2\nt = -95.406, df = 26718, p-value &lt; 2.2e-16\nalternative hypothesis: true mean difference is not equal to 0\n95 percent confidence interval:\n -2.691519 -2.583155\nsample estimates:\nmean difference \n      -2.637337 \n\n\nVergeet in dit geval niet paired = TRUE op te nemen.↩︎",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>T-toets voor het gemiddelde</span>"
    ]
  },
  {
    "objectID": "analysis_09_power_analysis.html",
    "href": "analysis_09_power_analysis.html",
    "title": "15  Poweranalyse",
    "section": "",
    "text": "De huidige cursus geeft alleen een basisinleiding tot poweranalyse (de analyse van het onderscheidend vermogen van een statistische toets). Package pwr biedt poweranalyse voor onder andere t-toetsen, proportietoetsen en chikwadraattoetsen. Het gebruik van package pwr is geen examenstof.\nBereken de power voor een t-toets met onafhankelijke steekproeven met een gegeven steekproefgrootte (n = 30) en effectgrootte (Cohen’s d = 0,5):\n\nlibrary(pwr)\npwr.t.test(n = 30, d = 0.5, sig.level = .05, type = \"two.sample\",\n           alternative = \"two.sided\")\n\n\n     Two-sample t test power calculation \n\n              n = 30\n              d = 0.5\n      sig.level = 0.05\n          power = 0.4778965\n    alternative = two.sided\n\nNOTE: n is number in *each* group\n\n\nAls we willen weten welke steekproefgrootte nodig is om een effect van d = 0,8 met 80% power te detecteren, laten we n weg (maar specificeren wel p = 0.8):\n\npwr.t.test(d = 0.3, power = 0.8, sig.level = .05, type = \"two.sample\",\n           alternative = \"two.sided\")\n\n\n     Two-sample t test power calculation \n\n              n = 175.3847\n              d = 0.3\n      sig.level = 0.05\n          power = 0.8\n    alternative = two.sided\n\nNOTE: n is number in *each* group\n\n\nMeer informatie over pwr.t.test is te krijgen door ?pwr.t.test te typen in de R console.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Poweranalyse</span>"
    ]
  },
  {
    "objectID": "analysis_10_anova.html",
    "href": "analysis_10_anova.html",
    "title": "16  ANOVA",
    "section": "",
    "text": "16.1 One-way ANOVA\nWe kunnen de eenzijdige ANOVA (one-way ANOVA) berekenen met de functie aov uit package stats (een van de weinige packages die R automatisch laadt bij het opstarten):\nanova_out &lt;- aov(formula = pes19_lr_self_1 ~ pes19_province, \n                 data = canada)\nsummary(anova_out)\nDf Sum Sq Mean Sq F value   Pr(&gt;F)    \npes19_province   12    277  23.046   4.261 9.74e-07 ***\nResiduals      4356  23561   5.409                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n33453 observations deleted due to missingness\nDe samenvatting geeft de vrijheidsgraden (Df), de som van de kwadraten (Sum Sq), de gemiddelde kwadraten (Mean Sq), de F-waarde (F-waarde) en de p-waarde (Pr(&gt;F)).",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>ANOVA</span>"
    ]
  },
  {
    "objectID": "analysis_10_anova.html#one-way-anova",
    "href": "analysis_10_anova.html#one-way-anova",
    "title": "16  ANOVA",
    "section": "",
    "text": "anova_out &lt;- aov()\n\nDe functie aov berekent de ANOVA. We wijzen de resultaten toe aan object anova_out (je kunt elke geldige naam kiezen die je wilt).\n\nformula = pes19_lr_self_1 ~ pes19_province\n\nDit specificeert de te gebruiken formule in het formaat &lt;interval-ratio variabele&gt; ~ &lt;categoriale variabele&gt; . In ons voorbeeld is de interval-ratio variabele pes19_lr_self_1 en de categoriale (groeperings) variabele is pes19_provincie. Vervang voor je eigen gegevens door de juiste variabelen.\n\ndata = canada\n\nDit specificeert de te gebruiken dataset.\n\nsummary(anova_out)\n\nDit geeft een samenvatting van het door ons geschatte model (anova_out).\n\n\n\n\n\n\n\n\n\n\nRapportage\n\n\n\n\nEr is een significant verschil in de gemiddelde links-rechtsscores van inwoners van Canadese provincies, F(12, 4356) = 4,261, p &lt; 0,001.\n\nNoem dus in ieder geval:\n\nF met tussen haakjes de twee bijbehorende vrijheidsgraden = F-waarde\np = p-waarde. Maar: schrijf nooit \\(p = 0,000\\). Want de p-waarde is nooit precies nul, maar heel klein. Het is dan beter om te zeggen \\(p &lt; 0,001\\). Als je een handmatige toets uitvoert schrijf je p &lt; α-waarde, bijvoorbeeld \\(p &lt; 0,05\\).",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>ANOVA</span>"
    ]
  },
  {
    "objectID": "analysis_10_anova.html#paargewijze-t-toets-voor-het-vergelijken-van-gemiddelden-van-meerdere-groepen",
    "href": "analysis_10_anova.html#paargewijze-t-toets-voor-het-vergelijken-van-gemiddelden-van-meerdere-groepen",
    "title": "16  ANOVA",
    "section": "16.2 Paargewijze t-toets voor het vergelijken van gemiddelden van meerdere groepen",
    "text": "16.2 Paargewijze t-toets voor het vergelijken van gemiddelden van meerdere groepen\nWe kunnen een paarsgewijze t-toets gebruiken om de gemiddelden van alle mogelijke paren van groepen te vergelijken. We gebruiken een correctie voor meervoudige testen (bonferroni-correctie) om rekening te houden met het feit dat we veel t-toetsen uitvoeren:\n\npairwise.t.test(x = canada$pes19_lr_self_1,\n                g = canada$pes19_province,\n                p.adjust.method = \"bonferroni\",\n                alternative = \"two.sided\")\n\n\npairwise.t.test(…)\n\nDeze roept de functie pairwise.t.test aan om deze test uit te voeren. Deze is opgenomen in de stats packages, die automatisch worden geladen.\n\nx = canada$pes19_lr_self_1\n\nWe specificeren hier de interval-ratio variabele (in ons geval variabele pes19_lr_self_1 uit de dataset canada). We moeten het dollarteken gebruiken, dus &lt;dataset&gt;$&lt;variabelenaam&gt;.\n\ng = canada$pes19_province\n\nWe specificeren hier de groeperingsvariabele, opnieuw met behulp van de dollartekennotatie (zie hierboven).\n\np.adjust.method = \"bonferroni\"\n\nHiermee wordt aangegeven dat we de Bonferroni-correctie willen gebruiken.\n\nalternative = \"two.sided\"\n\nDit voert tweezijdige significantietoetsen uit (de standaard). Andere opties zijn \" greater\" en \"less\".\n\n\n\n\n\n    Pairwise comparisons using t tests with pooled SD \n\ndata:  canada$pes19_lr_self_1 and canada$pes19_province \n\n                          Alberta British Columbia Manitoba New Brunswick\nBritish Columbia          1.7e-06 -                -        -            \nManitoba                  0.022   1.000            -        -            \nNew Brunswick             0.041   1.000            1.000    -            \nNewfoundland and Labrador 0.066   1.000            1.000    1.000        \nNorthwest Territories     1.000   1.000            1.000    1.000        \nNova Scotia               0.034   1.000            1.000    1.000        \nNunavut                   1.000   1.000            1.000    1.000        \nOntario                   4.5e-06 1.000            1.000    1.000        \nPrince Edward Island      1.000   1.000            1.000    1.000        \nQuebec                    3.0e-05 1.000            1.000    1.000        \nSaskatchewan              1.000   1.000            1.000    1.000        \nYukon                     1.000   1.000            1.000    1.000        \n                          Newfoundland and Labrador Northwest Territories\nBritish Columbia          -                         -                    \nManitoba                  -                         -                    \nNew Brunswick             -                         -                    \nNewfoundland and Labrador -                         -                    \nNorthwest Territories     1.000                     -                    \nNova Scotia               1.000                     1.000                \nNunavut                   1.000                     1.000                \nOntario                   1.000                     1.000                \nPrince Edward Island      1.000                     1.000                \nQuebec                    1.000                     1.000                \nSaskatchewan              1.000                     1.000                \nYukon                     1.000                     1.000                \n                          Nova Scotia Nunavut Ontario Prince Edward Island\nBritish Columbia          -           -       -       -                   \nManitoba                  -           -       -       -                   \nNew Brunswick             -           -       -       -                   \nNewfoundland and Labrador -           -       -       -                   \nNorthwest Territories     -           -       -       -                   \nNova Scotia               -           -       -       -                   \nNunavut                   1.000       -       -       -                   \nOntario                   1.000       1.000   -       -                   \nPrince Edward Island      1.000       1.000   1.000   -                   \nQuebec                    1.000       1.000   1.000   1.000               \nSaskatchewan              1.000       1.000   1.000   1.000               \nYukon                     1.000       1.000   1.000   1.000               \n                          Quebec Saskatchewan\nBritish Columbia          -      -           \nManitoba                  -      -           \nNew Brunswick             -      -           \nNewfoundland and Labrador -      -           \nNorthwest Territories     -      -           \nNova Scotia               -      -           \nNunavut                   -      -           \nOntario                   -      -           \nPrince Edward Island      -      -           \nQuebec                    -      -           \nSaskatchewan              1.000  -           \nYukon                     1.000  1.000       \n\nP value adjustment method: bonferroni \n\n\n\n\n\n\n\n\nRapportage\n\n\n\nDe presentatie deze toetsen is afhankelijk van het aantal groepen. Een grafiek zoals hierboven gemaakt kan ook nuttig zijn, zeker als er veel groepen zijn.\n\nWe hebben getoetst er een verschil was in de links-rechtsplaatsing van burgers tussen elk paar van provincies met toepassing van een Bonferroni-correctie. Burgers uit Alberta plaatsten zich gemiddeld genomen rechtser (M = 5,81, SE = 0,10) dan burgers uit de meeste andere provincies (British Columbia, Manitoba, New Brunswick, Nova Scotia, Ontario en Quebec). Dit verschil is statistisch significant, waarbij de p = 0,041 of kleiner voor alle genoemde provincies. Tussen alle andere provincies bestond geen significant verschil in de links-rechtsplaatsing van burgers.",
    "crumbs": [
      "Statistische analyse in R",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>ANOVA</span>"
    ]
  },
  {
    "objectID": "common_errors.html",
    "href": "common_errors.html",
    "title": "Bijlage A — Veelgemaakte fouten in R",
    "section": "",
    "text": "A.1 Top-5 errors",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Veelgemaakte fouten in R</span>"
    ]
  },
  {
    "objectID": "common_errors.html#top-5-errors",
    "href": "common_errors.html#top-5-errors",
    "title": "Bijlage A — Veelgemaakte fouten in R",
    "section": "",
    "text": "Function not found\nThe difference between = and ==\nFile not found / No such file\nUpper and lower case\nUsing |&gt; instead of + in a ggplot",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Veelgemaakte fouten in R</span>"
    ]
  },
  {
    "objectID": "common_errors.html#syntax-errors",
    "href": "common_errors.html#syntax-errors",
    "title": "Bijlage A — Veelgemaakte fouten in R",
    "section": "A.2 Syntax errors",
    "text": "A.2 Syntax errors\n\nA.2.1 Upper and lower case\nR is case sensitive, which means that upper and lower case are not interchangeable:\n\nx &lt;- c(1,2,3,4,5)\nMean(x)  # Won't work, because the function mean starts with a lower case m\n\nError in Mean(x): could not find function \"Mean\"\n\n\nFix by using the correct case:\n\nx &lt;- c(1,2,3,4,5)\nmean(x)\n\n[1] 3\n\n\nVariable names are also case-sensitive:\n\nMyVariable = \"Hello\"\nprint(myvariable)  # Object not found, because we're using lower case here\n\nError in eval(expr, envir, enclos): object 'myvariable' not found\n\n\nFix by using the correct case:\n\nprint(MyVariable)\n\n[1] \"Hello\"\n\n\n\n\nA.2.2 Incomplete code\nA very common error by users is to not close a bracket. R needs ‘complete statements’ and if you execute ‘incomplete’ code with Enter/Return, R will not know where the command ends.\n\n# In this example a bracket is missing in the end and R will therefore assume the code is incomplete and wait\n((4+5)/(6 + 3) * 2\n\nIf you run this code, you will not get an error message but R will simply ‘wait’ for the rest and indicate this with a + sign. For example, in the example above, you will see the following output in the console:\n\n&gt; ((4+5)/(6 + 3) * 2\n+\n\nIn this case you can either write the missing part, i.e. the closing bracket, in the console (the window below) and click Enter/Return or, alternatively, click in the console and use the ‘Escape’ button (which will reset the console). You can then enter new (complete) code.\n\n\nA.2.3 Annotation errors\nIf you place code that you want R to execute behind an annotation, it will not run:\n\n# I am annotating this: x &lt;- c(1,2,3,4)\n\nFix:\n\n# I am annotating this\nx &lt;- c(1,2,3,4)\n\nThe same is true for annotation in a pipe:\n\nx &lt;- c(1,2,3,4)\nx |&gt;\n  mean() # annotation hello |&gt;\n\n[1] 2.5\n\n  sqrt()\n\nError in sqrt(): 0 arguments passed to 'sqrt' which requires 1\n\n\nFix:\n\nx &lt;- c(1,2,3,4)\nx |&gt;\n  mean() |&gt; # annotation hello \n  sqrt()\n\n[1] 1.581139\n\n\n\n\nA.2.4 Forgetting quotation marks around a character vector\nRemember that text (character vectors, also called strings) requires quotation marks around it:\n\nmy_text &lt;- Hello, this won't work\n\nError: &lt;text&gt;:1:17: unexpected ','\n1: my_text &lt;- Hello,\n                    ^\n\n\nWe normally use double quotation marks (\"), but single quotation marks will also work ('):\n\nmy_text &lt;- \"Hello, this works\"\nmy_text2 &lt;- 'Hello, this also works'\n\n\n\nA.2.5 Too many or too few brackets or quotation marks\nEvery bracket (() and every quotation mark (\") needs to be closed (once):\n\nx &lt;- c(1,2,3,4\n\nError: &lt;text&gt;:2:0: unexpected end of input\n1: x &lt;- c(1,2,3,4\n   ^\n\n\n\ny &lt;- \"Hello\n\nError: &lt;text&gt;:1:6: unexpected INCOMPLETE_STRING\n1: y &lt;- \"Hello\n         ^\n\n\n\nx &lt;- c(1,2,3,4))\n\nError: &lt;text&gt;:1:16: unexpected ')'\n1: x &lt;- c(1,2,3,4))\n                   ^\n\n\n\ny &lt;- \"Hello\"\"\n\nError: &lt;text&gt;:1:13: unexpected INCOMPLETE_STRING\n1: y &lt;- \"Hello\"\"\n                ^\n\n\n\nz &lt;- \"You cannot put a \"string\" inside a string\"\n\nError: &lt;text&gt;:1:25: unexpected symbol\n1: z &lt;- \"You cannot put a \"string\n                            ^\n\n\nIf you get unexpected symbol errors, it is often for this reason.\nIf you have a text with a double quotation mark in it, put \\ before it (this is called ‘escaping’, so R means that you mean to write a quotation mark and not announce the end of the character variable):\n\nmy_text &lt;- \"Is it \\\"normal\\\" to like R?\"\ncat(my_text)\n\nIs it \"normal\" to like R?\n\n\n\n\nA.2.6 The difference between = and ==\nPeople often confuse = and ==:\n\ndata(\"starwars\")\nstarwars |&gt;\n  mutate(height_inch == height / 2.54)\n\nError in `mutate()`:\nℹ In argument: `height_inch == height/2.54`.\nCaused by error:\n! object 'height_inch' not found\n\n\nHere we used two equal signs where one should be used. R thinks we are trying to make a comparison with height_inch (and throws an error, because it doesn’t exist) when we are trying to create a new variable called height_inch.\n\ndata(\"starwars\")\nstarwars |&gt;\n  filter(height = 150)\n\nError in `filter()`:\n! We detected a named input.\nℹ This usually means that you've used `=` instead of `==`.\nℹ Did you mean `height == 150`?\n\n\nHere we used a single equal sign, where we should have put two. In this case R recognizes the potential error and suggests that we need to two equal signs. Thanks R!\nRemember:\n\nOne equal sign (=) is used to assign a variable, for example in mutate:\n\ndta |&gt;\n  mutate(new_variable = old_variable + 10)\n\nTwo equal signs (==) are used when comparing or conditioning, for example in filter or case_when:\n\ndta |&gt;\n  filter(height == 200)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Veelgemaakte fouten in R</span>"
    ]
  },
  {
    "objectID": "common_errors.html#package-errors",
    "href": "common_errors.html#package-errors",
    "title": "Bijlage A — Veelgemaakte fouten in R",
    "section": "A.3 Package errors",
    "text": "A.3 Package errors\n\nA.3.1 Function not found\n\nPhi(data$econ, data$oecd)\n\nError in Phi(data$econ, data$oecd): could not find function \"Phi\"\n\n\nWe try to run a function, but R says it could not find it.\n\nHave you loaded the package that contains this function? In this example: library(DescTools)\nDid you spell the function name correctly, including the use of upper and lower case?\nIs this a custom function that is part of your code? You need to select and run the code that defines the function before referencing this function.\n\n\n\nA.3.2 Conflicting functions\nIf you load multiple packages which have functions with the same name, this can lead to conflicts. Usually, the last package loaded ‘masks’ functions with the same name from previously loaded packages. R will warn you about this when loading the packages, but you may not always be aware and as a result the wrong function is used.\n\n# Load tidyverse first, then expss\nlibrary(tidyverse)\nlibrary(expss)\n\n# Create an example data frame with one variable 'test'\ndta &lt;- tibble(test = letters[1:5]) \n\n# Try to call recode (from dplyr), but this is masked by recode from expss\ndta |&gt;\n  mutate(test2 = recode(test, \"a\" = \"b\"))\n\nError in `mutate()`:\nℹ In argument: `test2 = recode(test, a = \"b\")`.\nCaused by error in `FUN()`:\n! 'recode': all recodings should be formula but: \"b\"\n\n\nThere are various ways to address this problem:\n\nLoad the packages in the correct order, i.e. the last package is the one that you need any conflicting functions from:\n\n\nlibrary(expss)\nlibrary(tidyverse)\n\n\nUse packagename::function instead of just the function name:\n\n\n# We specify that we want to use recode from dplyr by writing dplyr::recode\ndta |&gt;\n  mutate(test2 = dplyr::recode(test, \"a\" = \"b\"))\n\n# A tibble: 5 × 2\n  test  test2\n  &lt;chr&gt; &lt;chr&gt;\n1 a     b    \n2 b     b    \n3 c     c    \n4 d     d    \n5 e     e    \n\n\n\nDetach a package you no longer need, for example:\n\n\ndetach(\"package:expss\", unload = TRUE)\n\n# Now there is no more conflict\ndta |&gt;\n  mutate(test2 = recode(test, \"a\" = \"b\"))\n\n# A tibble: 5 × 2\n  test  test2\n  &lt;chr&gt; &lt;chr&gt;\n1 a     b    \n2 b     b    \n3 c     c    \n4 d     d    \n5 e     e",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Veelgemaakte fouten in R</span>"
    ]
  },
  {
    "objectID": "common_errors.html#file-errors",
    "href": "common_errors.html#file-errors",
    "title": "Bijlage A — Veelgemaakte fouten in R",
    "section": "A.4 File errors",
    "text": "A.4 File errors\n\nA.4.1 File not found / No such file\nIf R cannot find a file you are trying to open:\n\nimport(\"file.csv\")\n\nError: No such file: file.csv\n\n\n\nCheck for typos and use of UPPER and lower case.\nDid you include the correct file extension (e.g. .csv, .sav, .por)?\nDoes the file indeed exist and is it located in the project folder (or working directory)? Type dir() in the Console to list the files in the current working directory. Using getwd() you can get the current working directory and this can be changed by setwd(). But the best practice is to work in an R project (a folder on your computer) where all your files are located (see week 1).\nPerhaps the file is in a sub-folder? For example, if the file is located in a folder called data, try import(\"data/file.csv\").",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Veelgemaakte fouten in R</span>"
    ]
  },
  {
    "objectID": "common_errors.html#data-preparation-and-transformation-errors",
    "href": "common_errors.html#data-preparation-and-transformation-errors",
    "title": "Bijlage A — Veelgemaakte fouten in R",
    "section": "A.5 Data preparation and transformation errors",
    "text": "A.5 Data preparation and transformation errors\n\nA.5.1 Forgetting to use mutate inside case_when\nWhen using case_when(), we must create a new variable in our recoding procedure with mutate(). Otherwise R will not know where to put the new, recoded data.\n\nlibrary(openintro) # This is where the data is from\ngpa_study_hours &lt;- gpa_study_hours |&gt;\n  case_when(\n          gpa &gt;= 3.7 ~ \"A\",\n          gpa &gt;= 3.3 ~ \"B\",\n          gpa &gt;= 1.7 ~ \"C\",\n          gpa &gt;= 1.3 ~ \"D\",\n          gpa &lt; 1.3 ~ \"F\")\n\nError in `case_when()`:\n! Case 1 (`gpa_study_hours`) must be a two-sided formula, not a\n  &lt;tbl_df/tbl/data.frame&gt; object.\n\n\nThe solution is to put the case_when statement inside mutate():\n\nlibrary(openintro) # This is where the data is from\ngpa_study_hours &lt;- gpa_study_hours |&gt;\n  mutate(grade = case_when(\n    gpa &gt;= 3.7 ~ \"A\",\n    gpa &gt;= 3.3 ~ \"B\",\n    gpa &gt;= 1.7 ~ \"C\",\n    gpa &gt;= 1.3 ~ \"D\",\n    gpa &lt; 1.3 ~ \"F\"))\n\n\n\nA.5.2 Not assigning the result\nIf you perform any operation that aims to modify data in your dataset (for example filter, select, mutate, etc.), you need to assign the result. Otherwise R will just print out your modifications but not save them in memory:\n\nexample_data &lt;- data.frame(x = c(1,2,3,4,5))\nexample_data |&gt;\n  mutate(y = x * 2)\n\n  x  y\n1 1  2\n2 2  4\n3 3  6\n4 4  8\n5 5 10\n\n\nR has printed out the result, but not saved it in example_data:\n\nprint(example_data) # No 'y', because we did not assign the result\n\n  x\n1 1\n2 2\n3 3\n4 4\n5 5\n\n\nIf you want to save the result, assign it to an object:\n\nexample_data &lt;- example_data |&gt;\n  mutate(y = x * 2)\nexample_data # Now 'y' has been stored in 'example_data'\n\n  x  y\n1 1  2\n2 2  4\n3 3  6\n4 4  8\n5 5 10\n\n\n\n\nA.5.3 Overwriting data\nIf you mutate a variable and save it to a variable with the same name, the original data is lost:\n\nexample_data &lt;- data.frame(x = c(1,2,3,4,5))\nexample_data\n\n  x\n1 1\n2 2\n3 3\n4 4\n5 5\n\nexample_data &lt;- example_data |&gt;\n  mutate(x = x + 10)\nexample_data\n\n   x\n1 11\n2 12\n3 13\n4 14\n5 15\n\n\n\n\nA.5.4 Missing data recoding using na_if: loss of generality\nIf you make a mistake in correctly spelling the value of a factor variable, when using the function na_if, you will get a ‘loss of generality’ error:\n\nexample_data &lt;- data.frame(drink = as.factor(c(\"Tea\", \"Coffee\", \"Coffee\", \"Milk\")))\n\n# Suppose we would like to mark 'Coffee' as missing values, and we write\nexample_data |&gt; \n  mutate(drink = na_if(drink, \"Koffee\")) # Note the spelling error in Coffee\n\nError in `mutate()`:\nℹ In argument: `drink = na_if(drink, \"Koffee\")`.\nCaused by error in `na_if()`:\n! Can't convert from `y` &lt;character&gt; to `x` &lt;factor&lt;b5ac8&gt;&gt; due to loss of generality.\n• Locations: 1\n\n\nIn more simple language: R cannot find a level ‘Koffee’ in the factor variable drink and this produces an error. If we correct the spelling error, this should work:\n\nexample_data |&gt; \n  mutate(drink = na_if(drink, \"Coffee\")) # This should work and produce missing values for the 2nd and 3rd row\n\n  drink\n1   Tea\n2  &lt;NA&gt;\n3  &lt;NA&gt;\n4  Milk",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Veelgemaakte fouten in R</span>"
    ]
  },
  {
    "objectID": "common_errors.html#ggplot2-errors",
    "href": "common_errors.html#ggplot2-errors",
    "title": "Bijlage A — Veelgemaakte fouten in R",
    "section": "A.6 ggplot2 errors",
    "text": "A.6 ggplot2 errors\n\nA.6.1 An empty graph\n\nHave you included a geom layer?\nHave you put a plus sign between the layers of the ggplot? (see below)\nHave you inadvertently used the pipe instead of the plus sign to connect layers?\n\n\n\nA.6.2 Forgetting the plus sign at the end of the line\nIf you do not include the plus sign at the end of the line, the next part of the graph is not seen as part of the current graph.\n\nlibrary(openintro)\ndata(loan50)\nggplot(data = loan50,\n       mapping = aes(x = interest_rate)) \n\n\n\n\n\n\n\ngeom_histogram()\n\ngeom_bar: na.rm = FALSE, orientation = NA\nstat_bin: binwidth = NULL, bins = NULL, na.rm = FALSE, orientation = NA, pad = FALSE\nposition_stack \n\n\nFix by adding the + sign at the end of the line:\n\nlibrary(openintro)\ndata(loan50)\nggplot(data = loan50,\n       mapping = aes(x = interest_rate)) +\n  geom_histogram()\n\n\n\n\n\n\n\n\n\n\nA.6.3 Using |&gt; instead of + in a ggplot\nPerhaps confusingly you should use the + sign to add layers to a ggplot, not the pipe |&gt; (or %&gt;%). This throws an error:\n\nlibrary(openintro)\ndata(loan50)\nggplot(data = loan50,\n       mapping = aes(x = interest_rate)) |&gt;\n  geom_histogram()\n\nError in `geom_histogram()`:\n! `mapping` must be created by `aes()`.\nℹ Did you use `%&gt;%` or `|&gt;` instead of `+`?\n\n\nFix by replacing the pipe by a plus sign:\n\nlibrary(openintro)\ndata(loan50)\nggplot(data = loan50,\n       mapping = aes(x = interest_rate)) +\n  geom_histogram()\n\n\n\n\n\n\n\n\n\n\nA.6.4 Forgetting aes()\nNote that if you want to assign variables to an aesthetic (an axis, colour, shape, etc.) you need to use aes(). This won’t work:\n\nlibrary(openintro)\ndata(loan50)\nggplot(data = loan50,\n       x = interest_rate) +\n  geom_histogram()\n\nError in `geom_histogram()`:\n! Problem while computing stat.\nℹ Error occurred in the 1st layer.\nCaused by error in `setup_params()`:\n! `stat_bin()` requires an x or y aesthetic.\n\n\nFix by including aes():\n\nlibrary(openintro)\ndata(loan50)\nggplot(data = loan50,\n       aes(x = interest_rate)) +\n  geom_histogram()\n\n\n\n\n\n\n\n\nForgetting aes() can also lead to ‘object not found’ errors, for example, when we forget to include aes() in the geom_point function:\n\nlibrary(openintro)\ndata(loan50)\nggplot(data = loan50, \n       mapping = aes(x = total_income, y = loan_amount)) +\n  geom_point(colour = homeownership)\n\nError in eval(expr, envir, enclos): object 'homeownership' not found\n\n\nR will interpret the above as setting the colour of all points to homeownership . It will look for an object called homeownership , which does not exist. You need to tell R that you are trying to map the colour of the points to the variable homeownership from the data frame you are using. Do that by putting aes() around colour = homeownership:\n\nlibrary(openintro)\ndata(loan50)\nggplot(data = loan50, \n       mapping = aes(x = total_income, y = loan_amount)) +\n  geom_point(aes(colour = homeownership))\n\n\n\n\n\n\n\n\n\n\nA.6.5 Colours do not match\nIf you are trying to set a fixed colour for a graph element, for example grey points in a scatterplot, you should not include aes() .\n\nlibrary(openintro)\ndata(loan50)\nggplot(data = loan50, \n       mapping = aes(x = total_income, y = loan_amount)) +\n  geom_point(aes(colour = \"grey\"))\n\n\n\n\n\n\n\n\nInstead of grey dots we get red dots! Why? Because we have told R to link the colour of the dots to a variable (or constant, really) “grey”. Think of it as adding a new variable to the dataset which has the same value for each case. R matches the first default colour (red) to use for all cases in the group (which are all cases in the graph).\nFix by removing aes():\n\nlibrary(openintro)\ndata(loan50)\nggplot(data = loan50, \n       mapping = aes(x = total_income, y = loan_amount)) +\n  geom_point(colour = \"grey\")\n\n\n\n\n\n\n\n\nRemember: use aes() when you want to link an element of the graph to a variable in your data. If you want to just change a fixed colour, border, etc. do not use aes().",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Veelgemaakte fouten in R</span>"
    ]
  },
  {
    "objectID": "common_errors.html#errors-in-using-statistical-functions",
    "href": "common_errors.html#errors-in-using-statistical-functions",
    "title": "Bijlage A — Veelgemaakte fouten in R",
    "section": "A.7 Errors in using statistical functions",
    "text": "A.7 Errors in using statistical functions\n\nA.7.1 Forgetting table() when using prop.test\nWhen using prop.test for data in a data frame, you need to include table() around the arguments. This will not work:\n\n# We are using variable am from mtcars which indicates if a car has automatic (0) or manual (1) transmission\nprop.test(mtcars$am)\n\nError in prop.test(mtcars$am): argument \"n\" is missing, with no default\n\n\nWe can fix this by putting table() around the variable(s):\n\n# We are using variable am from mtcars which indicates if a car has automatic (0) or manual (1) transmission\nprop.test(table(mtcars$am))\n\n\n    1-sample proportions test with continuity correction\n\ndata:  table(mtcars$am), null probability 0.5\nX-squared = 0.78125, df = 1, p-value = 0.3768\nalternative hypothesis: true p is not equal to 0.5\n95 percent confidence interval:\n 0.4078543 0.7578086\nsample estimates:\n      p \n0.59375",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Veelgemaakte fouten in R</span>"
    ]
  },
  {
    "objectID": "appendix_formulas.html",
    "href": "appendix_formulas.html",
    "title": "Bijlage B — Formules Statistiek I",
    "section": "",
    "text": "B.1 Beschrijvende statistieken",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Formules Statistiek I</span>"
    ]
  },
  {
    "objectID": "appendix_formulas.html#beschrijvende-statistieken",
    "href": "appendix_formulas.html#beschrijvende-statistieken",
    "title": "Bijlage B — Formules Statistiek I",
    "section": "",
    "text": "B.1.1 Gemiddelde (Mean)\n\\[\\bar{x} = \\frac{\\sum_{i = 1}^{n}x_{i}}{n}\\]\n\n\nB.1.2 Variantie (Variance)\n\\[s^{2} = \\frac{\\sum_{i = 1}^{n}{(x_{i} - \\bar{x})}^{2}}{N - 1}\\]\n\n\nB.1.3 Standaardafwijking (Standard deviation)\n\\[s = \\sqrt{s^{2}}\\]\n\n\nB.1.4 Interkwartielafstand (Interquartile range)\n\\[IQR = \\ Q_{3} - Q_{1}\\]\n\n\nB.1.5 Verwachte waarde van een discrete stochastische variabele (Expected Value of a Discrete Random Variable)\n\\[E(X) = \\ \\sum_{i = 1}^{k}{x_{i}P(X = x_{i})}\\]\n\n\nB.1.6 Algemene Formule voor de Variantie (General Variance Formula)\n\\[\\sigma^{2} = \\sum_{j = 1}^{k}{{(x_{j} - \\mu)}^{2}P(X = x_{j})}\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Formules Statistiek I</span>"
    ]
  },
  {
    "objectID": "appendix_formulas.html#kansrekening",
    "href": "appendix_formulas.html#kansrekening",
    "title": "Bijlage B — Formules Statistiek I",
    "section": "B.2 Kansrekening",
    "text": "B.2 Kansrekening\n\nB.2.1 Kans op gebeurtenis A (Probability of event A)\n\\[\nP(A)\n\\]\n\n\nB.2.2 Intersectie van gebeurtenissen (Intersection of events)\n\\[\nP(A \\cap B) = P(\\text{A and B})\n\\]\n\n\nB.2.3 Vereniging van gebeurtenissen (Union of events)\n\\[\nP(A \\cup B) = P(\\text{A or B})\n\\]\n\n\nB.2.4 Algemene somregel (General addition rule)\n\\[P(A\\ or\\ B) = P(A) + P(B) - P(A\\ and\\ B)\\]\n\n\nB.2.5 Voorwaardelijke kans (Conditional probability)\n\\[P\\left( A \\middle| B \\right) = \\ \\frac{P(A\\ and\\ B)}{P(B)}\\]\n\n\nB.2.6 Algemene productregel (General multiplication rule)\n\\[P(A\\ and\\ B) = P\\left( A \\middle| B \\right)*P(B)\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Formules Statistiek I</span>"
    ]
  },
  {
    "objectID": "appendix_formulas.html#normaalverdeling",
    "href": "appendix_formulas.html#normaalverdeling",
    "title": "Bijlage B — Formules Statistiek I",
    "section": "B.3 Normaalverdeling",
    "text": "B.3 Normaalverdeling\n\nB.3.1 Z-score\n\\[z = \\frac{x - \\mu}{\\sigma}\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Formules Statistiek I</span>"
    ]
  },
  {
    "objectID": "appendix_formulas.html#proporties",
    "href": "appendix_formulas.html#proporties",
    "title": "Bijlage B — Formules Statistiek I",
    "section": "B.4 Proporties",
    "text": "B.4 Proporties\n\nB.4.1 Betrouwbaarheidsinterval 1 proportie (Confidence interval 1 proportion)\n\\[CI = \\ \\hat{p}\\  \\pm z^{*}SE\\left( \\hat{p} \\right)\\]\n\\[SE\\left( \\hat{p} \\right) = \\sqrt{\\frac{\\hat{p}(1 - \\hat{p})}{N}}\\]\n\n\nB.4.2 Hypothesetoets 1 proportie (Hypothesis test 1 proportion)\n\\[Z = \\ \\frac{\\hat{p} - p_{0}}{SE}\\]\n\\[SE\\left( p_{0} \\right) = \\sqrt{\\frac{p_{0}(1 - p_{0})}{N}}\\]\n\n\nB.4.3 Betrouwbaarheidsinterval 2 onafhankelijke proporties (Confidence interval 2 independent proportions)\n\\[CI = {(\\hat{p}}_{1} - {\\hat{p}}_{2}) \\pm z^{*}SE\\left( {\\hat{p}}_{1} - {\\hat{p}}_{2} \\right)\\]\n\\[SE\\left( {\\hat{p}}_{1} - {\\hat{p}}_{2} \\right) = \\sqrt{\\frac{{\\hat{p}}_{1}\\left( 1 - {\\hat{p}}_{1} \\right)}{n_{1}} + \\frac{{\\hat{p}}_{2}(1 - {\\hat{p}}_{2})}{n_{2}}}\\]\n\n\nB.4.4 Hypothesetoets 2 onafhankelijke proporties (Hypothesis test 2 independent proportions)\n\\[Z = \\ \\frac{\\left( {\\hat{p}}_{1} - {\\hat{p}}_{2} \\right) - \\text{null value}}{SE}\\]\n\\[{\\hat{p}}_{pooled} = \\frac{{\\hat{p}}_{1}n_{1} + {\\hat{p}}_{2}n_{2}}{n_{1} + n_{2}}\\]\n\\[SE = \\sqrt{\\frac{{\\hat{p}}_{pooled}(1 - {\\hat{p}}_{pooled})}{n_{1}} + \\frac{{\\hat{p}}_{pooled}(1 - {\\hat{p}}_{pooled})}{n_{2}}}\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Formules Statistiek I</span>"
    ]
  },
  {
    "objectID": "appendix_formulas.html#chikwadraat-en-associatiematen",
    "href": "appendix_formulas.html#chikwadraat-en-associatiematen",
    "title": "Bijlage B — Formules Statistiek I",
    "section": "B.5 Chikwadraat en associatiematen",
    "text": "B.5 Chikwadraat en associatiematen\n\nB.5.1 Chi2 (\\(\\chi^{2}\\)) one-way\n\\[\\chi^{2} = \\sum_{i = 1}^{k}\\frac{{(O_{i} - E_{i})}^{2}}{E_{i}}\\]\n\\[df = k - 1\\]\n\n\nB.5.2 Chi2 (\\(\\chi^{2}\\)) two-way\n\\[ E_{i,j} = \\frac{kolomtotaal_j * rijtotaal_i}{tabeltotaal} \\]\n\\[\\chi^{2} = \\sum_{i,\\ j}^{}\\frac{{(O_{i,j} - E_{i,j})}^{2}}{E_{i,j}}\\]\n\\[ df = (R-1)(C-1) \\]\n\n\nB.5.3 Phi (\\(\\phi\\))\n\\[\\phi = \\sqrt{\\frac{\\chi^{2}}{N}}\\]\n\n\nB.5.4 Cramérs V\n\\[V = \\sqrt{\\frac{\\chi^{2}}{N*(Min.\\ van\\ r - 1,\\ c - 1)}}\\]\n\n\nB.5.5 Lambda (\\(\\lambda)\\)\n\\[\\lambda = \\frac{E1 - E2}{E1} = \\frac{\\text{original error} - \\text{remaining error}}{\\text{original error}}\\]\n\n\nB.5.6 Gamma (\\(\\gamma)\\)\n\\[\\gamma = \\frac{N_{s} - N_{d}}{N_{s} + N_{d}}\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Formules Statistiek I</span>"
    ]
  },
  {
    "objectID": "appendix_formulas.html#betrouwbaarheidsinterval-gemiddelde-en-t-toets",
    "href": "appendix_formulas.html#betrouwbaarheidsinterval-gemiddelde-en-t-toets",
    "title": "Bijlage B — Formules Statistiek I",
    "section": "B.6 Betrouwbaarheidsinterval gemiddelde en t-toets",
    "text": "B.6 Betrouwbaarheidsinterval gemiddelde en t-toets\n\nB.6.1 Standaardfout van het gemiddelde (Standard error of the mean)\n\\[SE = \\frac{s}{\\sqrt{N}}\\]\n\n\nB.6.2 Betrouwbaarheidsinterval gemiddelde (Confidence interval mean)\n\\[CI = \\bar{x} \\pm t_{df}^{*}*SE\\]\n\n\nB.6.3 t (enkele steekproef / one sample)\n\\[t = \\frac{\\bar{x} - \\mu_{0}}{s/\\sqrt{N}}\\]\n\\[ df = n - 1 \\]\n\n\nB.6.4 t (gepaarde steekproeven/paired samples)\n\\[t = \\frac{{\\bar{x}}_{diff} - \\mu_{diff}}{s_{diff}/\\sqrt{n_{diff}}}\\]\n\\[ df = n - 1 \\]\n\n\nB.6.5 Welch’s t-test (onafhankelijke steekproeven/ independent samples)\n\\[t = \\frac{{(\\bar{X}}_{1} - {\\bar{X}}_{2}) - (\\mu_{1} - \\mu_{2})}{SE}\\]\n\\[SE = \\ \\sqrt{\\frac{s_{1}^{2}}{n_{1}} + \\frac{s_{2}^{2}}{n_{2}}}\\]\n\n\nB.6.6 Cohen’s D (one sample)\n\\[d = \\frac{\\bar{X} - \\mu_{0}}{s}\\]\n\n\nB.6.7 Cohen’s D (gepaard/paired)\n\\[d = \\frac{\\bar{D} - \\mu_{0}}{s}\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Formules Statistiek I</span>"
    ]
  },
  {
    "objectID": "appendix_formulas.html#anova",
    "href": "appendix_formulas.html#anova",
    "title": "Bijlage B — Formules Statistiek I",
    "section": "B.7 ANOVA",
    "text": "B.7 ANOVA\n\nB.7.1 Som en gemiddelde van kwadraten tussen groepen (Sum and Mean Square between Groups)\n\\[MSG = \\frac{SSG}{{df}_{G}}\\]\n\\[SSG = \\sum_{i=1}^{k}{n_{i}{({\\bar{x}}_{i} - {\\bar{x}}_{grand})}^{2}}\\]\n\\[\\text{df}_{G} = k - 1\\]\n\n\nB.7.2 Som en gemiddelde kwadratische fout (Sum of squared error & mean squared error)\n\\[MSE = \\frac{SSE}{{df}_{E}}\\]\n\\[SSE = \\sum_{}^{}{(x_{ik} - {\\bar{x}}_{k})}^{2}\\]\n\\[{df}_{E} = n\\ –k\\]\n\n\nB.7.3 F (ANOVA)\n\\[F = \\frac{MSG}{MSE}\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Formules Statistiek I</span>"
    ]
  },
  {
    "objectID": "appendix_install_all_packages.html",
    "href": "appendix_install_all_packages.html",
    "title": "Bijlage C — Alle packages installeren",
    "section": "",
    "text": "Om alle gebruikte packages in één keer te installeren, kun je onderstaande code gebruiken:\n\npackage_list &lt;- c(\"tidyverse\", \"rio\", \"summarytools\", \"DescTools\", \"skimr\", \n                  \"correlation\", \"parameters\", \"performance\", \"effectsize\", \n                  \"see\", \"marginaleffects\", \"broom\", \"ggResidpanel\",\n                  \"rms\", \"car\", \"modelsummary\", \"gt\", \"gtsummary\", \"kableExtra\",\n                  \"knitr\", \"rmarkdown\", \"huxtable\", \"flextable\", \"lmtest\",\n                  \"openintro\", \"statsr\", \"tidymodels\", \"tinytex\", \n                  \"visdat\", \"patchwork\", \"ggpubr\", \"cowplot\", \"expss\",\n                  \"effsize\", \"foreign\", \"haven\", \"ggstance\", \"ggrepel\",\n                  \"ggsignif\", \"naniar\", \"openxlsx\", \"sjmisc\", \"crosstable\",\n                  \"sjlabelled\", \"psych\", \"dice\", \"pwr\", \"visualize\", \"infer\",\n                  \"sandwich\", \"sjPlot\", \"scales\")\n\ninstall.packages(package_list)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Alle packages installeren</span>"
    ]
  }
]